// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// SDL Dart Bindings
class SDL {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  SDL(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  SDL.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Allocate a new RGB surface.
  ///
  /// If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.
  /// If `depth` is greater than 8 bits, the pixel format is set using the
  /// [RGBA]mask parameters.
  ///
  /// The [RGBA]mask parameters are the bitmasks used to extract that color from
  /// a pixel. For instance, `Rmask` being 0xFF000000 means the red data is
  /// stored in the most significant byte. Using zeros for the RGB masks sets a
  /// default value, based on the depth. For example:
  ///
  /// ```c++
  /// SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);
  /// ```
  ///
  /// However, using zero for the Amask results in an Amask of 0.
  ///
  /// By default surfaces with an alpha mask are set up for blending as with:
  ///
  /// ```c++
  /// SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)
  /// ```
  ///
  /// You can change this by calling SDL_SetSurfaceBlendMode() and selecting a
  /// different `blendMode`.
  ///
  /// \param flags the flags are unused and should be set to 0
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param Rmask the red mask for the pixels
  /// \param Gmask the green mask for the pixels
  /// \param Bmask the blue mask for the pixels
  /// \param Amask the alpha mask for the pixels
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurface(
    int flags,
    int width,
    int height,
    int depth,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurface(
      flags,
      width,
      height,
      depth,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int, ffi.Int, ffi.Int,
              Uint32, Uint32, Uint32, Uint32)>>('SDL_CreateRGBSurface');
  late final _SDL_CreateRGBSurface = _SDL_CreateRGBSurfacePtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          int, int, int, int, int, int, int, int)>();

  /// Allocate a new RGB surface with a specific pixel format.
  ///
  /// This function operates mostly like SDL_CreateRGBSurface(), except instead
  /// of providing pixel color masks, you provide it with a predefined format
  /// from SDL_PixelFormatEnum.
  ///
  /// \param flags the flags are unused and should be set to 0
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param format the SDL_PixelFormatEnum for the new surface's pixel format.
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormat(
    int flags,
    int width,
    int height,
    int depth,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormat(
      flags,
      width,
      height,
      depth,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int, ffi.Int, ffi.Int,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormat');
  late final _SDL_CreateRGBSurfaceWithFormat =
      _SDL_CreateRGBSurfaceWithFormatPtr.asFunction<
          ffi.Pointer<SDL_Surface> Function(int, int, int, int, int)>();

  /// Allocate a new RGB surface with existing pixel data.
  ///
  /// This function operates mostly like SDL_CreateRGBSurface(), except it does
  /// not allocate memory for the pixel data, instead the caller provides an
  /// existing buffer of data for the surface to use.
  ///
  /// No copy is made of the pixel data. Pixel data is not managed automatically;
  /// you must free the surface before you free the pixel data.
  ///
  /// \param pixels a pointer to existing pixel data
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param pitch the pitch of the surface in bytes
  /// \param Rmask the red mask for the pixels
  /// \param Gmask the green mask for the pixels
  /// \param Bmask the blue mask for the pixels
  /// \param Amask the alpha mask for the pixels
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceFrom(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurfaceFrom(
      pixels,
      width,
      height,
      depth,
      pitch,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurfaceFromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              Uint32,
              Uint32,
              Uint32,
              Uint32)>>('SDL_CreateRGBSurfaceFrom');
  late final _SDL_CreateRGBSurfaceFrom =
      _SDL_CreateRGBSurfaceFromPtr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int, int, int, int)>();

  /// Allocate a new RGB surface with with a specific pixel format and existing
  /// pixel data.
  ///
  /// This function operates mostly like SDL_CreateRGBSurfaceFrom(), except
  /// instead of providing pixel color masks, you provide it with a predefined
  /// format from SDL_PixelFormatEnum.
  ///
  /// No copy is made of the pixel data. Pixel data is not managed automatically;
  /// you must free the surface before you free the pixel data.
  ///
  /// \param pixels a pointer to existing pixel data
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param pitch the pitch of the surface in bytes
  /// \param format the SDL_PixelFormatEnum for the new surface's pixel format.
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormatFrom(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormatFrom(
      pixels,
      width,
      height,
      depth,
      pitch,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormatFromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormatFrom');
  late final _SDL_CreateRGBSurfaceWithFormatFrom =
      _SDL_CreateRGBSurfaceWithFormatFromPtr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int)>();

  /// Free an RGB surface.
  ///
  /// It is safe to pass NULL to this function.
  ///
  /// \param surface the SDL_Surface to free.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_LoadBMP
  /// \sa SDL_LoadBMP_RW
  void SDL_FreeSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_FreeSurface(
      surface,
    );
  }

  late final _SDL_FreeSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_FreeSurface');
  late final _SDL_FreeSurface =
      _SDL_FreeSurfacePtr.asFunction<void Function(ffi.Pointer<SDL_Surface>)>();

  /// Set the palette used by a surface.
  ///
  /// A single palette can be shared with many surfaces.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param palette the SDL_Palette structure to use
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SetSurfacePalette(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetSurfacePalette(
      surface,
      palette,
    );
  }

  late final _SDL_SetSurfacePalettePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetSurfacePalette');
  late final _SDL_SetSurfacePalette = _SDL_SetSurfacePalettePtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Palette>)>();

  /// Set up a surface for directly accessing the pixels.
  ///
  /// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to
  /// and read from `surface->pixels`, using the pixel format stored in
  /// `surface->format`. Once you are done accessing the surface, you should use
  /// SDL_UnlockSurface() to release it.
  ///
  /// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to
  /// 0, then you can read and write to the surface at any time, and the pixel
  /// format of the surface will not change.
  ///
  /// \param surface the SDL_Surface structure to be locked
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MUSTLOCK
  /// \sa SDL_UnlockSurface
  int SDL_LockSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_LockSurface(
      surface,
    );
  }

  late final _SDL_LockSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_LockSurface');
  late final _SDL_LockSurface =
      _SDL_LockSurfacePtr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// Release a surface after directly accessing the pixels.
  ///
  /// \param surface the SDL_Surface structure to be unlocked
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockSurface
  void SDL_UnlockSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_UnlockSurface(
      surface,
    );
  }

  late final _SDL_UnlockSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_UnlockSurface');
  late final _SDL_UnlockSurface = _SDL_UnlockSurfacePtr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>)>();

  /// Load a BMP image from a seekable SDL data stream.
  ///
  /// The new surface should be freed with SDL_FreeSurface(). Not doing so will
  /// result in a memory leak.
  ///
  /// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.
  /// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap
  /// from a file, convert it to an SDL_Surface and then close the file.
  ///
  /// \param src the data stream for the surface
  /// \param freesrc non-zero to close the stream after being read
  /// \returns a pointer to a new SDL_Surface structure or NULL if there was an
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeSurface
  /// \sa SDL_RWFromFile
  /// \sa SDL_LoadBMP
  /// \sa SDL_SaveBMP_RW
  ffi.Pointer<SDL_Surface> SDL_LoadBMP_RW(
    ffi.Pointer<SDL_RWops> src,
    int freesrc,
  ) {
    return _SDL_LoadBMP_RW(
      src,
      freesrc,
    );
  }

  late final _SDL_LoadBMP_RWPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_RWops>, ffi.Int)>>('SDL_LoadBMP_RW');
  late final _SDL_LoadBMP_RW = _SDL_LoadBMP_RWPtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Save a surface to a seekable SDL data stream in BMP format.
  ///
  /// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
  /// BMP directly. Other RGB formats with 8-bit or higher get converted to a
  /// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
  /// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
  /// not supported.
  ///
  /// \param surface the SDL_Surface structure containing the image to be saved
  /// \param dst a data stream to save to
  /// \param freedst non-zero to close the stream after being written
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadBMP_RW
  /// \sa SDL_SaveBMP
  int SDL_SaveBMP_RW(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_RWops> dst,
    int freedst,
  ) {
    return _SDL_SaveBMP_RW(
      surface,
      dst,
      freedst,
    );
  }

  late final _SDL_SaveBMP_RWPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>,
              ffi.Int)>>('SDL_SaveBMP_RW');
  late final _SDL_SaveBMP_RW = _SDL_SaveBMP_RWPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>, int)>();

  /// Set the RLE acceleration hint for a surface.
  ///
  /// If RLE is enabled, color key and alpha blending blits are much faster, but
  /// the surface must be locked before directly accessing the pixels.
  ///
  /// \param surface the SDL_Surface structure to optimize
  /// \param flag 0 to disable, non-zero to enable RLE acceleration
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_LockSurface
  /// \sa SDL_UnlockSurface
  int SDL_SetSurfaceRLE(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
  ) {
    return _SDL_SetSurfaceRLE(
      surface,
      flag,
    );
  }

  late final _SDL_SetSurfaceRLEPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Int)>>(
      'SDL_SetSurfaceRLE');
  late final _SDL_SetSurfaceRLE = _SDL_SetSurfaceRLEPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Returns whether the surface is RLE enabled
  ///
  /// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \returns SDL_TRUE if the surface is RLE enabled, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_SetSurfaceRLE
  SDL_bool SDL_HasSurfaceRLE(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return SDL_bool.fromValue(_SDL_HasSurfaceRLE(
      surface,
    ));
  }

  late final _SDL_HasSurfaceRLEPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<SDL_Surface>)>>(
      'SDL_HasSurfaceRLE');
  late final _SDL_HasSurfaceRLE = _SDL_HasSurfaceRLEPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>)>();

  /// Set the color key (transparent pixel) in a surface.
  ///
  /// The color key defines a pixel value that will be treated as transparent in
  /// a blit. For example, one can use this to specify that cyan pixels should be
  /// considered transparent, and therefore not rendered.
  ///
  /// It is a pixel of the format used by the surface, as generated by
  /// SDL_MapRGB().
  ///
  /// RLE acceleration can substantially speed up blitting of images with large
  /// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param flag SDL_TRUE to enable color key, SDL_FALSE to disable color key
  /// \param key the transparent pixel
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_GetColorKey
  int SDL_SetColorKey(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
    int key,
  ) {
    return _SDL_SetColorKey(
      surface,
      flag,
      key,
    );
  }

  late final _SDL_SetColorKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int, Uint32)>>('SDL_SetColorKey');
  late final _SDL_SetColorKey = _SDL_SetColorKeyPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int)>();

  /// Returns whether the surface has a color key
  ///
  /// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \return SDL_TRUE if the surface has a color key, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_SetColorKey
  /// \sa SDL_GetColorKey
  SDL_bool SDL_HasColorKey(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return SDL_bool.fromValue(_SDL_HasColorKey(
      surface,
    ));
  }

  late final _SDL_HasColorKeyPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<SDL_Surface>)>>(
      'SDL_HasColorKey');
  late final _SDL_HasColorKey =
      _SDL_HasColorKeyPtr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// Get the color key (transparent pixel) for a surface.
  ///
  /// The color key is a pixel of the format used by the surface, as generated by
  /// SDL_MapRGB().
  ///
  /// If the surface doesn't have color key enabled this function returns -1.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param key a pointer filled in with the transparent pixel
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_SetColorKey
  int SDL_GetColorKey(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint32> key,
  ) {
    return _SDL_GetColorKey(
      surface,
      key,
    );
  }

  late final _SDL_GetColorKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint32>)>>('SDL_GetColorKey');
  late final _SDL_GetColorKey = _SDL_GetColorKeyPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint32>)>();

  /// Set an additional color value multiplied into blit operations.
  ///
  /// When this surface is blitted, during the blit operation each source color
  /// channel is modulated by the appropriate color value according to the
  /// following formula:
  ///
  /// `srcC = srcC * (color / 255)`
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param r the red color value multiplied into blit operations
  /// \param g the green color value multiplied into blit operations
  /// \param b the blue color value multiplied into blit operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceColorMod
  /// \sa SDL_SetSurfaceAlphaMod
  int SDL_SetSurfaceColorMod(
    ffi.Pointer<SDL_Surface> surface,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetSurfaceColorMod(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetSurfaceColorModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, Uint8, Uint8,
              Uint8)>>('SDL_SetSurfaceColorMod');
  late final _SDL_SetSurfaceColorMod = _SDL_SetSurfaceColorModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int, int)>();

  /// Get the additional color value multiplied into blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param r a pointer filled in with the current red color value
  /// \param g a pointer filled in with the current green color value
  /// \param b a pointer filled in with the current blue color value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceAlphaMod
  /// \sa SDL_SetSurfaceColorMod
  int SDL_GetSurfaceColorMod(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetSurfaceColorMod(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetSurfaceColorModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceColorMod');
  late final _SDL_GetSurfaceColorMod = _SDL_GetSurfaceColorModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Set an additional alpha value used in blit operations.
  ///
  /// When this surface is blitted, during the blit operation the source alpha
  /// value is modulated by this alpha value according to the following formula:
  ///
  /// `srcA = srcA * (alpha / 255)`
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param alpha the alpha value multiplied into blit operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceAlphaMod
  /// \sa SDL_SetSurfaceColorMod
  int SDL_SetSurfaceAlphaMod(
    ffi.Pointer<SDL_Surface> surface,
    int alpha,
  ) {
    return _SDL_SetSurfaceAlphaMod(
      surface,
      alpha,
    );
  }

  late final _SDL_SetSurfaceAlphaModPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Surface>, Uint8)>>(
      'SDL_SetSurfaceAlphaMod');
  late final _SDL_SetSurfaceAlphaMod = _SDL_SetSurfaceAlphaModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Get the additional alpha value used in blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param alpha a pointer filled in with the current alpha value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceColorMod
  /// \sa SDL_SetSurfaceAlphaMod
  int SDL_GetSurfaceAlphaMod(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> alpha,
  ) {
    return _SDL_GetSurfaceAlphaMod(
      surface,
      alpha,
    );
  }

  late final _SDL_GetSurfaceAlphaModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceAlphaMod');
  late final _SDL_GetSurfaceAlphaMod = _SDL_GetSurfaceAlphaModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>)>();

  /// Set the blend mode used for blit operations.
  ///
  /// To copy a surface to another surface (or texture) without blending with the
  /// existing data, the blendmode of the SOURCE surface should be set to
  /// `SDL_BLENDMODE_NONE`.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param blendMode the SDL_BlendMode to use for blit blending
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceBlendMode
  int SDL_SetSurfaceBlendMode(
    ffi.Pointer<SDL_Surface> surface,
    SDL_BlendMode blendMode,
  ) {
    return _SDL_SetSurfaceBlendMode(
      surface,
      blendMode.value,
    );
  }

  late final _SDL_SetSurfaceBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.UnsignedInt)>>('SDL_SetSurfaceBlendMode');
  late final _SDL_SetSurfaceBlendMode = _SDL_SetSurfaceBlendModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Get the blend mode used for blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param blendMode a pointer filled in with the current SDL_BlendMode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetSurfaceBlendMode
  int SDL_GetSurfaceBlendMode(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<ffi.UnsignedInt> blendMode,
  ) {
    return _SDL_GetSurfaceBlendMode(
      surface,
      blendMode,
    );
  }

  late final _SDL_GetSurfaceBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<ffi.UnsignedInt>)>>('SDL_GetSurfaceBlendMode');
  late final _SDL_GetSurfaceBlendMode = _SDL_GetSurfaceBlendModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// Set the clipping rectangle for a surface.
  ///
  /// When `surface` is the destination of a blit, only the area within the clip
  /// rectangle is drawn into.
  ///
  /// Note that blits are automatically clipped to the edges of the source and
  /// destination surfaces.
  ///
  /// \param surface the SDL_Surface structure to be clipped
  /// \param rect the SDL_Rect structure representing the clipping rectangle, or
  /// NULL to disable clipping
  /// \returns SDL_TRUE if the rectangle intersects the surface, otherwise
  /// SDL_FALSE and blits will be completely clipped.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_GetClipRect
  SDL_bool SDL_SetClipRect(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return SDL_bool.fromValue(_SDL_SetClipRect(
      surface,
      rect,
    ));
  }

  late final _SDL_SetClipRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetClipRect');
  late final _SDL_SetClipRect = _SDL_SetClipRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Get the clipping rectangle for a surface.
  ///
  /// When `surface` is the destination of a blit, only the area within the clip
  /// rectangle is drawn into.
  ///
  /// \param surface the SDL_Surface structure representing the surface to be
  /// clipped
  /// \param rect an SDL_Rect structure filled in with the clipping rectangle for
  /// the surface
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_SetClipRect
  void SDL_GetClipRect(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetClipRect(
      surface,
      rect,
    );
  }

  late final _SDL_GetClipRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_GetClipRect');
  late final _SDL_GetClipRect = _SDL_GetClipRectPtr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  ffi.Pointer<SDL_Surface> SDL_DuplicateSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_DuplicateSurface(
      surface,
    );
  }

  late final _SDL_DuplicateSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>)>>('SDL_DuplicateSurface');
  late final _SDL_DuplicateSurface = _SDL_DuplicateSurfacePtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>)>();

  /// Copy an existing surface to a new surface of the specified format.
  ///
  /// This function is used to optimize images for faster *repeat* blitting. This
  /// is accomplished by converting the original and storing the result as a new
  /// surface. The new, optimized surface can then be used as the source for
  /// future blits, making them faster.
  ///
  /// \param src the existing SDL_Surface structure to convert
  /// \param fmt the SDL_PixelFormat structure that the new surface is optimized
  /// for
  /// \param flags the flags are unused and should be set to 0; this is a
  /// leftover from SDL 1.2's API
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  /// \sa SDL_ConvertSurfaceFormat
  /// \sa SDL_CreateRGBSurface
  ffi.Pointer<SDL_Surface> SDL_ConvertSurface(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_PixelFormat> fmt,
    int flags,
  ) {
    return _SDL_ConvertSurface(
      src,
      fmt,
      flags,
    );
  }

  late final _SDL_ConvertSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_PixelFormat>, Uint32)>>('SDL_ConvertSurface');
  late final _SDL_ConvertSurface = _SDL_ConvertSurfacePtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_PixelFormat>, int)>();

  /// Copy an existing surface to a new surface of the specified format enum.
  ///
  /// This function operates just like SDL_ConvertSurface(), but accepts an
  /// SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,
  /// it might be easier to call but it doesn't have access to palette
  /// information for the destination surface, in case that would be important.
  ///
  /// \param src the existing SDL_Surface structure to convert
  /// \param pixel_format the SDL_PixelFormatEnum that the new surface is
  /// optimized for
  /// \param flags the flags are unused and should be set to 0; this is a
  /// leftover from SDL 1.2's API
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  /// \sa SDL_ConvertSurface
  /// \sa SDL_CreateRGBSurface
  ffi.Pointer<SDL_Surface> SDL_ConvertSurfaceFormat(
    ffi.Pointer<SDL_Surface> src,
    int pixel_format,
    int flags,
  ) {
    return _SDL_ConvertSurfaceFormat(
      src,
      pixel_format,
      flags,
    );
  }

  late final _SDL_ConvertSurfaceFormatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>, Uint32,
              Uint32)>>('SDL_ConvertSurfaceFormat');
  late final _SDL_ConvertSurfaceFormat =
      _SDL_ConvertSurfaceFormatPtr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>, int, int)>();

  /// Copy a block of pixels of one format to another format.
  ///
  /// \param width the width of the block to copy, in pixels
  /// \param height the height of the block to copy, in pixels
  /// \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
  /// \param src a pointer to the source pixels
  /// \param src_pitch the pitch of the source pixels, in bytes
  /// \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
  /// \param dst a pointer to be filled in with new pixel data
  /// \param dst_pitch the pitch of the destination pixels, in bytes
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_ConvertPixels(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_ConvertPixels(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_ConvertPixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_ConvertPixels');
  late final _SDL_ConvertPixels = _SDL_ConvertPixelsPtr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Premultiply the alpha on a block of pixels.
  ///
  /// This is safe to use with src == dst, but not for other overlapping areas.
  ///
  /// This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.
  ///
  /// \param width the width of the block to convert, in pixels
  /// \param height the height of the block to convert, in pixels
  /// \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
  /// \param src a pointer to the source pixels
  /// \param src_pitch the pitch of the source pixels, in bytes
  /// \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
  /// \param dst a pointer to be filled in with premultiplied pixel data
  /// \param dst_pitch the pitch of the destination pixels, in bytes
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_PremultiplyAlpha(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_PremultiplyAlpha(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_PremultiplyAlphaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_PremultiplyAlpha');
  late final _SDL_PremultiplyAlpha = _SDL_PremultiplyAlphaPtr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Perform a fast fill of a rectangle with a specific color.
  ///
  /// `color` should be a pixel of the format used by the surface, and can be
  /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
  /// alpha component then the destination is simply filled with that alpha
  /// information, no blending takes place.
  ///
  /// If there is a clip rectangle set on the destination (set via
  /// SDL_SetClipRect()), then this function will fill based on the intersection
  /// of the clip rectangle and `rect`.
  ///
  /// \param dst the SDL_Surface structure that is the drawing target
  /// \param rect the SDL_Rect structure representing the rectangle to fill, or
  /// NULL to fill the entire surface
  /// \param color the color to fill with
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FillRects
  int SDL_FillRect(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rect,
    int color,
  ) {
    return _SDL_FillRect(
      dst,
      rect,
      color,
    );
  }

  late final _SDL_FillRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              Uint32)>>('SDL_FillRect');
  late final _SDL_FillRect = _SDL_FillRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int)>();

  /// Perform a fast fill of a set of rectangles with a specific color.
  ///
  /// `color` should be a pixel of the format used by the surface, and can be
  /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
  /// alpha component then the destination is simply filled with that alpha
  /// information, no blending takes place.
  ///
  /// If there is a clip rectangle set on the destination (set via
  /// SDL_SetClipRect()), then this function will fill based on the intersection
  /// of the clip rectangle and `rect`.
  ///
  /// \param dst the SDL_Surface structure that is the drawing target
  /// \param rects an array of SDL_Rects representing the rectangles to fill.
  /// \param count the number of rectangles in the array
  /// \param color the color to fill with
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FillRect
  int SDL_FillRects(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rects,
    int count,
    int color,
  ) {
    return _SDL_FillRects(
      dst,
      rects,
      count,
      color,
    );
  }

  late final _SDL_FillRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              ffi.Int, Uint32)>>('SDL_FillRects');
  late final _SDL_FillRects = _SDL_FillRectsPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int, int)>();

  /// Perform a fast blit from the source surface to the destination surface.
  ///
  /// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a
  /// macro for this function with a less confusing name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  int SDL_UpperBlit(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlit(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlit');
  late final _SDL_UpperBlit = _SDL_UpperBlitPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform low-level surface blitting only.
  ///
  /// This is a semi-private blit function and it performs low-level surface
  /// blitting, assuming the input rectangles have already been clipped.
  ///
  /// Unless you know what you're doing, you should be using SDL_BlitSurface()
  /// instead.
  ///
  /// \param src the SDL_Surface structure to be copied from
  /// \param srcrect the SDL_Rect structure representing the rectangle to be
  /// copied, or NULL to copy the entire surface
  /// \param dst the SDL_Surface structure that is the blit target
  /// \param dstrect the SDL_Rect structure representing the rectangle that is
  /// copied into
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  int SDL_LowerBlit(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlit(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlit');
  late final _SDL_LowerBlit = _SDL_LowerBlitPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform a fast, low quality, stretch blit between two surfaces of the same
  /// format.
  ///
  /// Please use SDL_BlitScaled() instead.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SoftStretch(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretch(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretch');
  late final _SDL_SoftStretch = _SDL_SoftStretchPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform bilinear scaling between two surfaces of the same format, 32BPP.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_SoftStretchLinear(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretchLinear(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretchLinearPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretchLinear');
  late final _SDL_SoftStretchLinear = _SDL_SoftStretchLinearPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform a scaled surface copy to a destination surface.
  ///
  /// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is
  /// merely a macro for this function with a less confusing name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitScaled
  int SDL_UpperBlitScaled(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlitScaled(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlitScaledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlitScaled');
  late final _SDL_UpperBlitScaled = _SDL_UpperBlitScaledPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform low-level surface scaled blitting only.
  ///
  /// This is a semi-private function and it performs low-level surface blitting,
  /// assuming the input rectangles have already been clipped.
  ///
  /// \param src the SDL_Surface structure to be copied from
  /// \param srcrect the SDL_Rect structure representing the rectangle to be
  /// copied
  /// \param dst the SDL_Surface structure that is the blit target
  /// \param dstrect the SDL_Rect structure representing the rectangle that is
  /// copied into
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitScaled
  int SDL_LowerBlitScaled(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlitScaled(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlitScaledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlitScaled');
  late final _SDL_LowerBlitScaled = _SDL_LowerBlitScaledPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Set the YUV conversion mode
  ///
  /// \since This function is available since SDL 2.0.8.
  void SDL_SetYUVConversionMode(
    SDL_YUV_CONVERSION_MODE mode,
  ) {
    return _SDL_SetYUVConversionMode(
      mode.value,
    );
  }

  late final _SDL_SetYUVConversionModePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'SDL_SetYUVConversionMode');
  late final _SDL_SetYUVConversionMode =
      _SDL_SetYUVConversionModePtr.asFunction<void Function(int)>();

  /// Get the YUV conversion mode
  ///
  /// \since This function is available since SDL 2.0.8.
  SDL_YUV_CONVERSION_MODE SDL_GetYUVConversionMode() {
    return SDL_YUV_CONVERSION_MODE.fromValue(_SDL_GetYUVConversionMode());
  }

  late final _SDL_GetYUVConversionModePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'SDL_GetYUVConversionMode');
  late final _SDL_GetYUVConversionMode =
      _SDL_GetYUVConversionModePtr.asFunction<int Function()>();

  /// Get the YUV conversion mode, returning the correct mode for the resolution
  /// when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC
  ///
  /// \since This function is available since SDL 2.0.8.
  SDL_YUV_CONVERSION_MODE SDL_GetYUVConversionModeForResolution(
    int width,
    int height,
  ) {
    return SDL_YUV_CONVERSION_MODE
        .fromValue(_SDL_GetYUVConversionModeForResolution(
      width,
      height,
    ));
  }

  late final _SDL_GetYUVConversionModeForResolutionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Int, ffi.Int)>>(
          'SDL_GetYUVConversionModeForResolution');
  late final _SDL_GetYUVConversionModeForResolution =
      _SDL_GetYUVConversionModeForResolutionPtr.asFunction<
          int Function(int, int)>();

  /// Get the number of video drivers compiled into SDL.
  ///
  /// \returns a number >= 1 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetVideoDriver
  int SDL_GetNumVideoDrivers() {
    return _SDL_GetNumVideoDrivers();
  }

  late final _SDL_GetNumVideoDriversPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumVideoDrivers');
  late final _SDL_GetNumVideoDrivers =
      _SDL_GetNumVideoDriversPtr.asFunction<int Function()>();

  /// Get the name of a built in video driver.
  ///
  /// The video drivers are presented in the order in which they are normally
  /// checked during initialization.
  ///
  /// \param index the index of a video driver
  /// \returns the name of the video driver with the given **index**.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  ffi.Pointer<ffi.Char> SDL_GetVideoDriver(
    int index,
  ) {
    return _SDL_GetVideoDriver(
      index,
    );
  }

  late final _SDL_GetVideoDriverPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetVideoDriver');
  late final _SDL_GetVideoDriver =
      _SDL_GetVideoDriverPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Initialize the video subsystem, optionally specifying a video driver.
  ///
  /// This function initializes the video subsystem, setting up a connection to
  /// the window manager, etc, and determines the available display modes and
  /// pixel formats, but does not initialize a window or graphics mode.
  ///
  /// If you use this function and you haven't used the SDL_INIT_VIDEO flag with
  /// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()
  /// before calling SDL_Quit().
  ///
  /// It is safe to call this function multiple times. SDL_VideoInit() will call
  /// SDL_VideoQuit() itself if the video subsystem has already been initialized.
  ///
  /// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a
  /// specific `driver_name`.
  ///
  /// \param driver_name the name of a video driver to initialize, or NULL for
  /// the default driver
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  /// \sa SDL_GetVideoDriver
  /// \sa SDL_InitSubSystem
  /// \sa SDL_VideoQuit
  int SDL_VideoInit(
    ffi.Pointer<ffi.Char> driver_name,
  ) {
    return _SDL_VideoInit(
      driver_name,
    );
  }

  late final _SDL_VideoInitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_VideoInit');
  late final _SDL_VideoInit =
      _SDL_VideoInitPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Shut down the video subsystem, if initialized with SDL_VideoInit().
  ///
  /// This function closes all windows, and restores the original video mode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_VideoInit
  void SDL_VideoQuit() {
    return _SDL_VideoQuit();
  }

  late final _SDL_VideoQuitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_VideoQuit');
  late final _SDL_VideoQuit = _SDL_VideoQuitPtr.asFunction<void Function()>();

  /// Get the name of the currently initialized video driver.
  ///
  /// \returns the name of the current video driver or NULL if no driver has been
  /// initialized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  /// \sa SDL_GetVideoDriver
  ffi.Pointer<ffi.Char> SDL_GetCurrentVideoDriver() {
    return _SDL_GetCurrentVideoDriver();
  }

  late final _SDL_GetCurrentVideoDriverPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetCurrentVideoDriver');
  late final _SDL_GetCurrentVideoDriver = _SDL_GetCurrentVideoDriverPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the number of available video displays.
  ///
  /// \returns a number >= 1 or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayBounds
  int SDL_GetNumVideoDisplays() {
    return _SDL_GetNumVideoDisplays();
  }

  late final _SDL_GetNumVideoDisplaysPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GetNumVideoDisplays');
  late final _SDL_GetNumVideoDisplays =
      _SDL_GetNumVideoDisplaysPtr.asFunction<int Function()>();

  /// Get the name of a display in UTF-8 encoding.
  ///
  /// \param displayIndex the index of display from which the name should be
  /// queried
  /// \returns the name of a display or NULL for an invalid display index or
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDisplays
  ffi.Pointer<ffi.Char> SDL_GetDisplayName(
    int displayIndex,
  ) {
    return _SDL_GetDisplayName(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetDisplayName');
  late final _SDL_GetDisplayName =
      _SDL_GetDisplayNamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the desktop area represented by a display.
  ///
  /// The primary display (`displayIndex` zero) is always located at 0,0.
  ///
  /// \param displayIndex the index of the display to query
  /// \param rect the SDL_Rect structure filled in with the display bounds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayBounds(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayBounds(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayBoundsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<SDL_Rect>)>>(
      'SDL_GetDisplayBounds');
  late final _SDL_GetDisplayBounds = _SDL_GetDisplayBoundsPtr.asFunction<
      int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// Get the usable desktop area represented by a display.
  ///
  /// The primary display (`displayIndex` zero) is always located at 0,0.
  ///
  /// This is the same area as SDL_GetDisplayBounds() reports, but with portions
  /// reserved by the system removed. For example, on Apple's macOS, this
  /// subtracts the area occupied by the menu bar and dock.
  ///
  /// Setting a window to be fullscreen generally bypasses these unusable areas,
  /// so these are good guidelines for the maximum space available to a
  /// non-fullscreen window.
  ///
  /// The parameter `rect` is ignored if it is NULL.
  ///
  /// This function also returns -1 if the parameter `displayIndex` is out of
  /// range.
  ///
  /// \param displayIndex the index of the display to query the usable bounds
  /// from
  /// \param rect the SDL_Rect structure filled in with the display bounds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayUsableBounds(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayUsableBounds(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayUsableBoundsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<SDL_Rect>)>>(
      'SDL_GetDisplayUsableBounds');
  late final _SDL_GetDisplayUsableBounds = _SDL_GetDisplayUsableBoundsPtr
      .asFunction<int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// Get the dots/pixels-per-inch for a display.
  ///
  /// Diagonal, horizontal and vertical DPI can all be optionally returned if the
  /// appropriate parameter is non-NULL.
  ///
  /// A failure of this function usually means that either no DPI information is
  /// available or the `displayIndex` is out of range.
  ///
  /// **WARNING**: This reports the DPI that the hardware reports, and it is not
  /// always reliable! It is almost always better to use SDL_GetWindowSize() to
  /// find the window size, which might be in logical points instead of pixels,
  /// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),
  /// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare
  /// the two values to get an actual scaling value between the two. We will be
  /// rethinking how high-dpi details should be managed in SDL3 to make things
  /// more consistent, reliable, and clear.
  ///
  /// \param displayIndex the index of the display from which DPI information
  /// should be queried
  /// \param ddpi a pointer filled in with the diagonal DPI of the display; may
  /// be NULL
  /// \param hdpi a pointer filled in with the horizontal DPI of the display; may
  /// be NULL
  /// \param vdpi a pointer filled in with the vertical DPI of the display; may
  /// be NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayDPI(
    int displayIndex,
    ffi.Pointer<ffi.Float> ddpi,
    ffi.Pointer<ffi.Float> hdpi,
    ffi.Pointer<ffi.Float> vdpi,
  ) {
    return _SDL_GetDisplayDPI(
      displayIndex,
      ddpi,
      hdpi,
      vdpi,
    );
  }

  late final _SDL_GetDisplayDPIPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetDisplayDPI');
  late final _SDL_GetDisplayDPI = _SDL_GetDisplayDPIPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Get the orientation of a display.
  ///
  /// \param displayIndex the index of the display to query
  /// \returns The SDL_DisplayOrientation enum value of the display, or
  /// `SDL_ORIENTATION_UNKNOWN` if it isn't available.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_GetNumVideoDisplays
  SDL_DisplayOrientation SDL_GetDisplayOrientation(
    int displayIndex,
  ) {
    return SDL_DisplayOrientation.fromValue(_SDL_GetDisplayOrientation(
      displayIndex,
    ));
  }

  late final _SDL_GetDisplayOrientationPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Int)>>(
          'SDL_GetDisplayOrientation');
  late final _SDL_GetDisplayOrientation =
      _SDL_GetDisplayOrientationPtr.asFunction<int Function(int)>();

  /// Get the number of available display modes.
  ///
  /// The `displayIndex` needs to be in the range from 0 to
  /// SDL_GetNumVideoDisplays() - 1.
  ///
  /// \param displayIndex the index of the display to query
  /// \returns a number >= 1 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetNumDisplayModes(
    int displayIndex,
  ) {
    return _SDL_GetNumDisplayModes(
      displayIndex,
    );
  }

  late final _SDL_GetNumDisplayModesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GetNumDisplayModes');
  late final _SDL_GetNumDisplayModes =
      _SDL_GetNumDisplayModesPtr.asFunction<int Function(int)>();

  /// Get information about a specific display mode.
  ///
  /// The display modes are sorted in this priority:
  ///
  /// - width -> largest to smallest
  /// - height -> largest to smallest
  /// - bits per pixel -> more colors to fewer colors
  /// - packed pixel layout -> largest to smallest
  /// - refresh rate -> highest to lowest
  ///
  /// \param displayIndex the index of the display to query
  /// \param modeIndex the index of the display mode to query
  /// \param mode an SDL_DisplayMode structure filled in with the mode at
  /// `modeIndex`
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumDisplayModes
  int SDL_GetDisplayMode(
    int displayIndex,
    int modeIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDisplayMode(
      displayIndex,
      modeIndex,
      mode,
    );
  }

  late final _SDL_GetDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDisplayMode');
  late final _SDL_GetDisplayMode = _SDL_GetDisplayModePtr.asFunction<
      int Function(int, int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get information about the desktop's display mode.
  ///
  /// There's a difference between this function and SDL_GetCurrentDisplayMode()
  /// when SDL runs fullscreen and has changed the resolution. In that case this
  /// function will return the previous native display mode, and not the current
  /// display mode.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure filled in with the current display
  /// mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetCurrentDisplayMode
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_SetWindowDisplayMode
  int SDL_GetDesktopDisplayMode(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDesktopDisplayMode(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetDesktopDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDesktopDisplayMode');
  late final _SDL_GetDesktopDisplayMode = _SDL_GetDesktopDisplayModePtr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get information about the current display mode.
  ///
  /// There's a difference between this function and SDL_GetDesktopDisplayMode()
  /// when SDL runs fullscreen and has changed the resolution. In that case this
  /// function will return the current display mode, and not the previous native
  /// display mode.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure filled in with the current display
  /// mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDesktopDisplayMode
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumVideoDisplays
  /// \sa SDL_SetWindowDisplayMode
  int SDL_GetCurrentDisplayMode(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetCurrentDisplayMode(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetCurrentDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetCurrentDisplayMode');
  late final _SDL_GetCurrentDisplayMode = _SDL_GetCurrentDisplayModePtr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the closest match to the requested display mode.
  ///
  /// The available display modes are scanned and `closest` is filled in with the
  /// closest mode matching the requested mode and returned. The mode format and
  /// refresh rate default to the desktop mode if they are set to 0. The modes
  /// are scanned with size being first priority, format being second priority,
  /// and finally checking the refresh rate. If all the available modes are too
  /// small, then NULL is returned.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure containing the desired display
  /// mode
  /// \param closest an SDL_DisplayMode structure filled in with the closest
  /// match of the available display modes
  /// \returns the passed in value `closest` or NULL if no matching video mode
  /// was available; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumDisplayModes
  ffi.Pointer<SDL_DisplayMode> SDL_GetClosestDisplayMode(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
    ffi.Pointer<SDL_DisplayMode> closest,
  ) {
    return _SDL_GetClosestDisplayMode(
      displayIndex,
      mode,
      closest,
    );
  }

  late final _SDL_GetClosestDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_DisplayMode> Function(
              ffi.Int,
              ffi.Pointer<SDL_DisplayMode>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetClosestDisplayMode');
  late final _SDL_GetClosestDisplayMode =
      _SDL_GetClosestDisplayModePtr.asFunction<
          ffi.Pointer<SDL_DisplayMode> Function(int,
              ffi.Pointer<SDL_DisplayMode>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the index of the display containing a point
  ///
  /// \param point the point to query
  /// \returns the index of the display containing the point or a negative error
  /// code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.24.0.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetPointDisplayIndex(
    ffi.Pointer<SDL_Point> point,
  ) {
    return _SDL_GetPointDisplayIndex(
      point,
    );
  }

  late final _SDL_GetPointDisplayIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Point>)>>(
          'SDL_GetPointDisplayIndex');
  late final _SDL_GetPointDisplayIndex = _SDL_GetPointDisplayIndexPtr
      .asFunction<int Function(ffi.Pointer<SDL_Point>)>();

  /// Get the index of the display primarily containing a rect
  ///
  /// \param rect the rect to query
  /// \returns the index of the display entirely containing the rect or closest
  /// to the center of the rect on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.24.0.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetRectDisplayIndex(
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetRectDisplayIndex(
      rect,
    );
  }

  late final _SDL_GetRectDisplayIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Rect>)>>(
          'SDL_GetRectDisplayIndex');
  late final _SDL_GetRectDisplayIndex = _SDL_GetRectDisplayIndexPtr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>)>();

  /// Get the index of the display associated with a window.
  ///
  /// \param window the window to query
  /// \returns the index of the display containing the center of the window on
  /// success or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetWindowDisplayIndex(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowDisplayIndex(
      window,
    );
  }

  late final _SDL_GetWindowDisplayIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowDisplayIndex');
  late final _SDL_GetWindowDisplayIndex = _SDL_GetWindowDisplayIndexPtr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the display mode to use when a window is visible at fullscreen.
  ///
  /// This only affects the display mode used when the window is fullscreen. To
  /// change the window size when the window is not fullscreen, use
  /// SDL_SetWindowSize().
  ///
  /// \param window the window to affect
  /// \param mode the SDL_DisplayMode structure representing the mode to use, or
  /// NULL to use the window's dimensions and the desktop's format
  /// and refresh rate
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowDisplayMode
  /// \sa SDL_SetWindowFullscreen
  int SDL_SetWindowDisplayMode(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_SetWindowDisplayMode(
      window,
      mode,
    );
  }

  late final _SDL_SetWindowDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_SetWindowDisplayMode');
  late final _SDL_SetWindowDisplayMode =
      _SDL_SetWindowDisplayModePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Query the display mode to use when a window is visible at fullscreen.
  ///
  /// \param window the window to query
  /// \param mode an SDL_DisplayMode structure filled in with the fullscreen
  /// display mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowDisplayMode
  /// \sa SDL_SetWindowFullscreen
  int SDL_GetWindowDisplayMode(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetWindowDisplayMode(
      window,
      mode,
    );
  }

  late final _SDL_GetWindowDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetWindowDisplayMode');
  late final _SDL_GetWindowDisplayMode =
      _SDL_GetWindowDisplayModePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the raw ICC profile data for the screen the window is currently on.
  ///
  /// Data returned should be freed with SDL_free.
  ///
  /// \param window the window to query
  /// \param size the size of the ICC profile
  /// \returns the raw ICC profile data on success or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  ffi.Pointer<ffi.Void> SDL_GetWindowICCProfile(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _SDL_GetWindowICCProfile(
      window,
      size,
    );
  }

  late final _SDL_GetWindowICCProfilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Size>)>>('SDL_GetWindowICCProfile');
  late final _SDL_GetWindowICCProfile = _SDL_GetWindowICCProfilePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Size>)>();

  /// Get the pixel format associated with the window.
  ///
  /// \param window the window to query
  /// \returns the pixel format of the window on success or
  /// SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GetWindowPixelFormat(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowPixelFormat(
      window,
    );
  }

  late final _SDL_GetWindowPixelFormatPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowPixelFormat');
  late final _SDL_GetWindowPixelFormat = _SDL_GetWindowPixelFormatPtr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Create a window with the specified position, dimensions, and flags.
  ///
  /// `flags` may be any of the following OR'd together:
  ///
  /// - `SDL_WINDOW_FULLSCREEN`: fullscreen window
  /// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution
  /// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context
  /// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance
  /// - `SDL_WINDOW_METAL`: window usable with a Metal instance
  /// - `SDL_WINDOW_HIDDEN`: window is not visible
  /// - `SDL_WINDOW_BORDERLESS`: no window decoration
  /// - `SDL_WINDOW_RESIZABLE`: window can be resized
  /// - `SDL_WINDOW_MINIMIZED`: window is minimized
  /// - `SDL_WINDOW_MAXIMIZED`: window is maximized
  /// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus
  /// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if
  /// supported (>= SDL 2.0.1)
  ///
  /// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is
  /// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be
  /// queried later using SDL_GetWindowFlags().
  ///
  /// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
  /// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.
  ///
  /// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size
  /// in pixels may differ from its size in screen coordinates on platforms with
  /// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the
  /// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that
  /// when this flag is set, the drawable size can vary after the window is
  /// created and should be queried after major window events such as when the
  /// window is resized or moved between displays.
  ///
  /// If the window is set fullscreen, the width and height parameters `w` and
  /// `h` will not be used. However, invalid size parameters (e.g. too large) may
  /// still fail. Window size is actually limited to 16384 x 16384 for all
  /// platforms at window creation.
  ///
  /// If the window is created with any of the SDL_WINDOW_OPENGL or
  /// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
  /// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
  /// corresponding UnloadLibrary function is called by SDL_DestroyWindow().
  ///
  /// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
  /// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.
  ///
  /// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
  /// SDL_CreateWindow() will fail.
  ///
  /// On non-Apple devices, SDL requires you to either not link to the Vulkan
  /// loader or link to a dynamic library version. This limitation may be removed
  /// in a future version of SDL.
  ///
  /// \param title the title of the window, in UTF-8 encoding
  /// \param x the x position of the window, `SDL_WINDOWPOS_CENTERED`, or
  /// `SDL_WINDOWPOS_UNDEFINED`
  /// \param y the y position of the window, `SDL_WINDOWPOS_CENTERED`, or
  /// `SDL_WINDOWPOS_UNDEFINED`
  /// \param w the width of the window, in screen coordinates
  /// \param h the height of the window, in screen coordinates
  /// \param flags 0, or one or more SDL_WindowFlags OR'd together
  /// \returns the window that was created or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindowFrom
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateWindow(
    ffi.Pointer<ffi.Char> title,
    int x,
    int y,
    int w,
    int h,
    int flags,
  ) {
    return _SDL_CreateWindow(
      title,
      x,
      y,
      w,
      h,
      flags,
    );
  }

  late final _SDL_CreateWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int, ffi.Int, ffi.Int, Uint32)>>('SDL_CreateWindow');
  late final _SDL_CreateWindow = _SDL_CreateWindowPtr.asFunction<
      ffi.Pointer<SDL_Window> Function(
          ffi.Pointer<ffi.Char>, int, int, int, int, int)>();

  /// Create an SDL window from an existing native window.
  ///
  /// In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)
  /// the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured
  /// before using SDL_CreateWindowFrom().
  ///
  /// \param data a pointer to driver-dependent window creation data, typically
  /// your native window cast to a void*
  /// \returns the window that was created or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateWindowFrom(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _SDL_CreateWindowFrom(
      data,
    );
  }

  late final _SDL_CreateWindowFromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(
              ffi.Pointer<ffi.Void>)>>('SDL_CreateWindowFrom');
  late final _SDL_CreateWindowFrom = _SDL_CreateWindowFromPtr.asFunction<
      ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Void>)>();

  /// Get the numeric ID of a window.
  ///
  /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
  /// these events to specific SDL_Window objects.
  ///
  /// \param window the window to query
  /// \returns the ID of the window on success or 0 on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowFromID
  int SDL_GetWindowID(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowID(
      window,
    );
  }

  late final _SDL_GetWindowIDPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowID');
  late final _SDL_GetWindowID =
      _SDL_GetWindowIDPtr.asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window from a stored ID.
  ///
  /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
  /// these events to specific SDL_Window objects.
  ///
  /// \param id the ID of the window
  /// \returns the window associated with `id` or NULL if it doesn't exist; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowID
  ffi.Pointer<SDL_Window> SDL_GetWindowFromID(
    int id,
  ) {
    return _SDL_GetWindowFromID(
      id,
    );
  }

  late final _SDL_GetWindowFromIDPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function(Uint32)>>(
          'SDL_GetWindowFromID');
  late final _SDL_GetWindowFromID = _SDL_GetWindowFromIDPtr.asFunction<
      ffi.Pointer<SDL_Window> Function(int)>();

  /// Get the window flags.
  ///
  /// \param window the window to query
  /// \returns a mask of the SDL_WindowFlags associated with `window`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_HideWindow
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_MinimizeWindow
  /// \sa SDL_SetWindowFullscreen
  /// \sa SDL_SetWindowGrab
  /// \sa SDL_ShowWindow
  int SDL_GetWindowFlags(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowFlags(
      window,
    );
  }

  late final _SDL_GetWindowFlagsPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowFlags');
  late final _SDL_GetWindowFlags = _SDL_GetWindowFlagsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the title of a window.
  ///
  /// This string is expected to be in UTF-8 encoding.
  ///
  /// \param window the window to change
  /// \param title the desired window title in UTF-8 format
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowTitle
  void SDL_SetWindowTitle(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> title,
  ) {
    return _SDL_SetWindowTitle(
      window,
      title,
    );
  }

  late final _SDL_SetWindowTitlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>)>>('SDL_SetWindowTitle');
  late final _SDL_SetWindowTitle = _SDL_SetWindowTitlePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Char>)>();

  /// Get the title of a window.
  ///
  /// \param window the window to query
  /// \returns the title of the window in UTF-8 format or "" if there is no
  /// title.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowTitle
  ffi.Pointer<ffi.Char> SDL_GetWindowTitle(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowTitle(
      window,
    );
  }

  late final _SDL_GetWindowTitlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowTitle');
  late final _SDL_GetWindowTitle = _SDL_GetWindowTitlePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Window>)>();

  /// Set the icon for a window.
  ///
  /// \param window the window to change
  /// \param icon an SDL_Surface structure containing the icon for the window
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_SetWindowIcon(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Surface> icon,
  ) {
    return _SDL_SetWindowIcon(
      window,
      icon,
    );
  }

  late final _SDL_SetWindowIconPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Surface>)>>('SDL_SetWindowIcon');
  late final _SDL_SetWindowIcon = _SDL_SetWindowIconPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Surface>)>();

  /// Associate an arbitrary named pointer with a window.
  ///
  /// `name` is case-sensitive.
  ///
  /// \param window the window to associate with the pointer
  /// \param name the name of the pointer
  /// \param userdata the associated pointer
  /// \returns the previous value associated with `name`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowData
  ffi.Pointer<ffi.Void> SDL_SetWindowData(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetWindowData(
      window,
      name,
      userdata,
    );
  }

  late final _SDL_SetWindowDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowData');
  late final _SDL_SetWindowData = _SDL_SetWindowDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>();

  /// Retrieve the data pointer associated with a window.
  ///
  /// \param window the window to query
  /// \param name the name of the pointer
  /// \returns the value associated with `name`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowData
  ffi.Pointer<ffi.Void> SDL_GetWindowData(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetWindowData(
      window,
      name,
    );
  }

  late final _SDL_GetWindowDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>)>>('SDL_GetWindowData');
  late final _SDL_GetWindowData = _SDL_GetWindowDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Char>)>();

  /// Set the position of a window.
  ///
  /// The window coordinate origin is the upper left of the display.
  ///
  /// \param window the window to reposition
  /// \param x the x coordinate of the window in screen coordinates, or
  /// `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
  /// \param y the y coordinate of the window in screen coordinates, or
  /// `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowPosition
  void SDL_SetWindowPosition(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_SetWindowPosition(
      window,
      x,
      y,
    );
  }

  late final _SDL_SetWindowPositionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowPosition');
  late final _SDL_SetWindowPosition = _SDL_SetWindowPositionPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the position of a window.
  ///
  /// If you do not need the value for one of the positions a NULL may be passed
  /// in the `x` or `y` parameter.
  ///
  /// \param window the window to query
  /// \param x a pointer filled in with the x position of the window, in screen
  /// coordinates, may be NULL
  /// \param y a pointer filled in with the y position of the window, in screen
  /// coordinates, may be NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowPosition
  void SDL_GetWindowPosition(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetWindowPosition(
      window,
      x,
      y,
    );
  }

  late final _SDL_GetWindowPositionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowPosition');
  late final _SDL_GetWindowPosition = _SDL_GetWindowPositionPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Set the size of a window's client area.
  ///
  /// The window size in screen coordinates may differ from the size in pixels,
  /// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
  /// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to get the real client area size in pixels.
  ///
  /// Fullscreen windows automatically match the size of the display mode, and
  /// you should use SDL_SetWindowDisplayMode() to change their size.
  ///
  /// \param window the window to change
  /// \param w the width of the window in pixels, in screen coordinates, must be
  /// > 0
  /// \param h the height of the window in pixels, in screen coordinates, must be
  /// > 0
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSize
  /// \sa SDL_SetWindowDisplayMode
  void SDL_SetWindowSize(
    ffi.Pointer<SDL_Window> window,
    int w,
    int h,
  ) {
    return _SDL_SetWindowSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_SetWindowSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int, ffi.Int)>>('SDL_SetWindowSize');
  late final _SDL_SetWindowSize = _SDL_SetWindowSizePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the size of a window's client area.
  ///
  /// NULL can safely be passed as the `w` or `h` parameter if the width or
  /// height value is not desired.
  ///
  /// The window size in screen coordinates may differ from the size in pixels,
  /// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
  /// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),
  /// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the
  /// real client area size in pixels.
  ///
  /// \param window the window to query the width and height from
  /// \param w a pointer filled in with the width of the window, in screen
  /// coordinates, may be NULL
  /// \param h a pointer filled in with the height of the window, in screen
  /// coordinates, may be NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetDrawableSize
  /// \sa SDL_Vulkan_GetDrawableSize
  /// \sa SDL_SetWindowSize
  void SDL_GetWindowSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowSize');
  late final _SDL_GetWindowSize = _SDL_GetWindowSizePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Get the size of a window's borders (decorations) around the client area.
  ///
  /// Note: If this function fails (returns -1), the size values will be
  /// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the
  /// window in question was borderless.
  ///
  /// Note: This function may fail on systems where the window has not yet been
  /// decorated by the display server (for example, immediately after calling
  /// SDL_CreateWindow). It is recommended that you wait at least until the
  /// window has been presented and composited, so that the window system has a
  /// chance to decorate the window and provide the border dimensions to SDL.
  ///
  /// This function also returns -1 if getting the information is not supported.
  ///
  /// \param window the window to query the size values of the border
  /// (decorations) from
  /// \param top pointer to variable for storing the size of the top border; NULL
  /// is permitted
  /// \param left pointer to variable for storing the size of the left border;
  /// NULL is permitted
  /// \param bottom pointer to variable for storing the size of the bottom
  /// border; NULL is permitted
  /// \param right pointer to variable for storing the size of the right border;
  /// NULL is permitted
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowSize
  int SDL_GetWindowBordersSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> top,
    ffi.Pointer<ffi.Int> left,
    ffi.Pointer<ffi.Int> bottom,
    ffi.Pointer<ffi.Int> right,
  ) {
    return _SDL_GetWindowBordersSize(
      window,
      top,
      left,
      bottom,
      right,
    );
  }

  late final _SDL_GetWindowBordersSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowBordersSize');
  late final _SDL_GetWindowBordersSize =
      _SDL_GetWindowBordersSizePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Get the size of a window in pixels.
  ///
  /// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
  /// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a
  /// platform with high-DPI support (Apple calls this "Retina"), and not
  /// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.
  ///
  /// \param window the window from which the drawable size should be queried
  /// \param w a pointer to variable for storing the width in pixels, may be NULL
  /// \param h a pointer to variable for storing the height in pixels, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.26.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_GetWindowSize
  void SDL_GetWindowSizeInPixels(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowSizeInPixels(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowSizeInPixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowSizeInPixels');
  late final _SDL_GetWindowSizeInPixels =
      _SDL_GetWindowSizeInPixelsPtr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the minimum size of a window's client area.
  ///
  /// \param window the window to change
  /// \param min_w the minimum width of the window in pixels
  /// \param min_h the minimum height of the window in pixels
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMinimumSize
  /// \sa SDL_SetWindowMaximumSize
  void SDL_SetWindowMinimumSize(
    ffi.Pointer<SDL_Window> window,
    int min_w,
    int min_h,
  ) {
    return _SDL_SetWindowMinimumSize(
      window,
      min_w,
      min_h,
    );
  }

  late final _SDL_SetWindowMinimumSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowMinimumSize');
  late final _SDL_SetWindowMinimumSize = _SDL_SetWindowMinimumSizePtr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the minimum size of a window's client area.
  ///
  /// \param window the window to query
  /// \param w a pointer filled in with the minimum width of the window, may be
  /// NULL
  /// \param h a pointer filled in with the minimum height of the window, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMaximumSize
  /// \sa SDL_SetWindowMinimumSize
  void SDL_GetWindowMinimumSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowMinimumSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMinimumSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowMinimumSize');
  late final _SDL_GetWindowMinimumSize =
      _SDL_GetWindowMinimumSizePtr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the maximum size of a window's client area.
  ///
  /// \param window the window to change
  /// \param max_w the maximum width of the window in pixels
  /// \param max_h the maximum height of the window in pixels
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMaximumSize
  /// \sa SDL_SetWindowMinimumSize
  void SDL_SetWindowMaximumSize(
    ffi.Pointer<SDL_Window> window,
    int max_w,
    int max_h,
  ) {
    return _SDL_SetWindowMaximumSize(
      window,
      max_w,
      max_h,
    );
  }

  late final _SDL_SetWindowMaximumSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowMaximumSize');
  late final _SDL_SetWindowMaximumSize = _SDL_SetWindowMaximumSizePtr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the maximum size of a window's client area.
  ///
  /// \param window the window to query
  /// \param w a pointer filled in with the maximum width of the window, may be
  /// NULL
  /// \param h a pointer filled in with the maximum height of the window, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMinimumSize
  /// \sa SDL_SetWindowMaximumSize
  void SDL_GetWindowMaximumSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowMaximumSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMaximumSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowMaximumSize');
  late final _SDL_GetWindowMaximumSize =
      _SDL_GetWindowMaximumSizePtr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the border state of a window.
  ///
  /// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add
  /// or remove the border from the actual window. This is a no-op if the
  /// window's border already matches the requested state.
  ///
  /// You can't change the border state of a fullscreen window.
  ///
  /// \param window the window of which to change the border state
  /// \param bordered SDL_FALSE to remove border, SDL_TRUE to add border
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowBordered(
    ffi.Pointer<SDL_Window> window,
    SDL_bool bordered,
  ) {
    return _SDL_SetWindowBordered(
      window,
      bordered.value,
    );
  }

  late final _SDL_SetWindowBorderedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.UnsignedInt)>>('SDL_SetWindowBordered');
  late final _SDL_SetWindowBordered = _SDL_SetWindowBorderedPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set the user-resizable state of a window.
  ///
  /// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and
  /// allow/disallow user resizing of the window. This is a no-op if the window's
  /// resizable state already matches the requested state.
  ///
  /// You can't change the resizable state of a fullscreen window.
  ///
  /// \param window the window of which to change the resizable state
  /// \param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowResizable(
    ffi.Pointer<SDL_Window> window,
    SDL_bool resizable,
  ) {
    return _SDL_SetWindowResizable(
      window,
      resizable.value,
    );
  }

  late final _SDL_SetWindowResizablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.UnsignedInt)>>('SDL_SetWindowResizable');
  late final _SDL_SetWindowResizable = _SDL_SetWindowResizablePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set the window to always be above the others.
  ///
  /// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This
  /// will bring the window to the front and keep the window above the rest.
  ///
  /// \param window The window of which to change the always on top state
  /// \param on_top SDL_TRUE to set the window always on top, SDL_FALSE to
  /// disable
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowAlwaysOnTop(
    ffi.Pointer<SDL_Window> window,
    SDL_bool on_top,
  ) {
    return _SDL_SetWindowAlwaysOnTop(
      window,
      on_top.value,
    );
  }

  late final _SDL_SetWindowAlwaysOnTopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.UnsignedInt)>>('SDL_SetWindowAlwaysOnTop');
  late final _SDL_SetWindowAlwaysOnTop = _SDL_SetWindowAlwaysOnTopPtr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Show a window.
  ///
  /// \param window the window to show
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HideWindow
  /// \sa SDL_RaiseWindow
  void SDL_ShowWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_ShowWindow(
      window,
    );
  }

  late final _SDL_ShowWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_ShowWindow');
  late final _SDL_ShowWindow =
      _SDL_ShowWindowPtr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Hide a window.
  ///
  /// \param window the window to hide
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ShowWindow
  void SDL_HideWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_HideWindow(
      window,
    );
  }

  late final _SDL_HideWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_HideWindow');
  late final _SDL_HideWindow =
      _SDL_HideWindowPtr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Raise a window above other windows and set the input focus.
  ///
  /// \param window the window to raise
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_RaiseWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RaiseWindow(
      window,
    );
  }

  late final _SDL_RaiseWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RaiseWindow');
  late final _SDL_RaiseWindow =
      _SDL_RaiseWindowPtr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Make a window as large as possible.
  ///
  /// \param window the window to maximize
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MinimizeWindow
  /// \sa SDL_RestoreWindow
  void SDL_MaximizeWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MaximizeWindow(
      window,
    );
  }

  late final _SDL_MaximizeWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MaximizeWindow');
  late final _SDL_MaximizeWindow = _SDL_MaximizeWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Minimize a window to an iconic representation.
  ///
  /// \param window the window to minimize
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_RestoreWindow
  void SDL_MinimizeWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MinimizeWindow(
      window,
    );
  }

  late final _SDL_MinimizeWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MinimizeWindow');
  late final _SDL_MinimizeWindow = _SDL_MinimizeWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Restore the size and position of a minimized or maximized window.
  ///
  /// \param window the window to restore
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_MinimizeWindow
  void SDL_RestoreWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RestoreWindow(
      window,
    );
  }

  late final _SDL_RestoreWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RestoreWindow');
  late final _SDL_RestoreWindow = _SDL_RestoreWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Set a window's fullscreen state.
  ///
  /// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a
  /// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen
  /// that takes the size of the desktop; and 0 for windowed mode.
  ///
  /// \param window the window to change
  /// \param flags `SDL_WINDOW_FULLSCREEN`, `SDL_WINDOW_FULLSCREEN_DESKTOP` or 0
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowDisplayMode
  /// \sa SDL_SetWindowDisplayMode
  int SDL_SetWindowFullscreen(
    ffi.Pointer<SDL_Window> window,
    int flags,
  ) {
    return _SDL_SetWindowFullscreen(
      window,
      flags,
    );
  }

  late final _SDL_SetWindowFullscreenPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>, Uint32)>>(
      'SDL_SetWindowFullscreen');
  late final _SDL_SetWindowFullscreen = _SDL_SetWindowFullscreenPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, int)>();

  /// Return whether the window has a surface associated with it.
  ///
  /// \returns SDL_TRUE if there is a surface associated with the window, or
  /// SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.28.0.
  ///
  /// \sa SDL_GetWindowSurface
  SDL_bool SDL_HasWindowSurface(
    ffi.Pointer<SDL_Window> window,
  ) {
    return SDL_bool.fromValue(_SDL_HasWindowSurface(
      window,
    ));
  }

  late final _SDL_HasWindowSurfacePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_HasWindowSurface');
  late final _SDL_HasWindowSurface = _SDL_HasWindowSurfacePtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Get the SDL surface associated with the window.
  ///
  /// A new surface will be created with the optimal format for the window, if
  /// necessary. This surface will be freed when the window is destroyed. Do not
  /// free this surface.
  ///
  /// This surface will be invalidated if the window is resized. After resizing a
  /// window this function must be called again to return a valid surface.
  ///
  /// You may not combine this with 3D or the rendering API on this window.
  ///
  /// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.
  ///
  /// \param window the window to query
  /// \returns the surface associated with the window, or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DestroyWindowSurface
  /// \sa SDL_HasWindowSurface
  /// \sa SDL_UpdateWindowSurface
  /// \sa SDL_UpdateWindowSurfaceRects
  ffi.Pointer<SDL_Surface> SDL_GetWindowSurface(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowSurface(
      window,
    );
  }

  late final _SDL_GetWindowSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowSurface');
  late final _SDL_GetWindowSurface = _SDL_GetWindowSurfacePtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Window>)>();

  /// Copy the window surface to the screen.
  ///
  /// This is the function you use to reflect any changes to the surface on the
  /// screen.
  ///
  /// This function is equivalent to the SDL 1.2 API SDL_Flip().
  ///
  /// \param window the window to update
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_UpdateWindowSurfaceRects
  int SDL_UpdateWindowSurface(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_UpdateWindowSurface(
      window,
    );
  }

  late final _SDL_UpdateWindowSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_UpdateWindowSurface');
  late final _SDL_UpdateWindowSurface = _SDL_UpdateWindowSurfacePtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Copy areas of the window surface to the screen.
  ///
  /// This is the function you use to reflect changes to portions of the surface
  /// on the screen.
  ///
  /// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().
  ///
  /// Note that this function will update _at least_ the rectangles specified,
  /// but this is only intended as an optimization; in practice, this might
  /// update more of the screen (or all of the screen!), depending on what
  /// method SDL uses to send pixels to the system.
  ///
  /// \param window the window to update
  /// \param rects an array of SDL_Rect structures representing areas of the
  /// surface to copy, in pixels
  /// \param numrects the number of rectangles
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_UpdateWindowSurface
  int SDL_UpdateWindowSurfaceRects(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rects,
    int numrects,
  ) {
    return _SDL_UpdateWindowSurfaceRects(
      window,
      rects,
      numrects,
    );
  }

  late final _SDL_UpdateWindowSurfaceRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>,
              ffi.Int)>>('SDL_UpdateWindowSurfaceRects');
  late final _SDL_UpdateWindowSurfaceRects =
      _SDL_UpdateWindowSurfaceRectsPtr.asFunction<
          int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>, int)>();

  /// Destroy the surface associated with the window.
  ///
  /// \param window the window to update
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.28.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_HasWindowSurface
  int SDL_DestroyWindowSurface(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_DestroyWindowSurface(
      window,
    );
  }

  late final _SDL_DestroyWindowSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_DestroyWindowSurface');
  late final _SDL_DestroyWindowSurface = _SDL_DestroyWindowSurfacePtr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Set a window's input grab mode.
  ///
  /// When input is grabbed, the mouse is confined to the window. This function
  /// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the
  /// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().
  ///
  /// If the caller enables a grab while another window is currently grabbed, the
  /// other window loses its grab in favor of the caller's window.
  ///
  /// \param window the window for which the input grab mode should be set
  /// \param grabbed SDL_TRUE to grab input or SDL_FALSE to release input
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetGrabbedWindow
  /// \sa SDL_GetWindowGrab
  void SDL_SetWindowGrab(
    ffi.Pointer<SDL_Window> window,
    SDL_bool grabbed,
  ) {
    return _SDL_SetWindowGrab(
      window,
      grabbed.value,
    );
  }

  late final _SDL_SetWindowGrabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.UnsignedInt)>>('SDL_SetWindowGrab');
  late final _SDL_SetWindowGrab = _SDL_SetWindowGrabPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set a window's keyboard grab mode.
  ///
  /// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
  /// the Meta/Super key. Note that not all system keyboard shortcuts can be
  /// captured by applications (one example is Ctrl+Alt+Del on Windows).
  ///
  /// This is primarily intended for specialized applications such as VNC clients
  /// or VM frontends. Normal games should not use keyboard grab.
  ///
  /// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
  /// window is full-screen to ensure the user is not trapped in your
  /// application. If you have a custom keyboard shortcut to exit fullscreen
  /// mode, you may suppress this behavior with
  /// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.
  ///
  /// If the caller enables a grab while another window is currently grabbed, the
  /// other window loses its grab in favor of the caller's window.
  ///
  /// \param window The window for which the keyboard grab mode should be set.
  /// \param grabbed This is SDL_TRUE to grab keyboard, and SDL_FALSE to release.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowKeyboardGrab
  /// \sa SDL_SetWindowMouseGrab
  /// \sa SDL_SetWindowGrab
  void SDL_SetWindowKeyboardGrab(
    ffi.Pointer<SDL_Window> window,
    SDL_bool grabbed,
  ) {
    return _SDL_SetWindowKeyboardGrab(
      window,
      grabbed.value,
    );
  }

  late final _SDL_SetWindowKeyboardGrabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.UnsignedInt)>>('SDL_SetWindowKeyboardGrab');
  late final _SDL_SetWindowKeyboardGrab = _SDL_SetWindowKeyboardGrabPtr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set a window's mouse grab mode.
  ///
  /// Mouse grab confines the mouse cursor to the window.
  ///
  /// \param window The window for which the mouse grab mode should be set.
  /// \param grabbed This is SDL_TRUE to grab mouse, and SDL_FALSE to release.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowMouseGrab
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_SetWindowGrab
  void SDL_SetWindowMouseGrab(
    ffi.Pointer<SDL_Window> window,
    SDL_bool grabbed,
  ) {
    return _SDL_SetWindowMouseGrab(
      window,
      grabbed.value,
    );
  }

  late final _SDL_SetWindowMouseGrabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.UnsignedInt)>>('SDL_SetWindowMouseGrab');
  late final _SDL_SetWindowMouseGrab = _SDL_SetWindowMouseGrabPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Get a window's input grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if input is grabbed, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGrab
  SDL_bool SDL_GetWindowGrab(
    ffi.Pointer<SDL_Window> window,
  ) {
    return SDL_bool.fromValue(_SDL_GetWindowGrab(
      window,
    ));
  }

  late final _SDL_GetWindowGrabPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_GetWindowGrab');
  late final _SDL_GetWindowGrab =
      _SDL_GetWindowGrabPtr.asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window's keyboard grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if keyboard is grabbed, and SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_GetWindowGrab
  SDL_bool SDL_GetWindowKeyboardGrab(
    ffi.Pointer<SDL_Window> window,
  ) {
    return SDL_bool.fromValue(_SDL_GetWindowKeyboardGrab(
      window,
    ));
  }

  late final _SDL_GetWindowKeyboardGrabPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_GetWindowKeyboardGrab');
  late final _SDL_GetWindowKeyboardGrab = _SDL_GetWindowKeyboardGrabPtr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window's mouse grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if mouse is grabbed, and SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_GetWindowGrab
  SDL_bool SDL_GetWindowMouseGrab(
    ffi.Pointer<SDL_Window> window,
  ) {
    return SDL_bool.fromValue(_SDL_GetWindowMouseGrab(
      window,
    ));
  }

  late final _SDL_GetWindowMouseGrabPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_GetWindowMouseGrab');
  late final _SDL_GetWindowMouseGrab = _SDL_GetWindowMouseGrabPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Get the window that currently has an input grab enabled.
  ///
  /// \returns the window if input is grabbed or NULL otherwise.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetWindowGrab
  /// \sa SDL_SetWindowGrab
  ffi.Pointer<SDL_Window> SDL_GetGrabbedWindow() {
    return _SDL_GetGrabbedWindow();
  }

  late final _SDL_GetGrabbedWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetGrabbedWindow');
  late final _SDL_GetGrabbedWindow =
      _SDL_GetGrabbedWindowPtr.asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// Confines the cursor to the specified area of a window.
  ///
  /// Note that this does NOT grab the cursor, it only defines the area a cursor
  /// is restricted to when the window has mouse focus.
  ///
  /// \param window The window that will be associated with the barrier.
  /// \param rect A rectangle area in window-relative coordinates. If NULL the
  /// barrier for the specified window will be destroyed.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GetWindowMouseRect
  /// \sa SDL_SetWindowMouseGrab
  int SDL_SetWindowMouseRect(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetWindowMouseRect(
      window,
      rect,
    );
  }

  late final _SDL_SetWindowMouseRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetWindowMouseRect');
  late final _SDL_SetWindowMouseRect = _SDL_SetWindowMouseRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>)>();

  /// Get the mouse confinement rectangle of a window.
  ///
  /// \param window The window to query
  /// \returns A pointer to the mouse confinement rectangle of a window, or NULL
  /// if there isn't one.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_SetWindowMouseRect
  ffi.Pointer<SDL_Rect> SDL_GetWindowMouseRect(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowMouseRect(
      window,
    );
  }

  late final _SDL_GetWindowMouseRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Rect> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowMouseRect');
  late final _SDL_GetWindowMouseRect = _SDL_GetWindowMouseRectPtr.asFunction<
      ffi.Pointer<SDL_Rect> Function(ffi.Pointer<SDL_Window>)>();

  /// Set the brightness (gamma multiplier) for a given window's display.
  ///
  /// Despite the name and signature, this method sets the brightness of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().) The
  /// brightness set will not follow the window if it is moved to another
  /// display.
  ///
  /// Many platforms will refuse to set the display brightness in modern times.
  /// You are better off using a shader to adjust gamma during rendering, or
  /// something similar.
  ///
  /// \param window the window used to select the display whose brightness will
  /// be changed
  /// \param brightness the brightness (gamma multiplier) value to set where 0.0
  /// is completely dark and 1.0 is normal brightness
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowBrightness
  /// \sa SDL_SetWindowGammaRamp
  int SDL_SetWindowBrightness(
    ffi.Pointer<SDL_Window> window,
    double brightness,
  ) {
    return _SDL_SetWindowBrightness(
      window,
      brightness,
    );
  }

  late final _SDL_SetWindowBrightnessPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowBrightness');
  late final _SDL_SetWindowBrightness = _SDL_SetWindowBrightnessPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, double)>();

  /// Get the brightness (gamma multiplier) for a given window's display.
  ///
  /// Despite the name and signature, this method retrieves the brightness of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().)
  ///
  /// \param window the window used to select the display whose brightness will
  /// be queried
  /// \returns the brightness for the display where 0.0 is completely dark and
  /// 1.0 is normal brightness.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowBrightness
  double SDL_GetWindowBrightness(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowBrightness(
      window,
    );
  }

  late final _SDL_GetWindowBrightnessPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowBrightness');
  late final _SDL_GetWindowBrightness = _SDL_GetWindowBrightnessPtr.asFunction<
      double Function(ffi.Pointer<SDL_Window>)>();

  /// Set the opacity for a window.
  ///
  /// The parameter `opacity` will be clamped internally between 0.0f
  /// (transparent) and 1.0f (opaque).
  ///
  /// This function also returns -1 if setting the opacity isn't supported.
  ///
  /// \param window the window which will be made transparent or opaque
  /// \param opacity the opacity value (0.0f - transparent, 1.0f - opaque)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowOpacity
  int SDL_SetWindowOpacity(
    ffi.Pointer<SDL_Window> window,
    double opacity,
  ) {
    return _SDL_SetWindowOpacity(
      window,
      opacity,
    );
  }

  late final _SDL_SetWindowOpacityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowOpacity');
  late final _SDL_SetWindowOpacity = _SDL_SetWindowOpacityPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, double)>();

  /// Get the opacity of a window.
  ///
  /// If transparency isn't supported on this platform, opacity will be reported
  /// as 1.0f without error.
  ///
  /// The parameter `opacity` is ignored if it is NULL.
  ///
  /// This function also returns -1 if an invalid window was provided.
  ///
  /// \param window the window to get the current opacity value from
  /// \param out_opacity the float filled in (0.0f - transparent, 1.0f - opaque)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_SetWindowOpacity
  int SDL_GetWindowOpacity(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Float> out_opacity,
  ) {
    return _SDL_GetWindowOpacity(
      window,
      out_opacity,
    );
  }

  late final _SDL_GetWindowOpacityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetWindowOpacity');
  late final _SDL_GetWindowOpacity = _SDL_GetWindowOpacityPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Float>)>();

  /// Set the window as a modal for another window.
  ///
  /// \param modal_window the window that should be set modal
  /// \param parent_window the parent window for the modal window
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  int SDL_SetWindowModalFor(
    ffi.Pointer<SDL_Window> modal_window,
    ffi.Pointer<SDL_Window> parent_window,
  ) {
    return _SDL_SetWindowModalFor(
      modal_window,
      parent_window,
    );
  }

  late final _SDL_SetWindowModalForPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Window>)>>('SDL_SetWindowModalFor');
  late final _SDL_SetWindowModalFor = _SDL_SetWindowModalForPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Window>)>();

  /// Explicitly set input focus to the window.
  ///
  /// You almost certainly want SDL_RaiseWindow() instead of this function. Use
  /// this with caution, as you might give focus to a window that is completely
  /// obscured by other windows.
  ///
  /// \param window the window that should get the input focus
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_RaiseWindow
  int SDL_SetWindowInputFocus(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_SetWindowInputFocus(
      window,
    );
  }

  late final _SDL_SetWindowInputFocusPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_SetWindowInputFocus');
  late final _SDL_SetWindowInputFocus = _SDL_SetWindowInputFocusPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the gamma ramp for the display that owns a given window.
  ///
  /// Set the gamma translation table for the red, green, and blue channels of
  /// the video hardware. Each table is an array of 256 16-bit quantities,
  /// representing a mapping between the input and output for that channel. The
  /// input is the index into the array, and the output is the 16-bit gamma value
  /// at that index, scaled to the output color precision.
  ///
  /// Despite the name and signature, this method sets the gamma ramp of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma
  /// ramp set will not follow the window if it is moved to another display.
  ///
  /// \param window the window used to select the display whose gamma ramp will
  /// be changed
  /// \param red a 256 element array of 16-bit quantities representing the
  /// translation table for the red channel, or NULL
  /// \param green a 256 element array of 16-bit quantities representing the
  /// translation table for the green channel, or NULL
  /// \param blue a 256 element array of 16-bit quantities representing the
  /// translation table for the blue channel, or NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowGammaRamp
  int SDL_SetWindowGammaRamp(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_SetWindowGammaRamp(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_SetWindowGammaRampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_SetWindowGammaRamp');
  late final _SDL_SetWindowGammaRamp = _SDL_SetWindowGammaRampPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// Get the gamma ramp for a given window's display.
  ///
  /// Despite the name and signature, this method retrieves the gamma ramp of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().)
  ///
  /// \param window the window used to select the display whose gamma ramp will
  /// be queried
  /// \param red a 256 element array of 16-bit quantities filled in with the
  /// translation table for the red channel, or NULL
  /// \param green a 256 element array of 16-bit quantities filled in with the
  /// translation table for the green channel, or NULL
  /// \param blue a 256 element array of 16-bit quantities filled in with the
  /// translation table for the blue channel, or NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGammaRamp
  int SDL_GetWindowGammaRamp(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_GetWindowGammaRamp(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_GetWindowGammaRampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_GetWindowGammaRamp');
  late final _SDL_GetWindowGammaRamp = _SDL_GetWindowGammaRampPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// Provide a callback that decides if a window region has special properties.
  ///
  /// Normally windows are dragged and resized by decorations provided by the
  /// system window manager (a title bar, borders, etc), but for some apps, it
  /// makes sense to drag them from somewhere else inside the window itself; for
  /// example, one might have a borderless window that wants to be draggable from
  /// any part, or simulate its own title bar, etc.
  ///
  /// This function lets the app provide a callback that designates pieces of a
  /// given window as special. This callback is run during event processing if we
  /// need to tell the OS to treat a region of the window specially; the use of
  /// this callback is known as "hit testing."
  ///
  /// Mouse input may not be delivered to your application if it is within a
  /// special area; the OS will often apply that input to moving the window or
  /// resizing the window and not deliver it to the application.
  ///
  /// Specifying NULL for a callback disables hit-testing. Hit-testing is
  /// disabled by default.
  ///
  /// Platforms that don't support this functionality will return -1
  /// unconditionally, even if you're attempting to disable hit-testing.
  ///
  /// Your callback may fire at any time, and its firing does not indicate any
  /// specific behavior (for example, on Windows, this certainly might fire when
  /// the OS is deciding whether to drag your window, but it fires for lots of
  /// other reasons, too, some unrelated to anything you probably care about _and
  /// when the mouse isn't actually at the location it is testing_). Since this
  /// can fire at any time, you should try to keep your callback efficient,
  /// devoid of allocations, etc.
  ///
  /// \param window the window to set hit-testing on
  /// \param callback the function to call when doing a hit-test
  /// \param callback_data an app-defined void pointer passed to **callback**
  /// \returns 0 on success or -1 on error (including unsupported); call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  int SDL_SetWindowHitTest(
    ffi.Pointer<SDL_Window> window,
    SDL_HitTest callback,
    ffi.Pointer<ffi.Void> callback_data,
  ) {
    return _SDL_SetWindowHitTest(
      window,
      callback,
      callback_data,
    );
  }

  late final _SDL_SetWindowHitTestPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, SDL_HitTest,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowHitTest');
  late final _SDL_SetWindowHitTest = _SDL_SetWindowHitTestPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Window>, SDL_HitTest, ffi.Pointer<ffi.Void>)>();

  /// Request a window to demand attention from the user.
  ///
  /// \param window the window to be flashed
  /// \param operation the flash operation
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_FlashWindow(
    ffi.Pointer<SDL_Window> window,
    SDL_FlashOperation operation,
  ) {
    return _SDL_FlashWindow(
      window,
      operation.value,
    );
  }

  late final _SDL_FlashWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.UnsignedInt)>>('SDL_FlashWindow');
  late final _SDL_FlashWindow = _SDL_FlashWindowPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, int)>();

  /// Destroy a window.
  ///
  /// If `window` is NULL, this function will return immediately after setting
  /// the SDL error message to "Invalid window". See SDL_GetError().
  ///
  /// \param window the window to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_CreateWindowFrom
  void SDL_DestroyWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_DestroyWindow(
      window,
    );
  }

  late final _SDL_DestroyWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_DestroyWindow');
  late final _SDL_DestroyWindow = _SDL_DestroyWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Check whether the screensaver is currently enabled.
  ///
  /// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2
  /// the screensaver was enabled by default.
  ///
  /// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.
  ///
  /// \returns SDL_TRUE if the screensaver is enabled, SDL_FALSE if it is
  /// disabled.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DisableScreenSaver
  /// \sa SDL_EnableScreenSaver
  SDL_bool SDL_IsScreenSaverEnabled() {
    return SDL_bool.fromValue(_SDL_IsScreenSaverEnabled());
  }

  late final _SDL_IsScreenSaverEnabledPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'SDL_IsScreenSaverEnabled');
  late final _SDL_IsScreenSaverEnabled =
      _SDL_IsScreenSaverEnabledPtr.asFunction<int Function()>();

  /// Allow the screen to be blanked by a screen saver.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DisableScreenSaver
  /// \sa SDL_IsScreenSaverEnabled
  void SDL_EnableScreenSaver() {
    return _SDL_EnableScreenSaver();
  }

  late final _SDL_EnableScreenSaverPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_EnableScreenSaver');
  late final _SDL_EnableScreenSaver =
      _SDL_EnableScreenSaverPtr.asFunction<void Function()>();

  /// Prevent the screen from being blanked by a screen saver.
  ///
  /// If you disable the screensaver, it is automatically re-enabled when SDL
  /// quits.
  ///
  /// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2
  /// the screensaver was enabled by default.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_EnableScreenSaver
  /// \sa SDL_IsScreenSaverEnabled
  void SDL_DisableScreenSaver() {
    return _SDL_DisableScreenSaver();
  }

  late final _SDL_DisableScreenSaverPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_DisableScreenSaver');
  late final _SDL_DisableScreenSaver =
      _SDL_DisableScreenSaverPtr.asFunction<void Function()>();

  /// Dynamically load an OpenGL library.
  ///
  /// This should be done after initializing the video driver, but before
  /// creating any OpenGL windows. If no OpenGL library is loaded, the default
  /// library will be loaded upon creation of the first OpenGL window.
  ///
  /// If you do this, you need to retrieve all of the GL functions used in your
  /// program from the dynamic library using SDL_GL_GetProcAddress().
  ///
  /// \param path the platform dependent OpenGL library name, or NULL to open the
  /// default OpenGL library
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetProcAddress
  /// \sa SDL_GL_UnloadLibrary
  int SDL_GL_LoadLibrary(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _SDL_GL_LoadLibrary(
      path,
    );
  }

  late final _SDL_GL_LoadLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GL_LoadLibrary');
  late final _SDL_GL_LoadLibrary =
      _SDL_GL_LoadLibraryPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get an OpenGL function by name.
  ///
  /// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all
  /// GL functions must be retrieved this way. Usually this is used to retrieve
  /// function pointers to OpenGL extensions.
  ///
  /// There are some quirks to looking up OpenGL functions that require some
  /// extra care from the application. If you code carefully, you can handle
  /// these quirks without any platform-specific code, though:
  ///
  /// - On Windows, function pointers are specific to the current GL context;
  /// this means you need to have created a GL context and made it current
  /// before calling SDL_GL_GetProcAddress(). If you recreate your context or
  /// create a second context, you should assume that any existing function
  /// pointers aren't valid to use with it. This is (currently) a
  /// Windows-specific limitation, and in practice lots of drivers don't suffer
  /// this limitation, but it is still the way the wgl API is documented to
  /// work and you should expect crashes if you don't respect it. Store a copy
  /// of the function pointers that comes and goes with context lifespan.
  /// - On X11, function pointers returned by this function are valid for any
  /// context, and can even be looked up before a context is created at all.
  /// This means that, for at least some common OpenGL implementations, if you
  /// look up a function that doesn't exist, you'll get a non-NULL result that
  /// is _NOT_ safe to call. You must always make sure the function is actually
  /// available for a given GL context before calling it, by checking for the
  /// existence of the appropriate extension with SDL_GL_ExtensionSupported(),
  /// or verifying that the version of OpenGL you're using offers the function
  /// as core functionality.
  /// - Some OpenGL drivers, on all platforms, *will* return NULL if a function
  /// isn't supported, but you can't count on this behavior. Check for
  /// extensions you use, and if you get a NULL anyway, act as if that
  /// extension wasn't available. This is probably a bug in the driver, but you
  /// can code defensively for this scenario anyhow.
  /// - Just because you're on Linux/Unix, don't assume you'll be using X11.
  /// Next-gen display servers are waiting to replace it, and may or may not
  /// make the same promises about function pointers.
  /// - OpenGL function pointers must be declared `APIENTRY` as in the example
  /// code. This will ensure the proper calling convention is followed on
  /// platforms where this matters (Win32) thereby avoiding stack corruption.
  ///
  /// \param proc the name of an OpenGL function
  /// \returns a pointer to the named OpenGL function. The returned pointer
  /// should be cast to the appropriate function signature.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_ExtensionSupported
  /// \sa SDL_GL_LoadLibrary
  /// \sa SDL_GL_UnloadLibrary
  ffi.Pointer<ffi.Void> SDL_GL_GetProcAddress(
    ffi.Pointer<ffi.Char> proc,
  ) {
    return _SDL_GL_GetProcAddress(
      proc,
    );
  }

  late final _SDL_GL_GetProcAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>)>>('SDL_GL_GetProcAddress');
  late final _SDL_GL_GetProcAddress = _SDL_GL_GetProcAddressPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  /// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_LoadLibrary
  void SDL_GL_UnloadLibrary() {
    return _SDL_GL_UnloadLibrary();
  }

  late final _SDL_GL_UnloadLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_GL_UnloadLibrary');
  late final _SDL_GL_UnloadLibrary =
      _SDL_GL_UnloadLibraryPtr.asFunction<void Function()>();

  /// Check if an OpenGL extension is supported for the current context.
  ///
  /// This function operates on the current GL context; you must have created a
  /// context and it must be current before calling this function. Do not assume
  /// that all contexts you create will have the same set of extensions
  /// available, or that recreating an existing context will offer the same
  /// extensions again.
  ///
  /// While it's probably not a massive overhead, this function is not an O(1)
  /// operation. Check the extensions you care about after creating the GL
  /// context and save that information somewhere instead of calling the function
  /// every time you need to know.
  ///
  /// \param extension the name of the extension to check
  /// \returns SDL_TRUE if the extension is supported, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  SDL_bool SDL_GL_ExtensionSupported(
    ffi.Pointer<ffi.Char> extension1,
  ) {
    return SDL_bool.fromValue(_SDL_GL_ExtensionSupported(
      extension1,
    ));
  }

  late final _SDL_GL_ExtensionSupportedPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>)>>(
      'SDL_GL_ExtensionSupported');
  late final _SDL_GL_ExtensionSupported = _SDL_GL_ExtensionSupportedPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Reset all previously set OpenGL context attributes to their default values.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_GL_GetAttribute
  /// \sa SDL_GL_SetAttribute
  void SDL_GL_ResetAttributes() {
    return _SDL_GL_ResetAttributes();
  }

  late final _SDL_GL_ResetAttributesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_GL_ResetAttributes');
  late final _SDL_GL_ResetAttributes =
      _SDL_GL_ResetAttributesPtr.asFunction<void Function()>();

  /// Set an OpenGL window attribute before window creation.
  ///
  /// This function sets the OpenGL attribute `attr` to `value`. The requested
  /// attributes should be set before creating an OpenGL window. You should use
  /// SDL_GL_GetAttribute() to check the values after creating the OpenGL
  /// context, since the values obtained can differ from the requested ones.
  ///
  /// \param attr an SDL_GLattr enum value specifying the OpenGL attribute to set
  /// \param value the desired value for the attribute
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetAttribute
  /// \sa SDL_GL_ResetAttributes
  int SDL_GL_SetAttribute(
    SDL_GLattr attr,
    int value,
  ) {
    return _SDL_GL_SetAttribute(
      attr.value,
      value,
    );
  }

  late final _SDL_GL_SetAttributePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt, ffi.Int)>>(
          'SDL_GL_SetAttribute');
  late final _SDL_GL_SetAttribute =
      _SDL_GL_SetAttributePtr.asFunction<int Function(int, int)>();

  /// Get the actual value for an attribute from the current context.
  ///
  /// \param attr an SDL_GLattr enum value specifying the OpenGL attribute to get
  /// \param value a pointer filled in with the current value of `attr`
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_ResetAttributes
  /// \sa SDL_GL_SetAttribute
  int SDL_GL_GetAttribute(
    SDL_GLattr attr,
    ffi.Pointer<ffi.Int> value,
  ) {
    return _SDL_GL_GetAttribute(
      attr.value,
      value,
    );
  }

  late final _SDL_GL_GetAttributePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Int>)>>('SDL_GL_GetAttribute');
  late final _SDL_GL_GetAttribute = _SDL_GL_GetAttributePtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>)>();

  /// Create an OpenGL context for an OpenGL window, and make it current.
  ///
  /// Windows users new to OpenGL should note that, for historical reasons, GL
  /// functions added after OpenGL version 1.1 are not available by default.
  /// Those functions must be loaded at run-time, either with an OpenGL
  /// extension-handling library or with SDL_GL_GetProcAddress() and its related
  /// functions.
  ///
  /// SDL_GLContext is an alias for `void *`. It's opaque to the application.
  ///
  /// \param window the window to associate with the context
  /// \returns the OpenGL context associated with `window` or NULL on error; call
  /// SDL_GetError() for more details.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_DeleteContext
  /// \sa SDL_GL_MakeCurrent
  SDL_GLContext SDL_GL_CreateContext(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_CreateContext(
      window,
    );
  }

  late final _SDL_GL_CreateContextPtr = _lookup<
          ffi.NativeFunction<SDL_GLContext Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_GL_CreateContext');
  late final _SDL_GL_CreateContext = _SDL_GL_CreateContextPtr.asFunction<
      SDL_GLContext Function(ffi.Pointer<SDL_Window>)>();

  /// Set up an OpenGL context for rendering into an OpenGL window.
  ///
  /// The context must have been created with a compatible window.
  ///
  /// \param window the window to associate with the context
  /// \param context the OpenGL context to associate with the window
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_CreateContext
  int SDL_GL_MakeCurrent(
    ffi.Pointer<SDL_Window> window,
    SDL_GLContext context,
  ) {
    return _SDL_GL_MakeCurrent(
      window,
      context,
    );
  }

  late final _SDL_GL_MakeCurrentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, SDL_GLContext)>>('SDL_GL_MakeCurrent');
  late final _SDL_GL_MakeCurrent = _SDL_GL_MakeCurrentPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, SDL_GLContext)>();

  /// Get the currently active OpenGL window.
  ///
  /// \returns the currently active OpenGL window on success or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GL_GetCurrentWindow() {
    return _SDL_GL_GetCurrentWindow();
  }

  late final _SDL_GL_GetCurrentWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GL_GetCurrentWindow');
  late final _SDL_GL_GetCurrentWindow = _SDL_GL_GetCurrentWindowPtr.asFunction<
      ffi.Pointer<SDL_Window> Function()>();

  /// Get the currently active OpenGL context.
  ///
  /// \returns the currently active OpenGL context or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_MakeCurrent
  SDL_GLContext SDL_GL_GetCurrentContext() {
    return _SDL_GL_GetCurrentContext();
  }

  late final _SDL_GL_GetCurrentContextPtr =
      _lookup<ffi.NativeFunction<SDL_GLContext Function()>>(
          'SDL_GL_GetCurrentContext');
  late final _SDL_GL_GetCurrentContext =
      _SDL_GL_GetCurrentContextPtr.asFunction<SDL_GLContext Function()>();

  /// Get the size of a window's underlying drawable in pixels.
  ///
  /// This returns info useful for calling glViewport().
  ///
  /// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
  /// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a
  /// platform with high-DPI support (Apple calls this "Retina"), and not
  /// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.
  ///
  /// \param window the window from which the drawable size should be queried
  /// \param w a pointer to variable for storing the width in pixels, may be NULL
  /// \param h a pointer to variable for storing the height in pixels, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_GetWindowSize
  void SDL_GL_GetDrawableSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GL_GetDrawableSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GL_GetDrawableSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GL_GetDrawableSize');
  late final _SDL_GL_GetDrawableSize = _SDL_GL_GetDrawableSizePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Set the swap interval for the current OpenGL context.
  ///
  /// Some systems allow specifying -1 for the interval, to enable adaptive
  /// vsync. Adaptive vsync works the same as vsync, but if you've already missed
  /// the vertical retrace for a given frame, it swaps buffers immediately, which
  /// might be less jarring for the user during occasional framerate drops. If an
  /// application requests adaptive vsync and the system does not support it,
  /// this function will fail and return -1. In such a case, you should probably
  /// retry the call with 1 for the interval.
  ///
  /// Adaptive vsync is implemented for some glX drivers with
  /// GLX_EXT_swap_control_tear, and for some Windows drivers with
  /// WGL_EXT_swap_control_tear.
  ///
  /// Read more on the Khronos wiki:
  /// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync
  ///
  /// \param interval 0 for immediate updates, 1 for updates synchronized with
  /// the vertical retrace, -1 for adaptive vsync
  /// \returns 0 on success or -1 if setting the swap interval is not supported;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetSwapInterval
  int SDL_GL_SetSwapInterval(
    int interval,
  ) {
    return _SDL_GL_SetSwapInterval(
      interval,
    );
  }

  late final _SDL_GL_SetSwapIntervalPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GL_SetSwapInterval');
  late final _SDL_GL_SetSwapInterval =
      _SDL_GL_SetSwapIntervalPtr.asFunction<int Function(int)>();

  /// Get the swap interval for the current OpenGL context.
  ///
  /// If the system can't determine the swap interval, or there isn't a valid
  /// current context, this function will return 0 as a safe default.
  ///
  /// \returns 0 if there is no vertical retrace synchronization, 1 if the buffer
  /// swap is synchronized with the vertical retrace, and -1 if late
  /// swaps happen immediately instead of waiting for the next retrace;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_SetSwapInterval
  int SDL_GL_GetSwapInterval() {
    return _SDL_GL_GetSwapInterval();
  }

  late final _SDL_GL_GetSwapIntervalPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GL_GetSwapInterval');
  late final _SDL_GL_GetSwapInterval =
      _SDL_GL_GetSwapIntervalPtr.asFunction<int Function()>();

  /// Update a window with OpenGL rendering.
  ///
  /// This is used with double-buffered OpenGL contexts, which are the default.
  ///
  /// On macOS, make sure you bind 0 to the draw framebuffer before swapping the
  /// window, otherwise nothing will happen. If you aren't using
  /// glBindFramebuffer(), this is the default and you won't have to do anything
  /// extra.
  ///
  /// \param window the window to change
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_GL_SwapWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_SwapWindow(
      window,
    );
  }

  late final _SDL_GL_SwapWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GL_SwapWindow');
  late final _SDL_GL_SwapWindow = _SDL_GL_SwapWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Delete an OpenGL context.
  ///
  /// \param context the OpenGL context to be deleted
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_CreateContext
  void SDL_GL_DeleteContext(
    SDL_GLContext context,
  ) {
    return _SDL_GL_DeleteContext(
      context,
    );
  }

  late final _SDL_GL_DeleteContextPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_GLContext)>>(
          'SDL_GL_DeleteContext');
  late final _SDL_GL_DeleteContext =
      _SDL_GL_DeleteContextPtr.asFunction<void Function(SDL_GLContext)>();

  /// Get the window which currently has mouse focus.
  ///
  /// \returns the window with mouse focus.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GetMouseFocus() {
    return _SDL_GetMouseFocus();
  }

  late final _SDL_GetMouseFocusPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetMouseFocus');
  late final _SDL_GetMouseFocus =
      _SDL_GetMouseFocusPtr.asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// Retrieve the current state of the mouse.
  ///
  /// The current button state is returned as a button bitmask, which can be
  /// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the
  /// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the
  /// mouse cursor position relative to the focus window. You can pass NULL for
  /// either `x` or `y`.
  ///
  /// \param x the x coordinate of the mouse cursor position relative to the
  /// focus window
  /// \param y the y coordinate of the mouse cursor position relative to the
  /// focus window
  /// \returns a 32-bit button bitmask of the current button state.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetGlobalMouseState
  /// \sa SDL_GetRelativeMouseState
  /// \sa SDL_PumpEvents
  int SDL_GetMouseState(
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetMouseState(
      x,
      y,
    );
  }

  late final _SDL_GetMouseStatePtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetMouseState');
  late final _SDL_GetMouseState = _SDL_GetMouseStatePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Get the current state of the mouse in relation to the desktop.
  ///
  /// This works similarly to SDL_GetMouseState(), but the coordinates will be
  /// reported relative to the top-left of the desktop. This can be useful if you
  /// need to track the mouse outside of a specific window and SDL_CaptureMouse()
  /// doesn't fit your needs. For example, it could be useful if you need to
  /// track the mouse while dragging a window, where coordinates relative to a
  /// window might not be in sync at all times.
  ///
  /// Note: SDL_GetMouseState() returns the mouse position as SDL understands it
  /// from the last pump of the event queue. This function, however, queries the
  /// OS for the current mouse position, and as such, might be a slightly less
  /// efficient function. Unless you know what you're doing and have a good
  /// reason to use this function, you probably want SDL_GetMouseState() instead.
  ///
  /// \param x filled in with the current X coord relative to the desktop; can be
  /// NULL
  /// \param y filled in with the current Y coord relative to the desktop; can be
  /// NULL
  /// \returns the current button state as a bitmask which can be tested using
  /// the SDL_BUTTON(X) macros.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_CaptureMouse
  int SDL_GetGlobalMouseState(
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetGlobalMouseState(
      x,
      y,
    );
  }

  late final _SDL_GetGlobalMouseStatePtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetGlobalMouseState');
  late final _SDL_GetGlobalMouseState = _SDL_GetGlobalMouseStatePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Retrieve the relative state of the mouse.
  ///
  /// The current button state is returned as a button bitmask, which can be
  /// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the
  /// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the
  /// mouse deltas since the last call to SDL_GetRelativeMouseState() or since
  /// event initialization. You can pass NULL for either `x` or `y`.
  ///
  /// \param x a pointer filled with the last recorded x coordinate of the mouse
  /// \param y a pointer filled with the last recorded y coordinate of the mouse
  /// \returns a 32-bit button bitmask of the relative button state.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetMouseState
  int SDL_GetRelativeMouseState(
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetRelativeMouseState(
      x,
      y,
    );
  }

  late final _SDL_GetRelativeMouseStatePtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetRelativeMouseState');
  late final _SDL_GetRelativeMouseState = _SDL_GetRelativeMouseStatePtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Move the mouse cursor to the given position within the window.
  ///
  /// This function generates a mouse motion event if relative mode is not
  /// enabled. If relative mode is enabled, you can force mouse events for the
  /// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.
  ///
  /// Note that this function will appear to succeed, but not actually move the
  /// mouse when used over Microsoft Remote Desktop.
  ///
  /// \param window the window to move the mouse into, or NULL for the current
  /// mouse focus
  /// \param x the x coordinate within the window
  /// \param y the y coordinate within the window
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WarpMouseGlobal
  void SDL_WarpMouseInWindow(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_WarpMouseInWindow(
      window,
      x,
      y,
    );
  }

  late final _SDL_WarpMouseInWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_WarpMouseInWindow');
  late final _SDL_WarpMouseInWindow = _SDL_WarpMouseInWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Move the mouse to the given position in global screen space.
  ///
  /// This function generates a mouse motion event.
  ///
  /// A failure of this function usually means that it is unsupported by a
  /// platform.
  ///
  /// Note that this function will appear to succeed, but not actually move the
  /// mouse when used over Microsoft Remote Desktop.
  ///
  /// \param x the x coordinate
  /// \param y the y coordinate
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_WarpMouseInWindow
  int SDL_WarpMouseGlobal(
    int x,
    int y,
  ) {
    return _SDL_WarpMouseGlobal(
      x,
      y,
    );
  }

  late final _SDL_WarpMouseGlobalPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'SDL_WarpMouseGlobal');
  late final _SDL_WarpMouseGlobal =
      _SDL_WarpMouseGlobalPtr.asFunction<int Function(int, int)>();

  /// Set relative mouse mode.
  ///
  /// While the mouse is in relative mode, the cursor is hidden, the mouse
  /// position is constrained to the window, and SDL will report continuous
  /// relative mouse motion even if the mouse is at the edge of the window.
  ///
  /// This function will flush any pending mouse motion.
  ///
  /// \param enabled SDL_TRUE to enable relative mode, SDL_FALSE to disable.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// If relative mode is not supported, this returns -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRelativeMouseMode
  int SDL_SetRelativeMouseMode(
    SDL_bool enabled,
  ) {
    return _SDL_SetRelativeMouseMode(
      enabled.value,
    );
  }

  late final _SDL_SetRelativeMouseModePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'SDL_SetRelativeMouseMode');
  late final _SDL_SetRelativeMouseMode =
      _SDL_SetRelativeMouseModePtr.asFunction<int Function(int)>();

  /// Capture the mouse and to track input outside an SDL window.
  ///
  /// Capturing enables your app to obtain mouse events globally, instead of just
  /// within your window. Not all video targets support this function. When
  /// capturing is enabled, the current window will get all mouse events, but
  /// unlike relative mode, no change is made to the cursor and it is not
  /// restrained to your window.
  ///
  /// This function may also deny mouse input to other windows--both those in
  /// your application and others on the system--so you should use this function
  /// sparingly, and in small bursts. For example, you might want to track the
  /// mouse while the user is dragging something, until the user releases a mouse
  /// button. It is not recommended that you capture the mouse for long periods
  /// of time, such as the entire time your app is running. For that, you should
  /// probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending
  /// on your goals.
  ///
  /// While captured, mouse events still report coordinates relative to the
  /// current (foreground) window, but those coordinates may be outside the
  /// bounds of the window (including negative values). Capturing is only allowed
  /// for the foreground window. If the window loses focus while capturing, the
  /// capture will be disabled automatically.
  ///
  /// While capturing is enabled, the current window will have the
  /// `SDL_WINDOW_MOUSE_CAPTURE` flag set.
  ///
  /// Please note that as of SDL 2.0.22, SDL will attempt to "auto capture" the
  /// mouse while the user is pressing a button; this is to try and make mouse
  /// behavior more consistent between platforms, and deal with the common case
  /// of a user dragging the mouse outside of the window. This means that if you
  /// are calling SDL_CaptureMouse() only to deal with this situation, you no
  /// longer have to (although it is safe to do so). If this causes problems for
  /// your app, you can disable auto capture by setting the
  /// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.
  ///
  /// \param enabled SDL_TRUE to enable capturing, SDL_FALSE to disable.
  /// \returns 0 on success or -1 if not supported; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetGlobalMouseState
  int SDL_CaptureMouse(
    SDL_bool enabled,
  ) {
    return _SDL_CaptureMouse(
      enabled.value,
    );
  }

  late final _SDL_CaptureMousePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'SDL_CaptureMouse');
  late final _SDL_CaptureMouse =
      _SDL_CaptureMousePtr.asFunction<int Function(int)>();

  /// Query whether relative mouse mode is enabled.
  ///
  /// \returns SDL_TRUE if relative mode is enabled or SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRelativeMouseMode
  SDL_bool SDL_GetRelativeMouseMode() {
    return SDL_bool.fromValue(_SDL_GetRelativeMouseMode());
  }

  late final _SDL_GetRelativeMouseModePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'SDL_GetRelativeMouseMode');
  late final _SDL_GetRelativeMouseMode =
      _SDL_GetRelativeMouseModePtr.asFunction<int Function()>();

  /// Create a cursor using the specified bitmap data and mask (in MSB format).
  ///
  /// `mask` has to be in MSB (Most Significant Bit) format.
  ///
  /// The cursor width (`w`) must be a multiple of 8 bits.
  ///
  /// The cursor is created in black and white according to the following:
  ///
  /// - data=0, mask=1: white
  /// - data=1, mask=1: black
  /// - data=0, mask=0: transparent
  /// - data=1, mask=0: inverted color if possible, black if not.
  ///
  /// Cursors created with this function must be freed with SDL_FreeCursor().
  ///
  /// If you want to have a color cursor, or create your cursor from an
  /// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can
  /// hide the cursor and draw your own as part of your game's rendering, but it
  /// will be bound to the framerate.
  ///
  /// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which
  /// provides twelve readily available system cursors to pick from.
  ///
  /// \param data the color value for each pixel of the cursor
  /// \param mask the mask value for each pixel of the cursor
  /// \param w the width of the cursor
  /// \param h the height of the cursor
  /// \param hot_x the X-axis location of the upper left corner of the cursor
  /// relative to the actual mouse position
  /// \param hot_y the Y-axis location of the upper left corner of the cursor
  /// relative to the actual mouse position
  /// \returns a new cursor with the specified parameters on success or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeCursor
  /// \sa SDL_SetCursor
  /// \sa SDL_ShowCursor
  ffi.Pointer<SDL_Cursor> SDL_CreateCursor(
    ffi.Pointer<Uint8> data,
    ffi.Pointer<Uint8> mask,
    int w,
    int h,
    int hot_x,
    int hot_y,
  ) {
    return _SDL_CreateCursor(
      data,
      mask,
      w,
      h,
      hot_x,
      hot_y,
    );
  }

  late final _SDL_CreateCursorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Cursor> Function(
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('SDL_CreateCursor');
  late final _SDL_CreateCursor = _SDL_CreateCursorPtr.asFunction<
      ffi.Pointer<SDL_Cursor> Function(
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, int, int, int, int)>();

  /// Create a color cursor.
  ///
  /// \param surface an SDL_Surface structure representing the cursor image
  /// \param hot_x the x position of the cursor hot spot
  /// \param hot_y the y position of the cursor hot spot
  /// \returns the new cursor on success or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateCursor
  /// \sa SDL_FreeCursor
  ffi.Pointer<SDL_Cursor> SDL_CreateColorCursor(
    ffi.Pointer<SDL_Surface> surface,
    int hot_x,
    int hot_y,
  ) {
    return _SDL_CreateColorCursor(
      surface,
      hot_x,
      hot_y,
    );
  }

  late final _SDL_CreateColorCursorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Cursor> Function(ffi.Pointer<SDL_Surface>, ffi.Int,
              ffi.Int)>>('SDL_CreateColorCursor');
  late final _SDL_CreateColorCursor = _SDL_CreateColorCursorPtr.asFunction<
      ffi.Pointer<SDL_Cursor> Function(ffi.Pointer<SDL_Surface>, int, int)>();

  /// Create a system cursor.
  ///
  /// \param id an SDL_SystemCursor enum value
  /// \returns a cursor on success or NULL on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeCursor
  ffi.Pointer<SDL_Cursor> SDL_CreateSystemCursor(
    SDL_SystemCursor id,
  ) {
    return _SDL_CreateSystemCursor(
      id.value,
    );
  }

  late final _SDL_CreateSystemCursorPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<SDL_Cursor> Function(ffi.UnsignedInt)>>(
      'SDL_CreateSystemCursor');
  late final _SDL_CreateSystemCursor = _SDL_CreateSystemCursorPtr.asFunction<
      ffi.Pointer<SDL_Cursor> Function(int)>();

  /// Set the active cursor.
  ///
  /// This function sets the currently active cursor to the specified one. If the
  /// cursor is currently visible, the change will be immediately represented on
  /// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if
  /// this is desired for any reason.
  ///
  /// \param cursor a cursor to make active
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateCursor
  /// \sa SDL_GetCursor
  /// \sa SDL_ShowCursor
  void SDL_SetCursor(
    ffi.Pointer<SDL_Cursor> cursor,
  ) {
    return _SDL_SetCursor(
      cursor,
    );
  }

  late final _SDL_SetCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Cursor>)>>(
          'SDL_SetCursor');
  late final _SDL_SetCursor =
      _SDL_SetCursorPtr.asFunction<void Function(ffi.Pointer<SDL_Cursor>)>();

  /// Get the active cursor.
  ///
  /// This function returns a pointer to the current cursor which is owned by the
  /// library. It is not necessary to free the cursor with SDL_FreeCursor().
  ///
  /// \returns the active cursor or NULL if there is no mouse.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetCursor
  ffi.Pointer<SDL_Cursor> SDL_GetCursor() {
    return _SDL_GetCursor();
  }

  late final _SDL_GetCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Cursor> Function()>>(
          'SDL_GetCursor');
  late final _SDL_GetCursor =
      _SDL_GetCursorPtr.asFunction<ffi.Pointer<SDL_Cursor> Function()>();

  /// Get the default cursor.
  ///
  /// You do not have to call SDL_FreeCursor() on the return value, but it is
  /// safe to do so.
  ///
  /// \returns the default cursor on success or NULL on failure.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSystemCursor
  ffi.Pointer<SDL_Cursor> SDL_GetDefaultCursor() {
    return _SDL_GetDefaultCursor();
  }

  late final _SDL_GetDefaultCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Cursor> Function()>>(
          'SDL_GetDefaultCursor');
  late final _SDL_GetDefaultCursor =
      _SDL_GetDefaultCursorPtr.asFunction<ffi.Pointer<SDL_Cursor> Function()>();

  /// Free a previously-created cursor.
  ///
  /// Use this function to free cursor resources created with SDL_CreateCursor(),
  /// SDL_CreateColorCursor() or SDL_CreateSystemCursor().
  ///
  /// \param cursor the cursor to free
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateColorCursor
  /// \sa SDL_CreateCursor
  /// \sa SDL_CreateSystemCursor
  void SDL_FreeCursor(
    ffi.Pointer<SDL_Cursor> cursor,
  ) {
    return _SDL_FreeCursor(
      cursor,
    );
  }

  late final _SDL_FreeCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Cursor>)>>(
          'SDL_FreeCursor');
  late final _SDL_FreeCursor =
      _SDL_FreeCursorPtr.asFunction<void Function(ffi.Pointer<SDL_Cursor>)>();

  /// Toggle whether or not the cursor is shown.
  ///
  /// The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`
  /// displays the cursor and passing `SDL_DISABLE` hides it.
  ///
  /// The current state of the mouse cursor can be queried by passing
  /// `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned.
  ///
  /// \param toggle `SDL_ENABLE` to show the cursor, `SDL_DISABLE` to hide it,
  /// `SDL_QUERY` to query the current state without changing it.
  /// \returns `SDL_ENABLE` if the cursor is shown, or `SDL_DISABLE` if the
  /// cursor is hidden, or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateCursor
  /// \sa SDL_SetCursor
  int SDL_ShowCursor(
    int toggle,
  ) {
    return _SDL_ShowCursor(
      toggle,
    );
  }

  late final _SDL_ShowCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ShowCursor');
  late final _SDL_ShowCursor =
      _SDL_ShowCursorPtr.asFunction<int Function(int)>();

  /// Pump the event loop, gathering events from the input devices.
  ///
  /// This function updates the event queue and internal input device state.
  ///
  /// **WARNING**: This should only be run in the thread that initialized the
  /// video subsystem, and for extra safety, you should consider only doing those
  /// things on the main thread in any case.
  ///
  /// SDL_PumpEvents() gathers all the pending input information from devices and
  /// places it in the event queue. Without calls to SDL_PumpEvents() no events
  /// would ever be placed on the queue. Often the need for calls to
  /// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and
  /// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not
  /// polling or waiting for events (e.g. you are filtering them), then you must
  /// call SDL_PumpEvents() to force an event queue update.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PollEvent
  /// \sa SDL_WaitEvent
  void SDL_PumpEvents() {
    return _SDL_PumpEvents();
  }

  late final _SDL_PumpEventsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_PumpEvents');
  late final _SDL_PumpEvents = _SDL_PumpEventsPtr.asFunction<void Function()>();

  /// Check the event queue for messages and optionally return them.
  ///
  /// `action` may be any of the following:
  ///
  /// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the
  /// event queue.
  /// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,
  /// within the specified minimum and maximum type, will be returned to the
  /// caller and will _not_ be removed from the queue.
  /// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,
  /// within the specified minimum and maximum type, will be returned to the
  /// caller and will be removed from the queue.
  ///
  /// You may have to call SDL_PumpEvents() before calling this function.
  /// Otherwise, the events may not be ready to be filtered when you call
  /// SDL_PeepEvents().
  ///
  /// This function is thread-safe.
  ///
  /// \param events destination buffer for the retrieved events
  /// \param numevents if action is SDL_ADDEVENT, the number of events to add
  /// back to the event queue; if action is SDL_PEEKEVENT or
  /// SDL_GETEVENT, the maximum number of events to retrieve
  /// \param action action to take; see [[#action|Remarks]] for details
  /// \param minType minimum value of the event type to be considered;
  /// SDL_FIRSTEVENT is a safe choice
  /// \param maxType maximum value of the event type to be considered;
  /// SDL_LASTEVENT is a safe choice
  /// \returns the number of events actually stored or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PollEvent
  /// \sa SDL_PumpEvents
  /// \sa SDL_PushEvent
  int SDL_PeepEvents(
    ffi.Pointer<SDL_Event> events,
    int numevents,
    SDL_eventaction action,
    DartUint32 minType,
    DartUint32 maxType,
  ) {
    return _SDL_PeepEvents(
      events,
      numevents,
      action.value,
      minType,
      maxType,
    );
  }

  late final _SDL_PeepEventsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Event>, ffi.Int, ffi.UnsignedInt,
              Uint32, Uint32)>>('SDL_PeepEvents');
  late final _SDL_PeepEvents = _SDL_PeepEventsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Event>, int, int, int, int)>();

  /// Check for the existence of a certain event type in the event queue.
  ///
  /// If you need to check for a range of event types, use SDL_HasEvents()
  /// instead.
  ///
  /// \param type the type of event to be queried; see SDL_EventType for details
  /// \returns SDL_TRUE if events matching `type` are present, or SDL_FALSE if
  /// events matching `type` are not present.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasEvents
  SDL_bool SDL_HasEvent(
    DartUint32 type,
  ) {
    return SDL_bool.fromValue(_SDL_HasEvent(
      type,
    ));
  }

  late final _SDL_HasEventPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Uint32)>>(
          'SDL_HasEvent');
  late final _SDL_HasEvent = _SDL_HasEventPtr.asFunction<int Function(int)>();

  /// Check for the existence of certain event types in the event queue.
  ///
  /// If you need to check for a single event type, use SDL_HasEvent() instead.
  ///
  /// \param minType the low end of event type to be queried, inclusive; see
  /// SDL_EventType for details
  /// \param maxType the high end of event type to be queried, inclusive; see
  /// SDL_EventType for details
  /// \returns SDL_TRUE if events with type >= `minType` and <= `maxType` are
  /// present, or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasEvents
  SDL_bool SDL_HasEvents(
    DartUint32 minType,
    DartUint32 maxType,
  ) {
    return SDL_bool.fromValue(_SDL_HasEvents(
      minType,
      maxType,
    ));
  }

  late final _SDL_HasEventsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Uint32, Uint32)>>(
          'SDL_HasEvents');
  late final _SDL_HasEvents =
      _SDL_HasEventsPtr.asFunction<int Function(int, int)>();

  /// Clear events of a specific type from the event queue.
  ///
  /// This will unconditionally remove any events from the queue that match
  /// `type`. If you need to remove a range of event types, use SDL_FlushEvents()
  /// instead.
  ///
  /// It's also normal to just ignore events you don't care about in your event
  /// loop without calling this function.
  ///
  /// This function only affects currently queued events. If you want to make
  /// sure that all pending OS events are flushed, you can call SDL_PumpEvents()
  /// on the main thread immediately before the flush call.
  ///
  /// \param type the type of event to be cleared; see SDL_EventType for details
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FlushEvents
  void SDL_FlushEvent(
    int type,
  ) {
    return _SDL_FlushEvent(
      type,
    );
  }

  late final _SDL_FlushEventPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32)>>('SDL_FlushEvent');
  late final _SDL_FlushEvent =
      _SDL_FlushEventPtr.asFunction<void Function(int)>();

  /// Clear events of a range of types from the event queue.
  ///
  /// This will unconditionally remove any events from the queue that are in the
  /// range of `minType` to `maxType`, inclusive. If you need to remove a single
  /// event type, use SDL_FlushEvent() instead.
  ///
  /// It's also normal to just ignore events you don't care about in your event
  /// loop without calling this function.
  ///
  /// This function only affects currently queued events. If you want to make
  /// sure that all pending OS events are flushed, you can call SDL_PumpEvents()
  /// on the main thread immediately before the flush call.
  ///
  /// \param minType the low end of event type to be cleared, inclusive; see
  /// SDL_EventType for details
  /// \param maxType the high end of event type to be cleared, inclusive; see
  /// SDL_EventType for details
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FlushEvent
  void SDL_FlushEvents(
    int minType,
    int maxType,
  ) {
    return _SDL_FlushEvents(
      minType,
      maxType,
    );
  }

  late final _SDL_FlushEventsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32, Uint32)>>(
          'SDL_FlushEvents');
  late final _SDL_FlushEvents =
      _SDL_FlushEventsPtr.asFunction<void Function(int, int)>();

  /// Poll for currently pending events.
  ///
  /// If `event` is not NULL, the next event is removed from the queue and stored
  /// in the SDL_Event structure pointed to by `event`. The 1 returned refers to
  /// this event, immediately stored in the SDL Event structure -- not an event
  /// to follow.
  ///
  /// If `event` is NULL, it simply returns 1 if there is an event in the queue,
  /// but will not remove it from the queue.
  ///
  /// As this function may implicitly call SDL_PumpEvents(), you can only call
  /// this function in the thread that set the video mode.
  ///
  /// SDL_PollEvent() is the favored way of receiving system events since it can
  /// be done from the main loop and does not suspend the main loop while waiting
  /// on an event to be posted.
  ///
  /// The common practice is to fully process the event queue once every frame,
  /// usually as a first step before updating the game's state:
  ///
  /// ```c
  /// while (game_is_still_running) {
  /// SDL_Event event;
  /// while (SDL_PollEvent(&event)) {  // poll until all events are handled!
  /// // decide what to do with this event.
  /// }
  ///
  /// // update game state, draw the current frame
  /// }
  /// ```
  ///
  /// \param event the SDL_Event structure to be filled with the next event from
  /// the queue, or NULL
  /// \returns 1 if there is a pending event or 0 if there are none available.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetEventFilter
  /// \sa SDL_PeepEvents
  /// \sa SDL_PushEvent
  /// \sa SDL_SetEventFilter
  /// \sa SDL_WaitEvent
  /// \sa SDL_WaitEventTimeout
  int SDL_PollEvent(
    ffi.Pointer<SDL_Event> event,
  ) {
    return _SDL_PollEvent(
      event,
    );
  }

  late final _SDL_PollEventPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Event>)>>(
          'SDL_PollEvent');
  late final _SDL_PollEvent =
      _SDL_PollEventPtr.asFunction<int Function(ffi.Pointer<SDL_Event>)>();

  /// Wait indefinitely for the next available event.
  ///
  /// If `event` is not NULL, the next event is removed from the queue and stored
  /// in the SDL_Event structure pointed to by `event`.
  ///
  /// As this function may implicitly call SDL_PumpEvents(), you can only call
  /// this function in the thread that initialized the video subsystem.
  ///
  /// \param event the SDL_Event structure to be filled in with the next event
  /// from the queue, or NULL
  /// \returns 1 on success or 0 if there was an error while waiting for events;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PollEvent
  /// \sa SDL_PumpEvents
  /// \sa SDL_WaitEventTimeout
  int SDL_WaitEvent(
    ffi.Pointer<SDL_Event> event,
  ) {
    return _SDL_WaitEvent(
      event,
    );
  }

  late final _SDL_WaitEventPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Event>)>>(
          'SDL_WaitEvent');
  late final _SDL_WaitEvent =
      _SDL_WaitEventPtr.asFunction<int Function(ffi.Pointer<SDL_Event>)>();

  /// Wait until the specified timeout (in milliseconds) for the next available
  /// event.
  ///
  /// If `event` is not NULL, the next event is removed from the queue and stored
  /// in the SDL_Event structure pointed to by `event`.
  ///
  /// As this function may implicitly call SDL_PumpEvents(), you can only call
  /// this function in the thread that initialized the video subsystem.
  ///
  /// \param event the SDL_Event structure to be filled in with the next event
  /// from the queue, or NULL
  /// \param timeout the maximum number of milliseconds to wait for the next
  /// available event
  /// \returns 1 on success or 0 if there was an error while waiting for events;
  /// call SDL_GetError() for more information. This also returns 0 if
  /// the timeout elapsed without an event arriving.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PollEvent
  /// \sa SDL_PumpEvents
  /// \sa SDL_WaitEvent
  int SDL_WaitEventTimeout(
    ffi.Pointer<SDL_Event> event,
    int timeout,
  ) {
    return _SDL_WaitEventTimeout(
      event,
      timeout,
    );
  }

  late final _SDL_WaitEventTimeoutPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Event>, ffi.Int)>>(
      'SDL_WaitEventTimeout');
  late final _SDL_WaitEventTimeout = _SDL_WaitEventTimeoutPtr.asFunction<
      int Function(ffi.Pointer<SDL_Event>, int)>();

  /// Add an event to the event queue.
  ///
  /// The event queue can actually be used as a two way communication channel.
  /// Not only can events be read from the queue, but the user can also push
  /// their own events onto it. `event` is a pointer to the event structure you
  /// wish to push onto the queue. The event is copied into the queue, and the
  /// caller may dispose of the memory pointed to after SDL_PushEvent() returns.
  ///
  /// Note: Pushing device input events onto the queue doesn't modify the state
  /// of the device within SDL.
  ///
  /// This function is thread-safe, and can be called from other threads safely.
  ///
  /// Note: Events pushed onto the queue with SDL_PushEvent() get passed through
  /// the event filter but events added with SDL_PeepEvents() do not.
  ///
  /// For pushing application-specific events, please use SDL_RegisterEvents() to
  /// get an event type that does not conflict with other code that also wants
  /// its own custom event types.
  ///
  /// \param event the SDL_Event to be added to the queue
  /// \returns 1 on success, 0 if the event was filtered, or a negative error
  /// code on failure; call SDL_GetError() for more information. A
  /// common reason for error is the event queue being full.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PeepEvents
  /// \sa SDL_PollEvent
  /// \sa SDL_RegisterEvents
  int SDL_PushEvent(
    ffi.Pointer<SDL_Event> event,
  ) {
    return _SDL_PushEvent(
      event,
    );
  }

  late final _SDL_PushEventPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Event>)>>(
          'SDL_PushEvent');
  late final _SDL_PushEvent =
      _SDL_PushEventPtr.asFunction<int Function(ffi.Pointer<SDL_Event>)>();

  /// Set up a filter to process all events before they change internal state and
  /// are posted to the internal event queue.
  ///
  /// If the filter function returns 1 when called, then the event will be added
  /// to the internal queue. If it returns 0, then the event will be dropped from
  /// the queue, but the internal state will still be updated. This allows
  /// selective filtering of dynamically arriving events.
  ///
  /// **WARNING**: Be very careful of what you do in the event filter function,
  /// as it may run in a different thread!
  ///
  /// On platforms that support it, if the quit event is generated by an
  /// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the
  /// application at the next event poll.
  ///
  /// There is one caveat when dealing with the ::SDL_QuitEvent event type. The
  /// event filter is only called when the window manager desires to close the
  /// application window. If the event filter returns 1, then the window will be
  /// closed, otherwise the window will remain open if possible.
  ///
  /// Note: Disabled events never make it to the event filter function; see
  /// SDL_EventState().
  ///
  /// Note: If you just want to inspect events without filtering, you should use
  /// SDL_AddEventWatch() instead.
  ///
  /// Note: Events pushed onto the queue with SDL_PushEvent() get passed through
  /// the event filter, but events pushed onto the queue with SDL_PeepEvents() do
  /// not.
  ///
  /// \param filter An SDL_EventFilter function to call when an event happens
  /// \param userdata a pointer that is passed to `filter`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AddEventWatch
  /// \sa SDL_EventState
  /// \sa SDL_GetEventFilter
  /// \sa SDL_PeepEvents
  /// \sa SDL_PushEvent
  void SDL_SetEventFilter(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetEventFilter(
      filter,
      userdata,
    );
  }

  late final _SDL_SetEventFilterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_SetEventFilter');
  late final _SDL_SetEventFilter = _SDL_SetEventFilterPtr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Query the current event filter.
  ///
  /// This function can be used to "chain" filters, by saving the existing filter
  /// before replacing it with a function that will call that saved filter.
  ///
  /// \param filter the current callback function will be stored here
  /// \param userdata the pointer that is passed to the current event filter will
  /// be stored here
  /// \returns SDL_TRUE on success or SDL_FALSE if there is no event filter set.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetEventFilter
  SDL_bool SDL_GetEventFilter(
    ffi.Pointer<SDL_EventFilter> filter,
    ffi.Pointer<ffi.Pointer<ffi.Void>> userdata,
  ) {
    return SDL_bool.fromValue(_SDL_GetEventFilter(
      filter,
      userdata,
    ));
  }

  late final _SDL_GetEventFilterPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<SDL_EventFilter>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_GetEventFilter');
  late final _SDL_GetEventFilter = _SDL_GetEventFilterPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_EventFilter>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Add a callback to be triggered when an event is added to the event queue.
  ///
  /// `filter` will be called when an event happens, and its return value is
  /// ignored.
  ///
  /// **WARNING**: Be very careful of what you do in the event filter function,
  /// as it may run in a different thread!
  ///
  /// If the quit event is generated by a signal (e.g. SIGINT), it will bypass
  /// the internal queue and be delivered to the watch callback immediately, and
  /// arrive at the next event poll.
  ///
  /// Note: the callback is called for events posted by the user through
  /// SDL_PushEvent(), but not for disabled events, nor for events by a filter
  /// callback set with SDL_SetEventFilter(), nor for events posted by the user
  /// through SDL_PeepEvents().
  ///
  /// \param filter an SDL_EventFilter function to call when an event happens.
  /// \param userdata a pointer that is passed to `filter`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DelEventWatch
  /// \sa SDL_SetEventFilter
  void SDL_AddEventWatch(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_AddEventWatch(
      filter,
      userdata,
    );
  }

  late final _SDL_AddEventWatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_AddEventWatch');
  late final _SDL_AddEventWatch = _SDL_AddEventWatchPtr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Remove an event watch callback added with SDL_AddEventWatch().
  ///
  /// This function takes the same input as SDL_AddEventWatch() to identify and
  /// delete the corresponding callback.
  ///
  /// \param filter the function originally passed to SDL_AddEventWatch()
  /// \param userdata the pointer originally passed to SDL_AddEventWatch()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AddEventWatch
  void SDL_DelEventWatch(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_DelEventWatch(
      filter,
      userdata,
    );
  }

  late final _SDL_DelEventWatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_DelEventWatch');
  late final _SDL_DelEventWatch = _SDL_DelEventWatchPtr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Run a specific filter function on the current event queue, removing any
  /// events for which the filter returns 0.
  ///
  /// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),
  /// this function does not change the filter permanently, it only uses the
  /// supplied filter until this function returns.
  ///
  /// \param filter the SDL_EventFilter function to call when an event happens
  /// \param userdata a pointer that is passed to `filter`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetEventFilter
  /// \sa SDL_SetEventFilter
  void SDL_FilterEvents(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_FilterEvents(
      filter,
      userdata,
    );
  }

  late final _SDL_FilterEventsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_FilterEvents');
  late final _SDL_FilterEvents = _SDL_FilterEventsPtr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Set the state of processing events by type.
  ///
  /// `state` may be any of the following:
  ///
  /// - `SDL_QUERY`: returns the current processing state of the specified event
  /// - `SDL_IGNORE` (aka `SDL_DISABLE`): the event will automatically be dropped
  /// from the event queue and will not be filtered
  /// - `SDL_ENABLE`: the event will be processed normally
  ///
  /// \param type the type of event; see SDL_EventType for details
  /// \param state how to process the event
  /// \returns `SDL_DISABLE` or `SDL_ENABLE`, representing the processing state
  /// of the event before this function makes any changes to it.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetEventState
  int SDL_EventState(
    int type,
    int state,
  ) {
    return _SDL_EventState(
      type,
      state,
    );
  }

  late final _SDL_EventStatePtr =
      _lookup<ffi.NativeFunction<Uint8 Function(Uint32, ffi.Int)>>(
          'SDL_EventState');
  late final _SDL_EventState =
      _SDL_EventStatePtr.asFunction<int Function(int, int)>();

  /// Allocate a set of user-defined events, and return the beginning event
  /// number for that set of events.
  ///
  /// Calling this function with `numevents` <= 0 is an error and will return
  /// (Uint32)-1.
  ///
  /// Note, (Uint32)-1 means the maximum unsigned 32-bit integer value (or
  /// 0xFFFFFFFF), but is clearer to write.
  ///
  /// \param numevents the number of events to be allocated
  /// \returns the beginning event number, or (Uint32)-1 if there are not enough
  /// user-defined events left.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PushEvent
  int SDL_RegisterEvents(
    int numevents,
  ) {
    return _SDL_RegisterEvents(
      numevents,
    );
  }

  late final _SDL_RegisterEventsPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Int)>>(
          'SDL_RegisterEvents');
  late final _SDL_RegisterEvents =
      _SDL_RegisterEventsPtr.asFunction<int Function(int)>();

  /// Get the number of 2D rendering drivers available for the current display.
  ///
  /// A render driver is a set of code that handles rendering and texture
  /// management on a particular display. Normally there is only one, but some
  /// drivers may have several available with different capabilities.
  ///
  /// There may be none if SDL was compiled without render support.
  ///
  /// \returns a number >= 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  /// \sa SDL_GetRenderDriverInfo
  int SDL_GetNumRenderDrivers() {
    return _SDL_GetNumRenderDrivers();
  }

  late final _SDL_GetNumRenderDriversPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GetNumRenderDrivers');
  late final _SDL_GetNumRenderDrivers =
      _SDL_GetNumRenderDriversPtr.asFunction<int Function()>();

  /// Get info about a specific 2D rendering driver for the current display.
  ///
  /// \param index the index of the driver to query information about
  /// \param info an SDL_RendererInfo structure to be filled with information on
  /// the rendering driver
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  /// \sa SDL_GetNumRenderDrivers
  int SDL_GetRenderDriverInfo(
    int index,
    ffi.Pointer<SDL_RendererInfo> info,
  ) {
    return _SDL_GetRenderDriverInfo(
      index,
      info,
    );
  }

  late final _SDL_GetRenderDriverInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_RendererInfo>)>>('SDL_GetRenderDriverInfo');
  late final _SDL_GetRenderDriverInfo = _SDL_GetRenderDriverInfoPtr.asFunction<
      int Function(int, ffi.Pointer<SDL_RendererInfo>)>();

  /// Create a window and default renderer.
  ///
  /// \param width the width of the window
  /// \param height the height of the window
  /// \param window_flags the flags used to create the window (see
  /// SDL_CreateWindow())
  /// \param window a pointer filled with the window, or NULL on error
  /// \param renderer a pointer filled with the renderer, or NULL on error
  /// \returns 0 on success, or -1 on error; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  /// \sa SDL_CreateWindow
  int SDL_CreateWindowAndRenderer(
    int width,
    int height,
    int window_flags,
    ffi.Pointer<ffi.Pointer<SDL_Window>> window,
    ffi.Pointer<ffi.Pointer<SDL_Renderer>> renderer,
  ) {
    return _SDL_CreateWindowAndRenderer(
      width,
      height,
      window_flags,
      window,
      renderer,
    );
  }

  late final _SDL_CreateWindowAndRendererPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Int,
                  ffi.Int,
                  Uint32,
                  ffi.Pointer<ffi.Pointer<SDL_Window>>,
                  ffi.Pointer<ffi.Pointer<SDL_Renderer>>)>>(
      'SDL_CreateWindowAndRenderer');
  late final _SDL_CreateWindowAndRenderer =
      _SDL_CreateWindowAndRendererPtr.asFunction<
          int Function(int, int, int, ffi.Pointer<ffi.Pointer<SDL_Window>>,
              ffi.Pointer<ffi.Pointer<SDL_Renderer>>)>();

  /// Create a 2D rendering context for a window.
  ///
  /// \param window the window where rendering is displayed
  /// \param index the index of the rendering driver to initialize, or -1 to
  /// initialize the first one supporting the requested flags
  /// \param flags 0, or one or more SDL_RendererFlags OR'd together
  /// \returns a valid rendering context or NULL if there was an error; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSoftwareRenderer
  /// \sa SDL_DestroyRenderer
  /// \sa SDL_GetNumRenderDrivers
  /// \sa SDL_GetRendererInfo
  ffi.Pointer<SDL_Renderer> SDL_CreateRenderer(
    ffi.Pointer<SDL_Window> window,
    int index,
    int flags,
  ) {
    return _SDL_CreateRenderer(
      window,
      index,
      flags,
    );
  }

  late final _SDL_CreateRendererPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Renderer> Function(
              ffi.Pointer<SDL_Window>, ffi.Int, Uint32)>>('SDL_CreateRenderer');
  late final _SDL_CreateRenderer = _SDL_CreateRendererPtr.asFunction<
      ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Create a 2D software rendering context for a surface.
  ///
  /// Two other API which can be used to create SDL_Renderer:
  /// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_
  /// create a software renderer, but they are intended to be used with an
  /// SDL_Window as the final destination and not an SDL_Surface.
  ///
  /// \param surface the SDL_Surface structure representing the surface where
  /// rendering is done
  /// \returns a valid rendering context or NULL if there was an error; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  /// \sa SDL_CreateWindowRenderer
  /// \sa SDL_DestroyRenderer
  ffi.Pointer<SDL_Renderer> SDL_CreateSoftwareRenderer(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_CreateSoftwareRenderer(
      surface,
    );
  }

  late final _SDL_CreateSoftwareRendererPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Renderer> Function(
              ffi.Pointer<SDL_Surface>)>>('SDL_CreateSoftwareRenderer');
  late final _SDL_CreateSoftwareRenderer =
      _SDL_CreateSoftwareRendererPtr.asFunction<
          ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Surface>)>();

  /// Get the renderer associated with a window.
  ///
  /// \param window the window to query
  /// \returns the rendering context on success or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  ffi.Pointer<SDL_Renderer> SDL_GetRenderer(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetRenderer(
      window,
    );
  }

  late final _SDL_GetRendererPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Renderer> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetRenderer');
  late final _SDL_GetRenderer = _SDL_GetRendererPtr.asFunction<
      ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Window>)>();

  /// Get the window associated with a renderer.
  ///
  /// \param renderer the renderer to query
  /// \returns the window on success or NULL on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.22.
  ffi.Pointer<SDL_Window> SDL_RenderGetWindow(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetWindow(
      renderer,
    );
  }

  late final _SDL_RenderGetWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetWindow');
  late final _SDL_RenderGetWindow = _SDL_RenderGetWindowPtr.asFunction<
      ffi.Pointer<SDL_Window> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Get information about a rendering context.
  ///
  /// \param renderer the rendering context
  /// \param info an SDL_RendererInfo structure filled with information about the
  /// current renderer
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  int SDL_GetRendererInfo(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_RendererInfo> info,
  ) {
    return _SDL_GetRendererInfo(
      renderer,
      info,
    );
  }

  late final _SDL_GetRendererInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_RendererInfo>)>>('SDL_GetRendererInfo');
  late final _SDL_GetRendererInfo = _SDL_GetRendererInfoPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_RendererInfo>)>();

  /// Get the output size in pixels of a rendering context.
  ///
  /// Due to high-dpi displays, you might end up with a rendering context that
  /// has more pixels than the window that contains it, so use this instead of
  /// SDL_GetWindowSize() to decide how much drawing area you have.
  ///
  /// \param renderer the rendering context
  /// \param w an int filled with the width
  /// \param h an int filled with the height
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRenderer
  int SDL_GetRendererOutputSize(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetRendererOutputSize(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_GetRendererOutputSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetRendererOutputSize');
  late final _SDL_GetRendererOutputSize =
      _SDL_GetRendererOutputSizePtr.asFunction<
          int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Create a texture for a rendering context.
  ///
  /// You can set the texture scaling method by setting
  /// `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.
  ///
  /// \param renderer the rendering context
  /// \param format one of the enumerated values in SDL_PixelFormatEnum
  /// \param access one of the enumerated values in SDL_TextureAccess
  /// \param w the width of the texture in pixels
  /// \param h the height of the texture in pixels
  /// \returns a pointer to the created texture or NULL if no rendering context
  /// was active, the format was unsupported, or the width or height
  /// were out of range; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTextureFromSurface
  /// \sa SDL_DestroyTexture
  /// \sa SDL_QueryTexture
  /// \sa SDL_UpdateTexture
  ffi.Pointer<SDL_Texture> SDL_CreateTexture(
    ffi.Pointer<SDL_Renderer> renderer,
    int format,
    int access,
    int w,
    int h,
  ) {
    return _SDL_CreateTexture(
      renderer,
      format,
      access,
      w,
      h,
    );
  }

  late final _SDL_CreateTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Texture> Function(ffi.Pointer<SDL_Renderer>, Uint32,
              ffi.Int, ffi.Int, ffi.Int)>>('SDL_CreateTexture');
  late final _SDL_CreateTexture = _SDL_CreateTexturePtr.asFunction<
      ffi.Pointer<SDL_Texture> Function(
          ffi.Pointer<SDL_Renderer>, int, int, int, int)>();

  /// Create a texture from an existing surface.
  ///
  /// The surface is not modified or freed by this function.
  ///
  /// The SDL_TextureAccess hint for the created texture is
  /// `SDL_TEXTUREACCESS_STATIC`.
  ///
  /// The pixel format of the created texture may be different from the pixel
  /// format of the surface. Use SDL_QueryTexture() to query the pixel format of
  /// the texture.
  ///
  /// \param renderer the rendering context
  /// \param surface the SDL_Surface structure containing pixel data used to fill
  /// the texture
  /// \returns the created texture or NULL on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTexture
  /// \sa SDL_DestroyTexture
  /// \sa SDL_QueryTexture
  ffi.Pointer<SDL_Texture> SDL_CreateTextureFromSurface(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_CreateTextureFromSurface(
      renderer,
      surface,
    );
  }

  late final _SDL_CreateTextureFromSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Texture> Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Surface>)>>('SDL_CreateTextureFromSurface');
  late final _SDL_CreateTextureFromSurface =
      _SDL_CreateTextureFromSurfacePtr.asFunction<
          ffi.Pointer<SDL_Texture> Function(
              ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Surface>)>();

  /// Query the attributes of a texture.
  ///
  /// \param texture the texture to query
  /// \param format a pointer filled in with the raw format of the texture; the
  /// actual format may differ, but pixel transfers will use this
  /// format (one of the SDL_PixelFormatEnum values). This argument
  /// can be NULL if you don't need this information.
  /// \param access a pointer filled in with the actual access to the texture
  /// (one of the SDL_TextureAccess values). This argument can be
  /// NULL if you don't need this information.
  /// \param w a pointer filled in with the width of the texture in pixels. This
  /// argument can be NULL if you don't need this information.
  /// \param h a pointer filled in with the height of the texture in pixels. This
  /// argument can be NULL if you don't need this information.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTexture
  int SDL_QueryTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<Uint32> format,
    ffi.Pointer<ffi.Int> access,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_QueryTexture(
      texture,
      format,
      access,
      w,
      h,
    );
  }

  late final _SDL_QueryTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_QueryTexture');
  late final _SDL_QueryTexture = _SDL_QueryTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<Uint32>,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Set an additional color value multiplied into render copy operations.
  ///
  /// When this texture is rendered, during the copy operation each source color
  /// channel is modulated by the appropriate color value according to the
  /// following formula:
  ///
  /// `srcC = srcC * (color / 255)`
  ///
  /// Color modulation is not always supported by the renderer; it will return -1
  /// if color modulation is not supported.
  ///
  /// \param texture the texture to update
  /// \param r the red color value multiplied into copy operations
  /// \param g the green color value multiplied into copy operations
  /// \param b the blue color value multiplied into copy operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureColorMod
  /// \sa SDL_SetTextureAlphaMod
  int SDL_SetTextureColorMod(
    ffi.Pointer<SDL_Texture> texture,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetTextureColorMod(
      texture,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetTextureColorModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>, Uint8, Uint8,
              Uint8)>>('SDL_SetTextureColorMod');
  late final _SDL_SetTextureColorMod = _SDL_SetTextureColorModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int, int, int)>();

  /// Get the additional color value multiplied into render copy operations.
  ///
  /// \param texture the texture to query
  /// \param r a pointer filled in with the current red color value
  /// \param g a pointer filled in with the current green color value
  /// \param b a pointer filled in with the current blue color value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureAlphaMod
  /// \sa SDL_SetTextureColorMod
  int SDL_GetTextureColorMod(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetTextureColorMod(
      texture,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetTextureColorModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetTextureColorMod');
  late final _SDL_GetTextureColorMod = _SDL_GetTextureColorModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Set an additional alpha value multiplied into render copy operations.
  ///
  /// When this texture is rendered, during the copy operation the source alpha
  /// value is modulated by this alpha value according to the following formula:
  ///
  /// `srcA = srcA * (alpha / 255)`
  ///
  /// Alpha modulation is not always supported by the renderer; it will return -1
  /// if alpha modulation is not supported.
  ///
  /// \param texture the texture to update
  /// \param alpha the source alpha value multiplied into copy operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureAlphaMod
  /// \sa SDL_SetTextureColorMod
  int SDL_SetTextureAlphaMod(
    ffi.Pointer<SDL_Texture> texture,
    int alpha,
  ) {
    return _SDL_SetTextureAlphaMod(
      texture,
      alpha,
    );
  }

  late final _SDL_SetTextureAlphaModPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Texture>, Uint8)>>(
      'SDL_SetTextureAlphaMod');
  late final _SDL_SetTextureAlphaMod = _SDL_SetTextureAlphaModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int)>();

  /// Get the additional alpha value multiplied into render copy operations.
  ///
  /// \param texture the texture to query
  /// \param alpha a pointer filled in with the current alpha value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureColorMod
  /// \sa SDL_SetTextureAlphaMod
  int SDL_GetTextureAlphaMod(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<Uint8> alpha,
  ) {
    return _SDL_GetTextureAlphaMod(
      texture,
      alpha,
    );
  }

  late final _SDL_GetTextureAlphaModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<Uint8>)>>('SDL_GetTextureAlphaMod');
  late final _SDL_GetTextureAlphaMod = _SDL_GetTextureAlphaModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<Uint8>)>();

  /// Set the blend mode for a texture, used by SDL_RenderCopy().
  ///
  /// If the blend mode is not supported, the closest supported mode is chosen
  /// and this function returns -1.
  ///
  /// \param texture the texture to update
  /// \param blendMode the SDL_BlendMode to use for texture blending
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureBlendMode
  /// \sa SDL_RenderCopy
  int SDL_SetTextureBlendMode(
    ffi.Pointer<SDL_Texture> texture,
    SDL_BlendMode blendMode,
  ) {
    return _SDL_SetTextureBlendMode(
      texture,
      blendMode.value,
    );
  }

  late final _SDL_SetTextureBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.UnsignedInt)>>('SDL_SetTextureBlendMode');
  late final _SDL_SetTextureBlendMode = _SDL_SetTextureBlendModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int)>();

  /// Get the blend mode used for texture copy operations.
  ///
  /// \param texture the texture to query
  /// \param blendMode a pointer filled in with the current SDL_BlendMode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetTextureBlendMode
  int SDL_GetTextureBlendMode(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.UnsignedInt> blendMode,
  ) {
    return _SDL_GetTextureBlendMode(
      texture,
      blendMode,
    );
  }

  late final _SDL_GetTextureBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.UnsignedInt>)>>('SDL_GetTextureBlendMode');
  late final _SDL_GetTextureBlendMode = _SDL_GetTextureBlendModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// Set the scale mode used for texture scale operations.
  ///
  /// If the scale mode is not supported, the closest supported mode is chosen.
  ///
  /// \param texture The texture to update.
  /// \param scaleMode the SDL_ScaleMode to use for texture scaling.
  /// \returns 0 on success, or -1 if the texture is not valid.
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_GetTextureScaleMode
  int SDL_SetTextureScaleMode(
    ffi.Pointer<SDL_Texture> texture,
    SDL_ScaleMode scaleMode,
  ) {
    return _SDL_SetTextureScaleMode(
      texture,
      scaleMode.value,
    );
  }

  late final _SDL_SetTextureScaleModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.UnsignedInt)>>('SDL_SetTextureScaleMode');
  late final _SDL_SetTextureScaleMode = _SDL_SetTextureScaleModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int)>();

  /// Get the scale mode used for texture scale operations.
  ///
  /// \param texture the texture to query.
  /// \param scaleMode a pointer filled in with the current scale mode.
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_SetTextureScaleMode
  int SDL_GetTextureScaleMode(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.UnsignedInt> scaleMode,
  ) {
    return _SDL_GetTextureScaleMode(
      texture,
      scaleMode,
    );
  }

  late final _SDL_GetTextureScaleModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.UnsignedInt>)>>('SDL_GetTextureScaleMode');
  late final _SDL_GetTextureScaleMode = _SDL_GetTextureScaleModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// Associate a user-specified pointer with a texture.
  ///
  /// \param texture the texture to update.
  /// \param userdata the pointer to associate with the texture.
  /// \returns 0 on success, or -1 if the texture is not valid.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GetTextureUserData
  int SDL_SetTextureUserData(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetTextureUserData(
      texture,
      userdata,
    );
  }

  late final _SDL_SetTextureUserDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.Void>)>>('SDL_SetTextureUserData');
  late final _SDL_SetTextureUserData = _SDL_SetTextureUserDataPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Void>)>();

  /// Get the user-specified pointer associated with a texture
  ///
  /// \param texture the texture to query.
  /// \return the pointer associated with the texture, or NULL if the texture is
  /// not valid.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_SetTextureUserData
  ffi.Pointer<ffi.Void> SDL_GetTextureUserData(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_GetTextureUserData(
      texture,
    );
  }

  late final _SDL_GetTextureUserDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Texture>)>>('SDL_GetTextureUserData');
  late final _SDL_GetTextureUserData = _SDL_GetTextureUserDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Texture>)>();

  /// Update the given texture rectangle with new pixel data.
  ///
  /// The pixel data must be in the pixel format of the texture. Use
  /// SDL_QueryTexture() to query the pixel format of the texture.
  ///
  /// This is a fairly slow function, intended for use with static textures that
  /// do not change often.
  ///
  /// If the texture is intended to be updated often, it is preferred to create
  /// the texture as streaming and use the locking functions referenced below.
  /// While this function will work with streaming textures, for optimization
  /// reasons you may not get the pixels back if you lock the texture afterward.
  ///
  /// \param texture the texture to update
  /// \param rect an SDL_Rect structure representing the area to update, or NULL
  /// to update the entire texture
  /// \param pixels the raw pixel data in the format of the texture
  /// \param pitch the number of bytes in a row of pixel data, including padding
  /// between lines
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTexture
  /// \sa SDL_LockTexture
  /// \sa SDL_UnlockTexture
  int SDL_UpdateTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Void> pixels,
    int pitch,
  ) {
    return _SDL_UpdateTexture(
      texture,
      rect,
      pixels,
      pitch,
    );
  }

  late final _SDL_UpdateTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_UpdateTexture');
  late final _SDL_UpdateTexture = _SDL_UpdateTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<ffi.Void>, int)>();

  /// Update a rectangle within a planar YV12 or IYUV texture with new pixel
  /// data.
  ///
  /// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
  /// block of Y and U/V planes in the proper order, but this function is
  /// available if your pixel data is not contiguous.
  ///
  /// \param texture the texture to update
  /// \param rect a pointer to the rectangle of pixels to update, or NULL to
  /// update the entire texture
  /// \param Yplane the raw pixel data for the Y plane
  /// \param Ypitch the number of bytes between rows of pixel data for the Y
  /// plane
  /// \param Uplane the raw pixel data for the U plane
  /// \param Upitch the number of bytes between rows of pixel data for the U
  /// plane
  /// \param Vplane the raw pixel data for the V plane
  /// \param Vpitch the number of bytes between rows of pixel data for the V
  /// plane
  /// \returns 0 on success or -1 if the texture is not valid; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_UpdateTexture
  int SDL_UpdateYUVTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<Uint8> Yplane,
    int Ypitch,
    ffi.Pointer<Uint8> Uplane,
    int Upitch,
    ffi.Pointer<Uint8> Vplane,
    int Vpitch,
  ) {
    return _SDL_UpdateYUVTexture(
      texture,
      rect,
      Yplane,
      Ypitch,
      Uplane,
      Upitch,
      Vplane,
      Vpitch,
    );
  }

  late final _SDL_UpdateYUVTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<Uint8>,
              ffi.Int,
              ffi.Pointer<Uint8>,
              ffi.Int,
              ffi.Pointer<Uint8>,
              ffi.Int)>>('SDL_UpdateYUVTexture');
  late final _SDL_UpdateYUVTexture = _SDL_UpdateYUVTexturePtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>,
          ffi.Pointer<Uint8>,
          int,
          ffi.Pointer<Uint8>,
          int,
          ffi.Pointer<Uint8>,
          int)>();

  /// Update a rectangle within a planar NV12 or NV21 texture with new pixels.
  ///
  /// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
  /// block of NV12/21 planes in the proper order, but this function is available
  /// if your pixel data is not contiguous.
  ///
  /// \param texture the texture to update
  /// \param rect a pointer to the rectangle of pixels to update, or NULL to
  /// update the entire texture.
  /// \param Yplane the raw pixel data for the Y plane.
  /// \param Ypitch the number of bytes between rows of pixel data for the Y
  /// plane.
  /// \param UVplane the raw pixel data for the UV plane.
  /// \param UVpitch the number of bytes between rows of pixel data for the UV
  /// plane.
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_UpdateNVTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<Uint8> Yplane,
    int Ypitch,
    ffi.Pointer<Uint8> UVplane,
    int UVpitch,
  ) {
    return _SDL_UpdateNVTexture(
      texture,
      rect,
      Yplane,
      Ypitch,
      UVplane,
      UVpitch,
    );
  }

  late final _SDL_UpdateNVTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<Uint8>,
              ffi.Int,
              ffi.Pointer<Uint8>,
              ffi.Int)>>('SDL_UpdateNVTexture');
  late final _SDL_UpdateNVTexture = _SDL_UpdateNVTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<Uint8>, int, ffi.Pointer<Uint8>, int)>();

  /// Lock a portion of the texture for **write-only** pixel access.
  ///
  /// As an optimization, the pixels made available for editing don't necessarily
  /// contain the old texture data. This is a write-only operation, and if you
  /// need to keep a copy of the texture data you should do that at the
  /// application level.
  ///
  /// You must use SDL_UnlockTexture() to unlock the pixels and apply any
  /// changes.
  ///
  /// \param texture the texture to lock for access, which was created with
  /// `SDL_TEXTUREACCESS_STREAMING`
  /// \param rect an SDL_Rect structure representing the area to lock for access;
  /// NULL to lock the entire texture
  /// \param pixels this is filled in with a pointer to the locked pixels,
  /// appropriately offset by the locked area
  /// \param pitch this is filled in with the pitch of the locked pixels; the
  /// pitch is the length of one row in bytes
  /// \returns 0 on success or a negative error code if the texture is not valid
  /// or was not created with `SDL_TEXTUREACCESS_STREAMING`; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_UnlockTexture
  int SDL_LockTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Pointer<ffi.Void>> pixels,
    ffi.Pointer<ffi.Int> pitch,
  ) {
    return _SDL_LockTexture(
      texture,
      rect,
      pixels,
      pitch,
    );
  }

  late final _SDL_LockTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Int>)>>('SDL_LockTexture');
  late final _SDL_LockTexture = _SDL_LockTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Int>)>();

  /// Lock a portion of the texture for **write-only** pixel access, and expose
  /// it as a SDL surface.
  ///
  /// Besides providing an SDL_Surface instead of raw pixel data, this function
  /// operates like SDL_LockTexture.
  ///
  /// As an optimization, the pixels made available for editing don't necessarily
  /// contain the old texture data. This is a write-only operation, and if you
  /// need to keep a copy of the texture data you should do that at the
  /// application level.
  ///
  /// You must use SDL_UnlockTexture() to unlock the pixels and apply any
  /// changes.
  ///
  /// The returned surface is freed internally after calling SDL_UnlockTexture()
  /// or SDL_DestroyTexture(). The caller should not free it.
  ///
  /// \param texture the texture to lock for access, which was created with
  /// `SDL_TEXTUREACCESS_STREAMING`
  /// \param rect a pointer to the rectangle to lock for access. If the rect is
  /// NULL, the entire texture will be locked
  /// \param surface this is filled in with an SDL surface representing the
  /// locked area
  /// \returns 0 on success, or -1 if the texture is not valid or was not created
  /// with `SDL_TEXTUREACCESS_STREAMING`
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_LockTexture
  /// \sa SDL_UnlockTexture
  int SDL_LockTextureToSurface(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Pointer<SDL_Surface>> surface,
  ) {
    return _SDL_LockTextureToSurface(
      texture,
      rect,
      surface,
    );
  }

  late final _SDL_LockTextureToSurfacePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
                  ffi.Pointer<ffi.Pointer<SDL_Surface>>)>>(
      'SDL_LockTextureToSurface');
  late final _SDL_LockTextureToSurface =
      _SDL_LockTextureToSurfacePtr.asFunction<
          int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Pointer<SDL_Surface>>)>();

  /// Unlock a texture, uploading the changes to video memory, if needed.
  ///
  /// **Warning**: Please note that SDL_LockTexture() is intended to be
  /// write-only; it will not guarantee the previous contents of the texture will
  /// be provided. You must fully initialize any area of a texture that you lock
  /// before unlocking it, as the pixels might otherwise be uninitialized memory.
  ///
  /// Which is to say: locking and immediately unlocking a texture can result in
  /// corrupted textures, depending on the renderer in use.
  ///
  /// \param texture a texture locked by SDL_LockTexture()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockTexture
  void SDL_UnlockTexture(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_UnlockTexture(
      texture,
    );
  }

  late final _SDL_UnlockTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Texture>)>>(
          'SDL_UnlockTexture');
  late final _SDL_UnlockTexture = _SDL_UnlockTexturePtr.asFunction<
      void Function(ffi.Pointer<SDL_Texture>)>();

  /// Determine whether a renderer supports the use of render targets.
  ///
  /// \param renderer the renderer that will be checked
  /// \returns SDL_TRUE if supported or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderTarget
  SDL_bool SDL_RenderTargetSupported(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return SDL_bool.fromValue(_SDL_RenderTargetSupported(
      renderer,
    ));
  }

  late final _SDL_RenderTargetSupportedPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderTargetSupported');
  late final _SDL_RenderTargetSupported = _SDL_RenderTargetSupportedPtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Set a texture as the current rendering target.
  ///
  /// Before using this function, you should check the
  /// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if
  /// render targets are supported.
  ///
  /// The default render target is the window for which the renderer was created.
  /// To stop rendering to a texture and render to the window again, call this
  /// function with a NULL `texture`.
  ///
  /// \param renderer the rendering context
  /// \param texture the targeted texture, which must be created with the
  /// `SDL_TEXTUREACCESS_TARGET` flag, or NULL to render to the
  /// window instead of a texture.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRenderTarget
  int SDL_SetRenderTarget(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_SetRenderTarget(
      renderer,
      texture,
    );
  }

  late final _SDL_SetRenderTargetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>)>>('SDL_SetRenderTarget');
  late final _SDL_SetRenderTarget = _SDL_SetRenderTargetPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>)>();

  /// Get the current render target.
  ///
  /// The default render target is the window for which the renderer was created,
  /// and is reported a NULL here.
  ///
  /// \param renderer the rendering context
  /// \returns the current render target or NULL for the default render target.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderTarget
  ffi.Pointer<SDL_Texture> SDL_GetRenderTarget(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_GetRenderTarget(
      renderer,
    );
  }

  late final _SDL_GetRenderTargetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Texture> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_GetRenderTarget');
  late final _SDL_GetRenderTarget = _SDL_GetRenderTargetPtr.asFunction<
      ffi.Pointer<SDL_Texture> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Set a device independent resolution for rendering.
  ///
  /// This function uses the viewport and scaling functionality to allow a fixed
  /// logical resolution for rendering, regardless of the actual output
  /// resolution. If the actual output resolution doesn't have the same aspect
  /// ratio the output rendering will be centered within the output display.
  ///
  /// If the output display is a window, mouse and touch events in the window
  /// will be filtered and scaled so they seem to arrive within the logical
  /// resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether
  /// relative motion events are also scaled.
  ///
  /// If this function results in scaling or subpixel drawing by the rendering
  /// backend, it will be handled using the appropriate quality hints.
  ///
  /// \param renderer the renderer for which resolution should be set
  /// \param w the width of the logical resolution
  /// \param h the height of the logical resolution
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderGetLogicalSize
  int SDL_RenderSetLogicalSize(
    ffi.Pointer<SDL_Renderer> renderer,
    int w,
    int h,
  ) {
    return _SDL_RenderSetLogicalSize(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_RenderSetLogicalSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Int,
              ffi.Int)>>('SDL_RenderSetLogicalSize');
  late final _SDL_RenderSetLogicalSize = _SDL_RenderSetLogicalSizePtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>, int, int)>();

  /// Get device independent resolution for rendering.
  ///
  /// When using the main rendering target (eg no target texture is set): this
  /// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical
  /// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical
  /// width and height.
  ///
  /// When using a target texture: Never return 0 for `w` and `h` at first. Then
  /// it returns the logical width and height that are set.
  ///
  /// \param renderer a rendering context
  /// \param w an int to be filled with the width
  /// \param h an int to be filled with the height
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderSetLogicalSize
  void SDL_RenderGetLogicalSize(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_RenderGetLogicalSize(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_RenderGetLogicalSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_RenderGetLogicalSize');
  late final _SDL_RenderGetLogicalSize =
      _SDL_RenderGetLogicalSizePtr.asFunction<
          void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set whether to force integer scales for resolution-independent rendering.
  ///
  /// This function restricts the logical viewport to integer values - that is,
  /// when a resolution is between two multiples of a logical size, the viewport
  /// size is rounded down to the lower multiple.
  ///
  /// \param renderer the renderer for which integer scaling should be set
  /// \param enable enable or disable the integer scaling for rendering
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_RenderGetIntegerScale
  /// \sa SDL_RenderSetLogicalSize
  int SDL_RenderSetIntegerScale(
    ffi.Pointer<SDL_Renderer> renderer,
    SDL_bool enable,
  ) {
    return _SDL_RenderSetIntegerScale(
      renderer,
      enable.value,
    );
  }

  late final _SDL_RenderSetIntegerScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.UnsignedInt)>>('SDL_RenderSetIntegerScale');
  late final _SDL_RenderSetIntegerScale = _SDL_RenderSetIntegerScalePtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>, int)>();

  /// Get whether integer scales are forced for resolution-independent rendering.
  ///
  /// \param renderer the renderer from which integer scaling should be queried
  /// \returns SDL_TRUE if integer scales are forced or SDL_FALSE if not and on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_RenderSetIntegerScale
  SDL_bool SDL_RenderGetIntegerScale(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return SDL_bool.fromValue(_SDL_RenderGetIntegerScale(
      renderer,
    ));
  }

  late final _SDL_RenderGetIntegerScalePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderGetIntegerScale');
  late final _SDL_RenderGetIntegerScale = _SDL_RenderGetIntegerScalePtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Set the drawing area for rendering on the current target.
  ///
  /// When the window is resized, the viewport is reset to fill the entire new
  /// window size.
  ///
  /// \param renderer the rendering context
  /// \param rect the SDL_Rect structure representing the drawing area, or NULL
  /// to set the viewport to the entire target
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderGetViewport
  int SDL_RenderSetViewport(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderSetViewport(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderSetViewportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderSetViewport');
  late final _SDL_RenderSetViewport = _SDL_RenderSetViewportPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Get the drawing area for the current target.
  ///
  /// \param renderer the rendering context
  /// \param rect an SDL_Rect structure filled in with the current drawing area
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderSetViewport
  void SDL_RenderGetViewport(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderGetViewport(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderGetViewportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderGetViewport');
  late final _SDL_RenderGetViewport = _SDL_RenderGetViewportPtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Set the clip rectangle for rendering on the specified target.
  ///
  /// \param renderer the rendering context for which clip rectangle should be
  /// set
  /// \param rect an SDL_Rect structure representing the clip area, relative to
  /// the viewport, or NULL to disable clipping
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderGetClipRect
  /// \sa SDL_RenderIsClipEnabled
  int SDL_RenderSetClipRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderSetClipRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderSetClipRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderSetClipRect');
  late final _SDL_RenderSetClipRect = _SDL_RenderSetClipRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Get the clip rectangle for the current target.
  ///
  /// \param renderer the rendering context from which clip rectangle should be
  /// queried
  /// \param rect an SDL_Rect structure filled in with the current clipping area
  /// or an empty rectangle if clipping is disabled
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderIsClipEnabled
  /// \sa SDL_RenderSetClipRect
  void SDL_RenderGetClipRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderGetClipRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderGetClipRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderGetClipRect');
  late final _SDL_RenderGetClipRect = _SDL_RenderGetClipRectPtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Get whether clipping is enabled on the given renderer.
  ///
  /// \param renderer the renderer from which clip state should be queried
  /// \returns SDL_TRUE if clipping is enabled or SDL_FALSE if not; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_RenderGetClipRect
  /// \sa SDL_RenderSetClipRect
  SDL_bool SDL_RenderIsClipEnabled(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return SDL_bool.fromValue(_SDL_RenderIsClipEnabled(
      renderer,
    ));
  }

  late final _SDL_RenderIsClipEnabledPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderIsClipEnabled');
  late final _SDL_RenderIsClipEnabled = _SDL_RenderIsClipEnabledPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Set the drawing scale for rendering on the current target.
  ///
  /// The drawing coordinates are scaled by the x/y scaling factors before they
  /// are used by the renderer. This allows resolution independent drawing with a
  /// single coordinate system.
  ///
  /// If this results in scaling or subpixel drawing by the rendering backend, it
  /// will be handled using the appropriate quality hints. For best results use
  /// integer scaling factors.
  ///
  /// \param renderer a rendering context
  /// \param scaleX the horizontal scaling factor
  /// \param scaleY the vertical scaling factor
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderGetScale
  /// \sa SDL_RenderSetLogicalSize
  int SDL_RenderSetScale(
    ffi.Pointer<SDL_Renderer> renderer,
    double scaleX,
    double scaleY,
  ) {
    return _SDL_RenderSetScale(
      renderer,
      scaleX,
      scaleY,
    );
  }

  late final _SDL_RenderSetScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Float,
              ffi.Float)>>('SDL_RenderSetScale');
  late final _SDL_RenderSetScale = _SDL_RenderSetScalePtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, double, double)>();

  /// Get the drawing scale for the current target.
  ///
  /// \param renderer the renderer from which drawing scale should be queried
  /// \param scaleX a pointer filled in with the horizontal scaling factor
  /// \param scaleY a pointer filled in with the vertical scaling factor
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderSetScale
  void SDL_RenderGetScale(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Float> scaleX,
    ffi.Pointer<ffi.Float> scaleY,
  ) {
    return _SDL_RenderGetScale(
      renderer,
      scaleX,
      scaleY,
    );
  }

  late final _SDL_RenderGetScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_RenderGetScale');
  late final _SDL_RenderGetScale = _SDL_RenderGetScalePtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Get logical coordinates of point in renderer when given real coordinates of
  /// point in window.
  ///
  /// Logical coordinates will differ from real coordinates when render is scaled
  /// and logical renderer size set
  ///
  /// \param renderer the renderer from which the logical coordinates should be
  /// calculated
  /// \param windowX the real X coordinate in the window
  /// \param windowY the real Y coordinate in the window
  /// \param logicalX the pointer filled with the logical x coordinate
  /// \param logicalY the pointer filled with the logical y coordinate
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_RenderGetScale
  /// \sa SDL_RenderSetScale
  /// \sa SDL_RenderGetLogicalSize
  /// \sa SDL_RenderSetLogicalSize
  void SDL_RenderWindowToLogical(
    ffi.Pointer<SDL_Renderer> renderer,
    int windowX,
    int windowY,
    ffi.Pointer<ffi.Float> logicalX,
    ffi.Pointer<ffi.Float> logicalY,
  ) {
    return _SDL_RenderWindowToLogical(
      renderer,
      windowX,
      windowY,
      logicalX,
      logicalY,
    );
  }

  late final _SDL_RenderWindowToLogicalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_RenderWindowToLogical');
  late final _SDL_RenderWindowToLogical =
      _SDL_RenderWindowToLogicalPtr.asFunction<
          void Function(ffi.Pointer<SDL_Renderer>, int, int,
              ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>)>();

  /// Get real coordinates of point in window when given logical coordinates of
  /// point in renderer.
  ///
  /// Logical coordinates will differ from real coordinates when render is scaled
  /// and logical renderer size set
  ///
  /// \param renderer the renderer from which the window coordinates should be
  /// calculated
  /// \param logicalX the logical x coordinate
  /// \param logicalY the logical y coordinate
  /// \param windowX the pointer filled with the real X coordinate in the window
  /// \param windowY the pointer filled with the real Y coordinate in the window
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_RenderGetScale
  /// \sa SDL_RenderSetScale
  /// \sa SDL_RenderGetLogicalSize
  /// \sa SDL_RenderSetLogicalSize
  void SDL_RenderLogicalToWindow(
    ffi.Pointer<SDL_Renderer> renderer,
    double logicalX,
    double logicalY,
    ffi.Pointer<ffi.Int> windowX,
    ffi.Pointer<ffi.Int> windowY,
  ) {
    return _SDL_RenderLogicalToWindow(
      renderer,
      logicalX,
      logicalY,
      windowX,
      windowY,
    );
  }

  late final _SDL_RenderLogicalToWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Float,
              ffi.Float,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_RenderLogicalToWindow');
  late final _SDL_RenderLogicalToWindow =
      _SDL_RenderLogicalToWindowPtr.asFunction<
          void Function(ffi.Pointer<SDL_Renderer>, double, double,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Set the color used for drawing operations (Rect, Line and Clear).
  ///
  /// Set the color for drawing or filling rectangles, lines, and points, and for
  /// SDL_RenderClear().
  ///
  /// \param renderer the rendering context
  /// \param r the red value used to draw on the rendering target
  /// \param g the green value used to draw on the rendering target
  /// \param b the blue value used to draw on the rendering target
  /// \param a the alpha value used to draw on the rendering target; usually
  /// `SDL_ALPHA_OPAQUE` (255). Use SDL_SetRenderDrawBlendMode to
  /// specify how the alpha channel is used
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRenderDrawColor
  /// \sa SDL_RenderClear
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  int SDL_SetRenderDrawColor(
    ffi.Pointer<SDL_Renderer> renderer,
    int r,
    int g,
    int b,
    int a,
  ) {
    return _SDL_SetRenderDrawColor(
      renderer,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_SetRenderDrawColorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, Uint8, Uint8, Uint8,
              Uint8)>>('SDL_SetRenderDrawColor');
  late final _SDL_SetRenderDrawColor = _SDL_SetRenderDrawColorPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int, int, int, int)>();

  /// Get the color used for drawing operations (Rect, Line and Clear).
  ///
  /// \param renderer the rendering context
  /// \param r a pointer filled in with the red value used to draw on the
  /// rendering target
  /// \param g a pointer filled in with the green value used to draw on the
  /// rendering target
  /// \param b a pointer filled in with the blue value used to draw on the
  /// rendering target
  /// \param a a pointer filled in with the alpha value used to draw on the
  /// rendering target; usually `SDL_ALPHA_OPAQUE` (255)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderDrawColor
  int SDL_GetRenderDrawColor(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
    ffi.Pointer<Uint8> a,
  ) {
    return _SDL_GetRenderDrawColor(
      renderer,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_GetRenderDrawColorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRenderDrawColor');
  late final _SDL_GetRenderDrawColor = _SDL_GetRenderDrawColorPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Set the blend mode used for drawing operations (Fill and Line).
  ///
  /// If the blend mode is not supported, the closest supported mode is chosen.
  ///
  /// \param renderer the rendering context
  /// \param blendMode the SDL_BlendMode to use for blending
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRenderDrawBlendMode
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  int SDL_SetRenderDrawBlendMode(
    ffi.Pointer<SDL_Renderer> renderer,
    SDL_BlendMode blendMode,
  ) {
    return _SDL_SetRenderDrawBlendMode(
      renderer,
      blendMode.value,
    );
  }

  late final _SDL_SetRenderDrawBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.UnsignedInt)>>('SDL_SetRenderDrawBlendMode');
  late final _SDL_SetRenderDrawBlendMode = _SDL_SetRenderDrawBlendModePtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>, int)>();

  /// Get the blend mode used for drawing operations.
  ///
  /// \param renderer the rendering context
  /// \param blendMode a pointer filled in with the current SDL_BlendMode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderDrawBlendMode
  int SDL_GetRenderDrawBlendMode(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.UnsignedInt> blendMode,
  ) {
    return _SDL_GetRenderDrawBlendMode(
      renderer,
      blendMode,
    );
  }

  late final _SDL_GetRenderDrawBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<ffi.UnsignedInt>)>>('SDL_GetRenderDrawBlendMode');
  late final _SDL_GetRenderDrawBlendMode =
      _SDL_GetRenderDrawBlendModePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// Clear the current rendering target with the drawing color.
  ///
  /// This function clears the entire rendering target, ignoring the viewport and
  /// the clip rectangle.
  ///
  /// \param renderer the rendering context
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderClear(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderClear(
      renderer,
    );
  }

  late final _SDL_RenderClearPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_RenderClear');
  late final _SDL_RenderClear =
      _SDL_RenderClearPtr.asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Draw a point on the current rendering target.
  ///
  /// SDL_RenderDrawPoint() draws a single point. If you want to draw multiple,
  /// use SDL_RenderDrawPoints() instead.
  ///
  /// \param renderer the rendering context
  /// \param x the x coordinate of the point
  /// \param y the y coordinate of the point
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawPoint(
    ffi.Pointer<SDL_Renderer> renderer,
    int x,
    int y,
  ) {
    return _SDL_RenderDrawPoint(
      renderer,
      x,
      y,
    );
  }

  late final _SDL_RenderDrawPointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Int,
              ffi.Int)>>('SDL_RenderDrawPoint');
  late final _SDL_RenderDrawPoint = _SDL_RenderDrawPointPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int, int)>();

  /// Draw multiple points on the current rendering target.
  ///
  /// \param renderer the rendering context
  /// \param points an array of SDL_Point structures that represent the points to
  /// draw
  /// \param count the number of points to draw
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawPoints(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Point> points,
    int count,
  ) {
    return _SDL_RenderDrawPoints(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawPointsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>,
              ffi.Int)>>('SDL_RenderDrawPoints');
  late final _SDL_RenderDrawPoints = _SDL_RenderDrawPointsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>, int)>();

  /// Draw a line on the current rendering target.
  ///
  /// SDL_RenderDrawLine() draws the line to include both end points. If you want
  /// to draw multiple, connecting lines use SDL_RenderDrawLines() instead.
  ///
  /// \param renderer the rendering context
  /// \param x1 the x coordinate of the start point
  /// \param y1 the y coordinate of the start point
  /// \param x2 the x coordinate of the end point
  /// \param y2 the y coordinate of the end point
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawLine(
    ffi.Pointer<SDL_Renderer> renderer,
    int x1,
    int y1,
    int x2,
    int y2,
  ) {
    return _SDL_RenderDrawLine(
      renderer,
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _SDL_RenderDrawLinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int)>>('SDL_RenderDrawLine');
  late final _SDL_RenderDrawLine = _SDL_RenderDrawLinePtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int, int, int, int)>();

  /// Draw a series of connected lines on the current rendering target.
  ///
  /// \param renderer the rendering context
  /// \param points an array of SDL_Point structures representing points along
  /// the lines
  /// \param count the number of points, drawing count-1 lines
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawLines(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Point> points,
    int count,
  ) {
    return _SDL_RenderDrawLines(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawLinesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>,
              ffi.Int)>>('SDL_RenderDrawLines');
  late final _SDL_RenderDrawLines = _SDL_RenderDrawLinesPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>, int)>();

  /// Draw a rectangle on the current rendering target.
  ///
  /// \param renderer the rendering context
  /// \param rect an SDL_Rect structure representing the rectangle to draw, or
  /// NULL to outline the entire rendering target
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderDrawRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderDrawRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderDrawRect');
  late final _SDL_RenderDrawRect = _SDL_RenderDrawRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Draw some number of rectangles on the current rendering target.
  ///
  /// \param renderer the rendering context
  /// \param rects an array of SDL_Rect structures representing the rectangles to
  /// be drawn
  /// \param count the number of rectangles
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawRects(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rects,
    int count,
  ) {
    return _SDL_RenderDrawRects(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderDrawRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>,
              ffi.Int)>>('SDL_RenderDrawRects');
  late final _SDL_RenderDrawRects = _SDL_RenderDrawRectsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>, int)>();

  /// Fill a rectangle on the current rendering target with the drawing color.
  ///
  /// The current drawing color is set by SDL_SetRenderDrawColor(), and the
  /// color's alpha value is ignored unless blending is enabled with the
  /// appropriate call to SDL_SetRenderDrawBlendMode().
  ///
  /// \param renderer the rendering context
  /// \param rect the SDL_Rect structure representing the rectangle to fill, or
  /// NULL for the entire rendering target
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderFillRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderFillRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderFillRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderFillRect');
  late final _SDL_RenderFillRect = _SDL_RenderFillRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Fill some number of rectangles on the current rendering target with the
  /// drawing color.
  ///
  /// \param renderer the rendering context
  /// \param rects an array of SDL_Rect structures representing the rectangles to
  /// be filled
  /// \param count the number of rectangles
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderPresent
  int SDL_RenderFillRects(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rects,
    int count,
  ) {
    return _SDL_RenderFillRects(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderFillRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>,
              ffi.Int)>>('SDL_RenderFillRects');
  late final _SDL_RenderFillRects = _SDL_RenderFillRectsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>, int)>();

  /// Copy a portion of the texture to the current rendering target.
  ///
  /// The texture is blended with the destination based on its blend mode set
  /// with SDL_SetTextureBlendMode().
  ///
  /// The texture color is affected based on its color modulation set by
  /// SDL_SetTextureColorMod().
  ///
  /// The texture alpha is affected based on its alpha modulation set by
  /// SDL_SetTextureAlphaMod().
  ///
  /// \param renderer the rendering context
  /// \param texture the source texture
  /// \param srcrect the source SDL_Rect structure or NULL for the entire texture
  /// \param dstrect the destination SDL_Rect structure or NULL for the entire
  /// rendering target; the texture will be stretched to fill the
  /// given rectangle
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderCopyEx
  /// \sa SDL_SetTextureAlphaMod
  /// \sa SDL_SetTextureBlendMode
  /// \sa SDL_SetTextureColorMod
  int SDL_RenderCopy(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_RenderCopy(
      renderer,
      texture,
      srcrect,
      dstrect,
    );
  }

  late final _SDL_RenderCopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>>('SDL_RenderCopy');
  late final _SDL_RenderCopy = _SDL_RenderCopyPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>();

  /// Copy a portion of the texture to the current rendering, with optional
  /// rotation and flipping.
  ///
  /// Copy a portion of the texture to the current rendering target, optionally
  /// rotating it by angle around the given center and also flipping it
  /// top-bottom and/or left-right.
  ///
  /// The texture is blended with the destination based on its blend mode set
  /// with SDL_SetTextureBlendMode().
  ///
  /// The texture color is affected based on its color modulation set by
  /// SDL_SetTextureColorMod().
  ///
  /// The texture alpha is affected based on its alpha modulation set by
  /// SDL_SetTextureAlphaMod().
  ///
  /// \param renderer the rendering context
  /// \param texture the source texture
  /// \param srcrect the source SDL_Rect structure or NULL for the entire texture
  /// \param dstrect the destination SDL_Rect structure or NULL for the entire
  /// rendering target
  /// \param angle an angle in degrees that indicates the rotation that will be
  /// applied to dstrect, rotating it in a clockwise direction
  /// \param center a pointer to a point indicating the point around which
  /// dstrect will be rotated (if NULL, rotation will be done
  /// around `dstrect.w / 2`, `dstrect.h / 2`)
  /// \param flip a SDL_RendererFlip value stating which flipping actions should
  /// be performed on the texture
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderCopy
  /// \sa SDL_SetTextureAlphaMod
  /// \sa SDL_SetTextureBlendMode
  /// \sa SDL_SetTextureColorMod
  int SDL_RenderCopyEx(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Rect> dstrect,
    double angle,
    ffi.Pointer<SDL_Point> center,
    SDL_RendererFlip flip,
  ) {
    return _SDL_RenderCopyEx(
      renderer,
      texture,
      srcrect,
      dstrect,
      angle,
      center,
      flip.value,
    );
  }

  late final _SDL_RenderCopyExPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>,
              ffi.Double,
              ffi.Pointer<SDL_Point>,
              ffi.UnsignedInt)>>('SDL_RenderCopyEx');
  late final _SDL_RenderCopyEx = _SDL_RenderCopyExPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>,
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>,
          double,
          ffi.Pointer<SDL_Point>,
          int)>();

  /// Draw a point on the current rendering target at subpixel precision.
  ///
  /// \param renderer The renderer which should draw a point.
  /// \param x The x coordinate of the point.
  /// \param y The y coordinate of the point.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawPointF(
    ffi.Pointer<SDL_Renderer> renderer,
    double x,
    double y,
  ) {
    return _SDL_RenderDrawPointF(
      renderer,
      x,
      y,
    );
  }

  late final _SDL_RenderDrawPointFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Float,
              ffi.Float)>>('SDL_RenderDrawPointF');
  late final _SDL_RenderDrawPointF = _SDL_RenderDrawPointFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, double, double)>();

  /// Draw multiple points on the current rendering target at subpixel precision.
  ///
  /// \param renderer The renderer which should draw multiple points.
  /// \param points The points to draw
  /// \param count The number of points to draw
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawPointsF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FPoint> points,
    int count,
  ) {
    return _SDL_RenderDrawPointsF(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawPointsFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>,
              ffi.Int)>>('SDL_RenderDrawPointsF');
  late final _SDL_RenderDrawPointsF = _SDL_RenderDrawPointsFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>, int)>();

  /// Draw a line on the current rendering target at subpixel precision.
  ///
  /// \param renderer The renderer which should draw a line.
  /// \param x1 The x coordinate of the start point.
  /// \param y1 The y coordinate of the start point.
  /// \param x2 The x coordinate of the end point.
  /// \param y2 The y coordinate of the end point.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawLineF(
    ffi.Pointer<SDL_Renderer> renderer,
    double x1,
    double y1,
    double x2,
    double y2,
  ) {
    return _SDL_RenderDrawLineF(
      renderer,
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _SDL_RenderDrawLineFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Float, ffi.Float,
              ffi.Float, ffi.Float)>>('SDL_RenderDrawLineF');
  late final _SDL_RenderDrawLineF = _SDL_RenderDrawLineFPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>, double, double, double, double)>();

  /// Draw a series of connected lines on the current rendering target at
  /// subpixel precision.
  ///
  /// \param renderer The renderer which should draw multiple lines.
  /// \param points The points along the lines
  /// \param count The number of points, drawing count-1 lines
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawLinesF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FPoint> points,
    int count,
  ) {
    return _SDL_RenderDrawLinesF(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawLinesFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>,
              ffi.Int)>>('SDL_RenderDrawLinesF');
  late final _SDL_RenderDrawLinesF = _SDL_RenderDrawLinesFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>, int)>();

  /// Draw a rectangle on the current rendering target at subpixel precision.
  ///
  /// \param renderer The renderer which should draw a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL to outline the
  /// entire rendering target.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawRectF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rect,
  ) {
    return _SDL_RenderDrawRectF(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderDrawRectFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_FRect>)>>('SDL_RenderDrawRectF');
  late final _SDL_RenderDrawRectF = _SDL_RenderDrawRectFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>)>();

  /// Draw some number of rectangles on the current rendering target at subpixel
  /// precision.
  ///
  /// \param renderer The renderer which should draw multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawRectsF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rects,
    int count,
  ) {
    return _SDL_RenderDrawRectsF(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderDrawRectsFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>,
              ffi.Int)>>('SDL_RenderDrawRectsF');
  late final _SDL_RenderDrawRectsF = _SDL_RenderDrawRectsFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>, int)>();

  /// Fill a rectangle on the current rendering target with the drawing color at
  /// subpixel precision.
  ///
  /// \param renderer The renderer which should fill a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL for the entire
  /// rendering target.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderFillRectF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rect,
  ) {
    return _SDL_RenderFillRectF(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderFillRectFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_FRect>)>>('SDL_RenderFillRectF');
  late final _SDL_RenderFillRectF = _SDL_RenderFillRectFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>)>();

  /// Fill some number of rectangles on the current rendering target with the
  /// drawing color at subpixel precision.
  ///
  /// \param renderer The renderer which should fill multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderFillRectsF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rects,
    int count,
  ) {
    return _SDL_RenderFillRectsF(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderFillRectsFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>,
              ffi.Int)>>('SDL_RenderFillRectsF');
  late final _SDL_RenderFillRectsF = _SDL_RenderFillRectsFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>, int)>();

  /// Copy a portion of the texture to the current rendering target at subpixel
  /// precision.
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderCopyF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_FRect> dstrect,
  ) {
    return _SDL_RenderCopyF(
      renderer,
      texture,
      srcrect,
      dstrect,
    );
  }

  late final _SDL_RenderCopyFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_FRect>)>>('SDL_RenderCopyF');
  late final _SDL_RenderCopyF = _SDL_RenderCopyFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_FRect>)>();

  /// Copy a portion of the source texture to the current rendering target, with
  /// rotation and flipping, at subpixel precision.
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  /// \param angle An angle in degrees that indicates the rotation that will be
  /// applied to dstrect, rotating it in a clockwise direction
  /// \param center A pointer to a point indicating the point around which
  /// dstrect will be rotated (if NULL, rotation will be done
  /// around dstrect.w/2, dstrect.h/2).
  /// \param flip An SDL_RendererFlip value stating which flipping actions should
  /// be performed on the texture
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderCopyExF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_FRect> dstrect,
    double angle,
    ffi.Pointer<SDL_FPoint> center,
    SDL_RendererFlip flip,
  ) {
    return _SDL_RenderCopyExF(
      renderer,
      texture,
      srcrect,
      dstrect,
      angle,
      center,
      flip.value,
    );
  }

  late final _SDL_RenderCopyExFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_FRect>,
              ffi.Double,
              ffi.Pointer<SDL_FPoint>,
              ffi.UnsignedInt)>>('SDL_RenderCopyExF');
  late final _SDL_RenderCopyExF = _SDL_RenderCopyExFPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>,
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_FRect>,
          double,
          ffi.Pointer<SDL_FPoint>,
          int)>();

  /// Render a list of triangles, optionally using a texture and indices into the
  /// vertex array Color and alpha modulation is done per vertex
  /// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
  ///
  /// \param renderer The rendering context.
  /// \param texture (optional) The SDL texture to use.
  /// \param vertices Vertices.
  /// \param num_vertices Number of vertices.
  /// \param indices (optional) An array of integer indices into the 'vertices'
  /// array, if NULL all vertices will be rendered in sequential
  /// order.
  /// \param num_indices Number of indices.
  /// \return 0 on success, or -1 if the operation is not supported
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_RenderGeometryRaw
  /// \sa SDL_Vertex
  int SDL_RenderGeometry(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Vertex> vertices,
    int num_vertices,
    ffi.Pointer<ffi.Int> indices,
    int num_indices,
  ) {
    return _SDL_RenderGeometry(
      renderer,
      texture,
      vertices,
      num_vertices,
      indices,
      num_indices,
    );
  }

  late final _SDL_RenderGeometryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Vertex>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int)>>('SDL_RenderGeometry');
  late final _SDL_RenderGeometry = _SDL_RenderGeometryPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Vertex>, int, ffi.Pointer<ffi.Int>, int)>();

  /// Render a list of triangles, optionally using a texture and indices into the
  /// vertex arrays Color and alpha modulation is done per vertex
  /// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
  ///
  /// \param renderer The rendering context.
  /// \param texture (optional) The SDL texture to use.
  /// \param xy Vertex positions
  /// \param xy_stride Byte size to move from one element to the next element
  /// \param color Vertex colors (as SDL_Color)
  /// \param color_stride Byte size to move from one element to the next element
  /// \param uv Vertex normalized texture coordinates
  /// \param uv_stride Byte size to move from one element to the next element
  /// \param num_vertices Number of vertices.
  /// \param indices (optional) An array of indices into the 'vertices' arrays,
  /// if NULL all vertices will be rendered in sequential order.
  /// \param num_indices Number of indices.
  /// \param size_indices Index size: 1 (byte), 2 (short), 4 (int)
  /// \return 0 on success, or -1 if the operation is not supported
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_RenderGeometry
  /// \sa SDL_Vertex
  int SDL_RenderGeometryRaw(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Float> xy,
    int xy_stride,
    ffi.Pointer<SDL_Color> color,
    int color_stride,
    ffi.Pointer<ffi.Float> uv,
    int uv_stride,
    int num_vertices,
    ffi.Pointer<ffi.Void> indices,
    int num_indices,
    int size_indices,
  ) {
    return _SDL_RenderGeometryRaw(
      renderer,
      texture,
      xy,
      xy_stride,
      color,
      color_stride,
      uv,
      uv_stride,
      num_vertices,
      indices,
      num_indices,
      size_indices,
    );
  }

  late final _SDL_RenderGeometryRawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Pointer<SDL_Color>,
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int)>>('SDL_RenderGeometryRaw');
  late final _SDL_RenderGeometryRaw = _SDL_RenderGeometryRawPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>,
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<ffi.Float>,
          int,
          ffi.Pointer<SDL_Color>,
          int,
          ffi.Pointer<ffi.Float>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          int)>();

  /// Read pixels from the current rendering target to an array of pixels.
  ///
  /// **WARNING**: This is a very slow operation, and should not be used
  /// frequently. If you're using this on the main rendering target, it should be
  /// called after rendering and before SDL_RenderPresent().
  ///
  /// `pitch` specifies the number of bytes between rows in the destination
  /// `pixels` data. This allows you to write to a subrectangle or have padded
  /// rows in the destination. Generally, `pitch` should equal the number of
  /// pixels per row in the `pixels` data times the number of bytes per pixel,
  /// but it might contain additional padding (for example, 24bit RGB Windows
  /// Bitmap data pads all rows to multiples of 4 bytes).
  ///
  /// \param renderer the rendering context
  /// \param rect an SDL_Rect structure representing the area to read, or NULL
  /// for the entire render target
  /// \param format an SDL_PixelFormatEnum value of the desired format of the
  /// pixel data, or 0 to use the format of the rendering target
  /// \param pixels a pointer to the pixel data to copy into
  /// \param pitch the pitch of the `pixels` parameter
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_RenderReadPixels(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
    int format,
    ffi.Pointer<ffi.Void> pixels,
    int pitch,
  ) {
    return _SDL_RenderReadPixels(
      renderer,
      rect,
      format,
      pixels,
      pitch,
    );
  }

  late final _SDL_RenderReadPixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>,
              Uint32, ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RenderReadPixels');
  late final _SDL_RenderReadPixels = _SDL_RenderReadPixelsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Update the screen with any rendering performed since the previous call.
  ///
  /// SDL's rendering functions operate on a backbuffer; that is, calling a
  /// rendering function such as SDL_RenderDrawLine() does not directly put a
  /// line on the screen, but rather updates the backbuffer. As such, you compose
  /// your entire scene and *present* the composed backbuffer to the screen as a
  /// complete picture.
  ///
  /// Therefore, when using SDL's rendering API, one does all drawing intended
  /// for the frame, and then calls this function once per frame to present the
  /// final drawing to the user.
  ///
  /// The backbuffer should be considered invalidated after each present; do not
  /// assume that previous contents will exist between frames. You are strongly
  /// encouraged to call SDL_RenderClear() to initialize the backbuffer before
  /// starting each new frame's drawing, even if you plan to overwrite every
  /// pixel.
  ///
  /// \param renderer the rendering context
  ///
  /// \threadsafety You may only call this function on the main thread. If this
  /// happens to work on a background thread on any given platform
  /// or backend, it's purely by luck and you should not rely on it
  /// to work next time.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderClear
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  void SDL_RenderPresent(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderPresent(
      renderer,
    );
  }

  late final _SDL_RenderPresentPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_RenderPresent');
  late final _SDL_RenderPresent = _SDL_RenderPresentPtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>)>();

  /// Destroy the specified texture.
  ///
  /// Passing NULL or an otherwise invalid texture will set the SDL error message
  /// to "Invalid texture".
  ///
  /// \param texture the texture to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTexture
  /// \sa SDL_CreateTextureFromSurface
  void SDL_DestroyTexture(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_DestroyTexture(
      texture,
    );
  }

  late final _SDL_DestroyTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Texture>)>>(
          'SDL_DestroyTexture');
  late final _SDL_DestroyTexture = _SDL_DestroyTexturePtr.asFunction<
      void Function(ffi.Pointer<SDL_Texture>)>();

  /// Destroy the rendering context for a window and free associated textures.
  ///
  /// If `renderer` is NULL, this function will return immediately after setting
  /// the SDL error message to "Invalid renderer". See SDL_GetError().
  ///
  /// \param renderer the rendering context
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  void SDL_DestroyRenderer(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_DestroyRenderer(
      renderer,
    );
  }

  late final _SDL_DestroyRendererPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_DestroyRenderer');
  late final _SDL_DestroyRenderer = _SDL_DestroyRendererPtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>)>();

  /// Force the rendering context to flush any pending commands to the underlying
  /// rendering API.
  ///
  /// You do not need to (and in fact, shouldn't) call this function unless you
  /// are planning to call into OpenGL/Direct3D/Metal/whatever directly in
  /// addition to using an SDL_Renderer.
  ///
  /// This is for a very-specific case: if you are using SDL's render API, you
  /// asked for a specific renderer backend (OpenGL, Direct3D, etc), you set
  /// SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever
  /// calls in addition to SDL render API calls. If all of this applies, you
  /// should call SDL_RenderFlush() between calls to SDL's render API and the
  /// low-level API you're using in cooperation.
  ///
  /// In all other cases, you can ignore this function. This is only here to get
  /// maximum performance out of a specific situation. In all other cases, SDL
  /// will do the right thing, perhaps at a performance loss.
  ///
  /// This function is first available in SDL 2.0.10, and is not needed in 2.0.9
  /// and earlier, as earlier versions did not queue rendering commands at all,
  /// instead flushing them to the OS immediately.
  ///
  /// \param renderer the rendering context
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderFlush(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderFlush(
      renderer,
    );
  }

  late final _SDL_RenderFlushPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_RenderFlush');
  late final _SDL_RenderFlush =
      _SDL_RenderFlushPtr.asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Bind an OpenGL/ES/ES2 texture to the current context.
  ///
  /// This is for use with OpenGL instructions when rendering OpenGL primitives
  /// directly.
  ///
  /// If not NULL, `texw` and `texh` will be filled with the width and height
  /// values suitable for the provided texture. In most cases, both will be 1.0,
  /// however, on systems that support the GL_ARB_texture_rectangle extension,
  /// these values will actually be the pixel width and height used to create the
  /// texture, so this factor needs to be taken into account when providing
  /// texture coordinates to OpenGL.
  ///
  /// You need a renderer to create an SDL_Texture, therefore you can only use
  /// this function with an implicit OpenGL context from SDL_CreateRenderer(),
  /// not with your own OpenGL context. If you need control over your OpenGL
  /// context, you need to write your own texture-loading methods.
  ///
  /// Also note that SDL may upload RGB textures as BGR (or vice-versa), and
  /// re-order the color channels in the shaders phase, so the uploaded texture
  /// may have swapped color channels.
  ///
  /// \param texture the texture to bind to the current OpenGL/ES/ES2 context
  /// \param texw a pointer to a float value which will be filled with the
  /// texture width or NULL if you don't need that value
  /// \param texh a pointer to a float value which will be filled with the
  /// texture height or NULL if you don't need that value
  /// \returns 0 on success, or -1 if the operation is not supported; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_MakeCurrent
  /// \sa SDL_GL_UnbindTexture
  int SDL_GL_BindTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Float> texw,
    ffi.Pointer<ffi.Float> texh,
  ) {
    return _SDL_GL_BindTexture(
      texture,
      texw,
      texh,
    );
  }

  late final _SDL_GL_BindTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GL_BindTexture');
  late final _SDL_GL_BindTexture = _SDL_GL_BindTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Unbind an OpenGL/ES/ES2 texture from the current context.
  ///
  /// See SDL_GL_BindTexture() for examples on how to use these functions
  ///
  /// \param texture the texture to unbind from the current OpenGL/ES/ES2 context
  /// \returns 0 on success, or -1 if the operation is not supported
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_BindTexture
  /// \sa SDL_GL_MakeCurrent
  int SDL_GL_UnbindTexture(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_GL_UnbindTexture(
      texture,
    );
  }

  late final _SDL_GL_UnbindTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Texture>)>>(
          'SDL_GL_UnbindTexture');
  late final _SDL_GL_UnbindTexture = _SDL_GL_UnbindTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>)>();

  /// Get the CAMetalLayer associated with the given Metal renderer.
  ///
  /// This function returns `void *`, so SDL doesn't have to include Metal's
  /// headers, but it can be safely cast to a `CAMetalLayer *`.
  ///
  /// \param renderer The renderer to query
  /// \returns a `CAMetalLayer *` on success, or NULL if the renderer isn't a
  /// Metal renderer
  ///
  /// \since This function is available since SDL 2.0.8.
  ///
  /// \sa SDL_RenderGetMetalCommandEncoder
  ffi.Pointer<ffi.Void> SDL_RenderGetMetalLayer(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetMetalLayer(
      renderer,
    );
  }

  late final _SDL_RenderGetMetalLayerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetMetalLayer');
  late final _SDL_RenderGetMetalLayer = _SDL_RenderGetMetalLayerPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Get the Metal command encoder for the current frame
  ///
  /// This function returns `void *`, so SDL doesn't have to include Metal's
  /// headers, but it can be safely cast to an `id<MTLRenderCommandEncoder>`.
  ///
  /// Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give
  /// SDL a drawable to render to, which might happen if the window is
  /// hidden/minimized/offscreen. This doesn't apply to command encoders for
  /// render targets, just the window's backbuffer. Check your return values!
  ///
  /// \param renderer The renderer to query
  /// \returns an `id<MTLRenderCommandEncoder>` on success, or NULL if the
  /// renderer isn't a Metal renderer or there was an error.
  ///
  /// \since This function is available since SDL 2.0.8.
  ///
  /// \sa SDL_RenderGetMetalLayer
  ffi.Pointer<ffi.Void> SDL_RenderGetMetalCommandEncoder(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetMetalCommandEncoder(
      renderer,
    );
  }

  late final _SDL_RenderGetMetalCommandEncoderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetMetalCommandEncoder');
  late final _SDL_RenderGetMetalCommandEncoder =
      _SDL_RenderGetMetalCommandEncoderPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Toggle VSync of the given renderer.
  ///
  /// \param renderer The renderer to toggle
  /// \param vsync 1 for on, 0 for off. All other values are reserved
  /// \returns a 0 int on success, or non-zero on failure
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_RenderSetVSync(
    ffi.Pointer<SDL_Renderer> renderer,
    int vsync,
  ) {
    return _SDL_RenderSetVSync(
      renderer,
      vsync,
    );
  }

  late final _SDL_RenderSetVSyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>, ffi.Int)>>('SDL_RenderSetVSync');
  late final _SDL_RenderSetVSync = _SDL_RenderSetVSyncPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int)>();

  /// Get the number of milliseconds since SDL library initialization.
  ///
  /// This value wraps if the program runs for more than ~49 days.
  ///
  /// This function is not recommended as of SDL 2.0.18; use SDL_GetTicks64()
  /// instead, where the value doesn't wrap every ~49 days. There are places in
  /// SDL where we provide a 32-bit timestamp that can not change without
  /// breaking binary compatibility, though, so this function isn't officially
  /// deprecated.
  ///
  /// \returns an unsigned 32-bit value representing the number of milliseconds
  /// since the SDL library initialized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_TICKS_PASSED
  int SDL_GetTicks() {
    return _SDL_GetTicks();
  }

  late final _SDL_GetTicksPtr =
      _lookup<ffi.NativeFunction<Uint32 Function()>>('SDL_GetTicks');
  late final _SDL_GetTicks = _SDL_GetTicksPtr.asFunction<int Function()>();

  /// Get the number of milliseconds since SDL library initialization.
  ///
  /// Note that you should not use the SDL_TICKS_PASSED macro with values
  /// returned by this function, as that macro does clever math to compensate for
  /// the 32-bit overflow every ~49 days that SDL_GetTicks() suffers from. 64-bit
  /// values from this function can be safely compared directly.
  ///
  /// For example, if you want to wait 100 ms, you could do this:
  ///
  /// ```c
  /// const Uint64 timeout = SDL_GetTicks64() + 100;
  /// while (SDL_GetTicks64() < timeout) {
  /// // ... do work until timeout has elapsed
  /// }
  /// ```
  ///
  /// \returns an unsigned 64-bit value representing the number of milliseconds
  /// since the SDL library initialized.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_GetTicks64() {
    return _SDL_GetTicks64();
  }

  late final _SDL_GetTicks64Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function()>>('SDL_GetTicks64');
  late final _SDL_GetTicks64 = _SDL_GetTicks64Ptr.asFunction<int Function()>();

  /// Get the current value of the high resolution counter.
  ///
  /// This function is typically used for profiling.
  ///
  /// The counter values are only meaningful relative to each other. Differences
  /// between values can be converted to times by using
  /// SDL_GetPerformanceFrequency().
  ///
  /// \returns the current counter value.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetPerformanceFrequency
  int SDL_GetPerformanceCounter() {
    return _SDL_GetPerformanceCounter();
  }

  late final _SDL_GetPerformanceCounterPtr =
      _lookup<ffi.NativeFunction<Uint64 Function()>>(
          'SDL_GetPerformanceCounter');
  late final _SDL_GetPerformanceCounter =
      _SDL_GetPerformanceCounterPtr.asFunction<int Function()>();

  /// Get the count per second of the high resolution counter.
  ///
  /// \returns a platform-specific count per second.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetPerformanceCounter
  int SDL_GetPerformanceFrequency() {
    return _SDL_GetPerformanceFrequency();
  }

  late final _SDL_GetPerformanceFrequencyPtr =
      _lookup<ffi.NativeFunction<Uint64 Function()>>(
          'SDL_GetPerformanceFrequency');
  late final _SDL_GetPerformanceFrequency =
      _SDL_GetPerformanceFrequencyPtr.asFunction<int Function()>();

  /// Wait a specified number of milliseconds before returning.
  ///
  /// This function waits a specified number of milliseconds before returning. It
  /// waits at least the specified time, but possibly longer due to OS
  /// scheduling.
  ///
  /// \param ms the number of milliseconds to delay
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_Delay(
    int ms,
  ) {
    return _SDL_Delay(
      ms,
    );
  }

  late final _SDL_DelayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32)>>('SDL_Delay');
  late final _SDL_Delay = _SDL_DelayPtr.asFunction<void Function(int)>();

  /// Call a callback function at a future time.
  ///
  /// If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().
  ///
  /// The callback function is passed the current timer interval and the user
  /// supplied parameter from the SDL_AddTimer() call and should return the next
  /// timer interval. If the value returned from the callback is 0, the timer is
  /// canceled.
  ///
  /// The callback is run on a separate thread.
  ///
  /// Timers take into account the amount of time it took to execute the
  /// callback. For example, if the callback took 250 ms to execute and returned
  /// 1000 (ms), the timer would only wait another 750 ms before its next
  /// iteration.
  ///
  /// Timing may be inexact due to OS scheduling. Be sure to note the current
  /// time with SDL_GetTicks() or SDL_GetPerformanceCounter() in case your
  /// callback needs to adjust for variances.
  ///
  /// \param interval the timer delay, in milliseconds, passed to `callback`
  /// \param callback the SDL_TimerCallback function to call when the specified
  /// `interval` elapses
  /// \param param a pointer that is passed to `callback`
  /// \returns a timer ID or 0 if an error occurs; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RemoveTimer
  int SDL_AddTimer(
    int interval,
    SDL_TimerCallback callback,
    ffi.Pointer<ffi.Void> param,
  ) {
    return _SDL_AddTimer(
      interval,
      callback,
      param,
    );
  }

  late final _SDL_AddTimerPtr = _lookup<
      ffi.NativeFunction<
          SDL_TimerID Function(Uint32, SDL_TimerCallback,
              ffi.Pointer<ffi.Void>)>>('SDL_AddTimer');
  late final _SDL_AddTimer = _SDL_AddTimerPtr.asFunction<
      int Function(int, SDL_TimerCallback, ffi.Pointer<ffi.Void>)>();

  /// Remove a timer created with SDL_AddTimer().
  ///
  /// \param id the ID of the timer to remove
  /// \returns SDL_TRUE if the timer is removed or SDL_FALSE if the timer wasn't
  /// found.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AddTimer
  SDL_bool SDL_RemoveTimer(
    DartSDL_TimerID id,
  ) {
    return SDL_bool.fromValue(_SDL_RemoveTimer(
      id,
    ));
  }

  late final _SDL_RemoveTimerPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(SDL_TimerID)>>(
          'SDL_RemoveTimer');
  late final _SDL_RemoveTimer =
      _SDL_RemoveTimerPtr.asFunction<int Function(int)>();

  /// Initialize the SDL library.
  ///
  /// SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the
  /// two may be used interchangeably. Though for readability of your code
  /// SDL_InitSubSystem() might be preferred.
  ///
  /// The file I/O (for example: SDL_RWFromFile) and threading (SDL_CreateThread)
  /// subsystems are initialized by default. Message boxes
  /// (SDL_ShowSimpleMessageBox) also attempt to work without initializing the
  /// video subsystem, in hopes of being useful in showing an error dialog when
  /// SDL_Init fails. You must specifically initialize other subsystems if you
  /// use them in your application.
  ///
  /// Logging (such as SDL_Log) works without initialization, too.
  ///
  /// `flags` may be any of the following OR'd together:
  ///
  /// - `SDL_INIT_TIMER`: timer subsystem
  /// - `SDL_INIT_AUDIO`: audio subsystem
  /// - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events
  /// subsystem
  /// - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the
  /// events subsystem
  /// - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem
  /// - `SDL_INIT_GAMECONTROLLER`: controller subsystem; automatically
  /// initializes the joystick subsystem
  /// - `SDL_INIT_EVENTS`: events subsystem
  /// - `SDL_INIT_EVERYTHING`: all of the above subsystems
  /// - `SDL_INIT_NOPARACHUTE`: compatibility; this flag is ignored
  ///
  /// Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()
  /// for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or
  /// call SDL_Quit() to force shutdown). If a subsystem is already loaded then
  /// this call will increase the ref-count and return.
  ///
  /// \param flags subsystem initialization flags
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_InitSubSystem
  /// \sa SDL_Quit
  /// \sa SDL_SetMainReady
  /// \sa SDL_WasInit
  int SDL_Init(
    int flags,
  ) {
    return _SDL_Init(
      flags,
    );
  }

  late final _SDL_InitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Uint32)>>('SDL_Init');
  late final _SDL_Init = _SDL_InitPtr.asFunction<int Function(int)>();

  /// Compatibility function to initialize the SDL library.
  ///
  /// In SDL2, this function and SDL_Init() are interchangeable.
  ///
  /// \param flags any of the flags used by SDL_Init(); see SDL_Init for details.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Init
  /// \sa SDL_Quit
  /// \sa SDL_QuitSubSystem
  int SDL_InitSubSystem(
    int flags,
  ) {
    return _SDL_InitSubSystem(
      flags,
    );
  }

  late final _SDL_InitSubSystemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Uint32)>>(
          'SDL_InitSubSystem');
  late final _SDL_InitSubSystem =
      _SDL_InitSubSystemPtr.asFunction<int Function(int)>();

  /// Shut down specific SDL subsystems.
  ///
  /// If you start a subsystem using a call to that subsystem's init function
  /// (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),
  /// SDL_QuitSubSystem() and SDL_WasInit() will not work. You will need to use
  /// that subsystem's quit function (SDL_VideoQuit()) directly instead. But
  /// generally, you should not be using those functions directly anyhow; use
  /// SDL_Init() instead.
  ///
  /// You still need to call SDL_Quit() even if you close all open subsystems
  /// with SDL_QuitSubSystem().
  ///
  /// \param flags any of the flags used by SDL_Init(); see SDL_Init for details.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_InitSubSystem
  /// \sa SDL_Quit
  void SDL_QuitSubSystem(
    int flags,
  ) {
    return _SDL_QuitSubSystem(
      flags,
    );
  }

  late final _SDL_QuitSubSystemPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32)>>(
          'SDL_QuitSubSystem');
  late final _SDL_QuitSubSystem =
      _SDL_QuitSubSystemPtr.asFunction<void Function(int)>();

  /// Get a mask of the specified subsystems which are currently initialized.
  ///
  /// \param flags any of the flags used by SDL_Init(); see SDL_Init for details.
  /// \returns a mask of all initialized subsystems if `flags` is 0, otherwise it
  /// returns the initialization status of the specified subsystems.
  ///
  /// The return value does not include SDL_INIT_NOPARACHUTE.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Init
  /// \sa SDL_InitSubSystem
  int SDL_WasInit(
    int flags,
  ) {
    return _SDL_WasInit(
      flags,
    );
  }

  late final _SDL_WasInitPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(Uint32)>>('SDL_WasInit');
  late final _SDL_WasInit = _SDL_WasInitPtr.asFunction<int Function(int)>();

  /// Clean up all initialized subsystems.
  ///
  /// You should call this function even if you have already shutdown each
  /// initialized subsystem with SDL_QuitSubSystem(). It is safe to call this
  /// function even in the case of errors in initialization.
  ///
  /// If you start a subsystem using a call to that subsystem's init function
  /// (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),
  /// then you must use that subsystem's quit function (SDL_VideoQuit()) to shut
  /// it down before calling SDL_Quit(). But generally, you should not be using
  /// those functions directly anyhow; use SDL_Init() instead.
  ///
  /// You can use this function with atexit() to ensure that it is run when your
  /// application is shutdown, but it is not wise to do this from a library or
  /// other dynamically loaded code.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Init
  /// \sa SDL_QuitSubSystem
  void SDL_Quit() {
    return _SDL_Quit();
  }

  late final _SDL_QuitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_Quit');
  late final _SDL_Quit = _SDL_QuitPtr.asFunction<void Function()>();
}

final class SDL_BlitMap extends ffi.Opaque {}

typedef Uint32 = ffi.Uint32;
typedef DartUint32 = int;
typedef Uint8 = ffi.Uint8;
typedef DartUint8 = int;

/// The bits of this structure can be directly reinterpreted as an integer-packed
/// color which uses the SDL_PIXELFORMAT_RGBA32 format (SDL_PIXELFORMAT_ABGR8888
/// on little-endian systems and SDL_PIXELFORMAT_RGBA8888 on big-endian systems).
final class SDL_Color extends ffi.Struct {
  @Uint8()
  external int r;

  @Uint8()
  external int g;

  @Uint8()
  external int b;

  @Uint8()
  external int a;
}

final class SDL_Palette extends ffi.Struct {
  @ffi.Int()
  external int ncolors;

  external ffi.Pointer<SDL_Color> colors;

  @Uint32()
  external int version;

  @ffi.Int()
  external int refcount;
}

/// \note Everything in the pixel format structure is read-only.
final class SDL_PixelFormat extends ffi.Struct {
  @Uint32()
  external int format;

  external ffi.Pointer<SDL_Palette> palette;

  @Uint8()
  external int BitsPerPixel;

  @Uint8()
  external int BytesPerPixel;

  @ffi.Array.multi([2])
  external ffi.Array<Uint8> padding;

  @Uint32()
  external int Rmask;

  @Uint32()
  external int Gmask;

  @Uint32()
  external int Bmask;

  @Uint32()
  external int Amask;

  @Uint8()
  external int Rloss;

  @Uint8()
  external int Gloss;

  @Uint8()
  external int Bloss;

  @Uint8()
  external int Aloss;

  @Uint8()
  external int Rshift;

  @Uint8()
  external int Gshift;

  @Uint8()
  external int Bshift;

  @Uint8()
  external int Ashift;

  @ffi.Int()
  external int refcount;

  external ffi.Pointer<SDL_PixelFormat> next;
}

/// A rectangle, with the origin at the upper left (integer).
///
/// \sa SDL_RectEmpty
/// \sa SDL_RectEquals
/// \sa SDL_HasIntersection
/// \sa SDL_IntersectRect
/// \sa SDL_IntersectRectAndLine
/// \sa SDL_UnionRect
/// \sa SDL_EnclosePoints
final class SDL_Rect extends ffi.Struct {
  @ffi.Int()
  external int x;

  @ffi.Int()
  external int y;

  @ffi.Int()
  external int w;

  @ffi.Int()
  external int h;
}

/// \brief A collection of pixels used in software blitting.
///
/// \note  This structure should be treated as read-only, except for \c pixels,
/// which, if not NULL, contains the raw pixel data for the surface.
final class SDL_Surface extends ffi.Struct {
  /// < Read-only
  @Uint32()
  external int flags;

  /// < Read-only
  external ffi.Pointer<SDL_PixelFormat> format;

  /// < Read-only
  @ffi.Int()
  external int w;

  @ffi.Int()
  external int h;

  /// < Read-only
  @ffi.Int()
  external int pitch;

  /// < Read-write
  external ffi.Pointer<ffi.Void> pixels;

  /// < Read-write
  external ffi.Pointer<ffi.Void> userdata;

  /// < Read-only
  @ffi.Int()
  external int locked;

  /// < Private
  external ffi.Pointer<ffi.Void> list_blitmap;

  /// < Read-only
  external SDL_Rect clip_rect;

  /// < Private
  external ffi.Pointer<SDL_BlitMap> map;

  /// < Read-mostly
  @ffi.Int()
  external int refcount;
}

typedef SDL_blitFunction = ffi.Int Function(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect);
typedef DartSDL_blitFunction = int Function(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect);

/// \brief The type of function used for surface blitting functions.
typedef SDL_blit = ffi.Pointer<ffi.NativeFunction<SDL_blitFunction>>;

/// \brief The formula used for converting between YUV and RGB
enum SDL_YUV_CONVERSION_MODE {
  /// < Full range JPEG
  SDL_YUV_CONVERSION_JPEG(0),

  /// < BT.601 (the default)
  SDL_YUV_CONVERSION_BT601(1),

  /// < BT.709
  SDL_YUV_CONVERSION_BT709(2),

  /// < BT.601 for SD content, BT.709 for HD content
  SDL_YUV_CONVERSION_AUTOMATIC(3);

  final int value;
  const SDL_YUV_CONVERSION_MODE(this.value);

  static SDL_YUV_CONVERSION_MODE fromValue(int value) => switch (value) {
        0 => SDL_YUV_CONVERSION_JPEG,
        1 => SDL_YUV_CONVERSION_BT601,
        2 => SDL_YUV_CONVERSION_BT709,
        3 => SDL_YUV_CONVERSION_AUTOMATIC,
        _ => throw ArgumentError(
            "Unknown value for SDL_YUV_CONVERSION_MODE: $value"),
      };
}

typedef Sint64 = ffi.Int64;
typedef DartSint64 = int;

enum SDL_bool {
  SDL_FALSE(0),
  SDL_TRUE(1);

  final int value;
  const SDL_bool(this.value);

  static SDL_bool fromValue(int value) => switch (value) {
        0 => SDL_FALSE,
        1 => SDL_TRUE,
        _ => throw ArgumentError("Unknown value for SDL_bool: $value"),
      };
}

final class _IO_marker extends ffi.Opaque {}

typedef __off_t = ffi.Long;
typedef Dart__off_t = int;
typedef _IO_lock_t = ffi.Void;
typedef Dart_IO_lock_t = void;
typedef __off64_t = ffi.Long;
typedef Dart__off64_t = int;

final class _IO_codecvt extends ffi.Opaque {}

final class _IO_wide_data extends ffi.Opaque {}

final class _IO_FILE extends ffi.Struct {
  @ffi.Int()
  external int _flags;

  external ffi.Pointer<ffi.Char> _IO_read_ptr;

  external ffi.Pointer<ffi.Char> _IO_read_end;

  external ffi.Pointer<ffi.Char> _IO_read_base;

  external ffi.Pointer<ffi.Char> _IO_write_base;

  external ffi.Pointer<ffi.Char> _IO_write_ptr;

  external ffi.Pointer<ffi.Char> _IO_write_end;

  external ffi.Pointer<ffi.Char> _IO_buf_base;

  external ffi.Pointer<ffi.Char> _IO_buf_end;

  external ffi.Pointer<ffi.Char> _IO_save_base;

  external ffi.Pointer<ffi.Char> _IO_backup_base;

  external ffi.Pointer<ffi.Char> _IO_save_end;

  external ffi.Pointer<_IO_marker> _markers;

  external ffi.Pointer<_IO_FILE> _chain;

  @ffi.Int()
  external int _fileno;

  @ffi.Int()
  external int _flags2;

  @__off_t()
  external int _old_offset;

  @ffi.UnsignedShort()
  external int _cur_column;

  @ffi.SignedChar()
  external int _vtable_offset;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Char> _shortbuf;

  external ffi.Pointer<_IO_lock_t> _lock;

  @__off64_t()
  external int _offset;

  external ffi.Pointer<_IO_codecvt> _codecvt;

  external ffi.Pointer<_IO_wide_data> _wide_data;

  external ffi.Pointer<_IO_FILE> _freeres_list;

  external ffi.Pointer<ffi.Void> _freeres_buf;

  @ffi.Size()
  external int __pad5;

  @ffi.Int()
  external int _mode;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Char> _unused2;
}

typedef FILE = _IO_FILE;

final class UnnamedStruct1 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int autocloseAsInt;

  SDL_bool get autoclose => SDL_bool.fromValue(autocloseAsInt);

  external ffi.Pointer<FILE> fp;
}

final class UnnamedStruct2 extends ffi.Struct {
  external ffi.Pointer<Uint8> base;

  external ffi.Pointer<Uint8> here;

  external ffi.Pointer<Uint8> stop;
}

final class UnnamedStruct3 extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data1;

  external ffi.Pointer<ffi.Void> data2;
}

final class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 stdio;

  external UnnamedStruct2 mem;

  external UnnamedStruct3 unknown;
}

/// This is the read/write operation structure -- very basic.
final class SDL_RWops extends ffi.Struct {
  /// Return the size of the file in this rwops, or -1 if unknown
  external ffi.Pointer<
      ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops> context)>> size;

  /// Seek to \c offset relative to \c whence, one of stdio's whence values:
  /// RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END
  ///
  /// \return the final offset in the data stream, or -1 on error.
  external ffi.Pointer<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<SDL_RWops> context, Sint64 offset,
              ffi.Int whence)>> seek;

  /// Read up to \c maxnum objects each of size \c size from the data
  /// stream to the area pointed at by \c ptr.
  ///
  /// \return the number of objects read, or 0 at error or end of file.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops> context,
              ffi.Pointer<ffi.Void> ptr, ffi.Size size, ffi.Size maxnum)>> read;

  /// Write exactly \c num objects each of size \c size from the area
  /// pointed at by \c ptr to data stream.
  ///
  /// \return the number of objects written, or 0 at error or end of file.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops> context,
              ffi.Pointer<ffi.Void> ptr, ffi.Size size, ffi.Size num)>> write;

  /// Close and free an allocated SDL_RWops structure.
  ///
  /// \return 0 if successful or -1 on write error when flushing data.
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_RWops> context)>>
      close;

  @Uint32()
  external int type;

  external UnnamedUnion1 hidden;
}

/// \brief The blend mode used in SDL_RenderCopy() and drawing operations.
enum SDL_BlendMode {
  /// < no blending
  /// dstRGBA = srcRGBA
  SDL_BLENDMODE_NONE(0),

  /// < alpha blending
  /// dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
  /// dstA = srcA + (dstA * (1-srcA))
  SDL_BLENDMODE_BLEND(1),

  /// < additive blending
  /// dstRGB = (srcRGB * srcA) + dstRGB
  /// dstA = dstA
  SDL_BLENDMODE_ADD(2),

  /// < color modulate
  /// dstRGB = srcRGB * dstRGB
  /// dstA = dstA
  SDL_BLENDMODE_MOD(4),

  /// < color multiply
  /// dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA))
  /// dstA = dstA
  SDL_BLENDMODE_MUL(8),
  SDL_BLENDMODE_INVALID(2147483647);

  final int value;
  const SDL_BlendMode(this.value);

  static SDL_BlendMode fromValue(int value) => switch (value) {
        0 => SDL_BLENDMODE_NONE,
        1 => SDL_BLENDMODE_BLEND,
        2 => SDL_BLENDMODE_ADD,
        4 => SDL_BLENDMODE_MOD,
        8 => SDL_BLENDMODE_MUL,
        2147483647 => SDL_BLENDMODE_INVALID,
        _ => throw ArgumentError("Unknown value for SDL_BlendMode: $value"),
      };
}

/// \brief  The structure that defines a display mode
///
/// \sa SDL_GetNumDisplayModes()
/// \sa SDL_GetDisplayMode()
/// \sa SDL_GetDesktopDisplayMode()
/// \sa SDL_GetCurrentDisplayMode()
/// \sa SDL_GetClosestDisplayMode()
/// \sa SDL_SetWindowDisplayMode()
/// \sa SDL_GetWindowDisplayMode()
final class SDL_DisplayMode extends ffi.Struct {
  /// < pixel format
  @Uint32()
  external int format;

  /// < width, in screen coordinates
  @ffi.Int()
  external int w;

  /// < height, in screen coordinates
  @ffi.Int()
  external int h;

  /// < refresh rate (or zero for unspecified)
  @ffi.Int()
  external int refresh_rate;

  /// < driver-specific data, initialize to 0
  external ffi.Pointer<ffi.Void> driverdata;
}

final class SDL_Window extends ffi.Opaque {}

/// \brief The flags on a window
///
/// \sa SDL_GetWindowFlags()
enum SDL_WindowFlags {
  /// < fullscreen window
  SDL_WINDOW_FULLSCREEN(1),

  /// < window usable with OpenGL context
  SDL_WINDOW_OPENGL(2),

  /// < window is visible
  SDL_WINDOW_SHOWN(4),

  /// < window is not visible
  SDL_WINDOW_HIDDEN(8),

  /// < no window decoration
  SDL_WINDOW_BORDERLESS(16),

  /// < window can be resized
  SDL_WINDOW_RESIZABLE(32),

  /// < window is minimized
  SDL_WINDOW_MINIMIZED(64),

  /// < window is maximized
  SDL_WINDOW_MAXIMIZED(128),

  /// < window has grabbed mouse input
  SDL_WINDOW_MOUSE_GRABBED(256),

  /// < window has input focus
  SDL_WINDOW_INPUT_FOCUS(512),

  /// < window has mouse focus
  SDL_WINDOW_MOUSE_FOCUS(1024),
  SDL_WINDOW_FULLSCREEN_DESKTOP(4097),

  /// < window not created by SDL
  SDL_WINDOW_FOREIGN(2048),

  /// < window should be created in high-DPI mode if supported.
  /// On macOS NSHighResolutionCapable must be set true in the
  /// application's Info.plist for this to have any effect.
  SDL_WINDOW_ALLOW_HIGHDPI(8192),

  /// < window has mouse captured (unrelated to MOUSE_GRABBED)
  SDL_WINDOW_MOUSE_CAPTURE(16384),

  /// < window should always be above others
  SDL_WINDOW_ALWAYS_ON_TOP(32768),

  /// < window should not be added to the taskbar
  SDL_WINDOW_SKIP_TASKBAR(65536),

  /// < window should be treated as a utility window
  SDL_WINDOW_UTILITY(131072),

  /// < window should be treated as a tooltip
  SDL_WINDOW_TOOLTIP(262144),

  /// < window should be treated as a popup menu
  SDL_WINDOW_POPUP_MENU(524288),

  /// < window has grabbed keyboard input
  SDL_WINDOW_KEYBOARD_GRABBED(1048576),

  /// < window usable for Vulkan surface
  SDL_WINDOW_VULKAN(268435456),

  /// < window usable for Metal view
  SDL_WINDOW_METAL(536870912);

  /// < equivalent to SDL_WINDOW_MOUSE_GRABBED for compatibility
  static const SDL_WINDOW_INPUT_GRABBED = SDL_WINDOW_MOUSE_GRABBED;

  final int value;
  const SDL_WindowFlags(this.value);

  static SDL_WindowFlags fromValue(int value) => switch (value) {
        1 => SDL_WINDOW_FULLSCREEN,
        2 => SDL_WINDOW_OPENGL,
        4 => SDL_WINDOW_SHOWN,
        8 => SDL_WINDOW_HIDDEN,
        16 => SDL_WINDOW_BORDERLESS,
        32 => SDL_WINDOW_RESIZABLE,
        64 => SDL_WINDOW_MINIMIZED,
        128 => SDL_WINDOW_MAXIMIZED,
        256 => SDL_WINDOW_MOUSE_GRABBED,
        512 => SDL_WINDOW_INPUT_FOCUS,
        1024 => SDL_WINDOW_MOUSE_FOCUS,
        4097 => SDL_WINDOW_FULLSCREEN_DESKTOP,
        2048 => SDL_WINDOW_FOREIGN,
        8192 => SDL_WINDOW_ALLOW_HIGHDPI,
        16384 => SDL_WINDOW_MOUSE_CAPTURE,
        32768 => SDL_WINDOW_ALWAYS_ON_TOP,
        65536 => SDL_WINDOW_SKIP_TASKBAR,
        131072 => SDL_WINDOW_UTILITY,
        262144 => SDL_WINDOW_TOOLTIP,
        524288 => SDL_WINDOW_POPUP_MENU,
        1048576 => SDL_WINDOW_KEYBOARD_GRABBED,
        268435456 => SDL_WINDOW_VULKAN,
        536870912 => SDL_WINDOW_METAL,
        _ => throw ArgumentError("Unknown value for SDL_WindowFlags: $value"),
      };

  @override
  String toString() {
    if (this == SDL_WINDOW_MOUSE_GRABBED)
      return "SDL_WindowFlags.SDL_WINDOW_MOUSE_GRABBED, SDL_WindowFlags.SDL_WINDOW_INPUT_GRABBED";
    return super.toString();
  }
}

/// \brief Event subtype for window events
enum SDL_WindowEventID {
  /// < Never used
  SDL_WINDOWEVENT_NONE(0),

  /// < Window has been shown
  SDL_WINDOWEVENT_SHOWN(1),

  /// < Window has been hidden
  SDL_WINDOWEVENT_HIDDEN(2),

  /// < Window has been exposed and should be
  /// redrawn
  SDL_WINDOWEVENT_EXPOSED(3),

  /// < Window has been moved to data1, data2
  SDL_WINDOWEVENT_MOVED(4),

  /// < Window has been resized to data1xdata2
  SDL_WINDOWEVENT_RESIZED(5),

  /// < The window size has changed, either as
  /// a result of an API call or through the
  /// system or user changing the window size.
  SDL_WINDOWEVENT_SIZE_CHANGED(6),

  /// < Window has been minimized
  SDL_WINDOWEVENT_MINIMIZED(7),

  /// < Window has been maximized
  SDL_WINDOWEVENT_MAXIMIZED(8),

  /// < Window has been restored to normal size
  /// and position
  SDL_WINDOWEVENT_RESTORED(9),

  /// < Window has gained mouse focus
  SDL_WINDOWEVENT_ENTER(10),

  /// < Window has lost mouse focus
  SDL_WINDOWEVENT_LEAVE(11),

  /// < Window has gained keyboard focus
  SDL_WINDOWEVENT_FOCUS_GAINED(12),

  /// < Window has lost keyboard focus
  SDL_WINDOWEVENT_FOCUS_LOST(13),

  /// < The window manager requests that the window be closed
  SDL_WINDOWEVENT_CLOSE(14),

  /// < Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore)
  SDL_WINDOWEVENT_TAKE_FOCUS(15),

  /// < Window had a hit test that wasn't SDL_HITTEST_NORMAL.
  SDL_WINDOWEVENT_HIT_TEST(16),

  /// < The ICC profile of the window's display has changed.
  SDL_WINDOWEVENT_ICCPROF_CHANGED(17),

  /// < Window has been moved to display data1.
  SDL_WINDOWEVENT_DISPLAY_CHANGED(18);

  final int value;
  const SDL_WindowEventID(this.value);

  static SDL_WindowEventID fromValue(int value) => switch (value) {
        0 => SDL_WINDOWEVENT_NONE,
        1 => SDL_WINDOWEVENT_SHOWN,
        2 => SDL_WINDOWEVENT_HIDDEN,
        3 => SDL_WINDOWEVENT_EXPOSED,
        4 => SDL_WINDOWEVENT_MOVED,
        5 => SDL_WINDOWEVENT_RESIZED,
        6 => SDL_WINDOWEVENT_SIZE_CHANGED,
        7 => SDL_WINDOWEVENT_MINIMIZED,
        8 => SDL_WINDOWEVENT_MAXIMIZED,
        9 => SDL_WINDOWEVENT_RESTORED,
        10 => SDL_WINDOWEVENT_ENTER,
        11 => SDL_WINDOWEVENT_LEAVE,
        12 => SDL_WINDOWEVENT_FOCUS_GAINED,
        13 => SDL_WINDOWEVENT_FOCUS_LOST,
        14 => SDL_WINDOWEVENT_CLOSE,
        15 => SDL_WINDOWEVENT_TAKE_FOCUS,
        16 => SDL_WINDOWEVENT_HIT_TEST,
        17 => SDL_WINDOWEVENT_ICCPROF_CHANGED,
        18 => SDL_WINDOWEVENT_DISPLAY_CHANGED,
        _ => throw ArgumentError("Unknown value for SDL_WindowEventID: $value"),
      };
}

/// \brief Event subtype for display events
enum SDL_DisplayEventID {
  /// < Never used
  SDL_DISPLAYEVENT_NONE(0),

  /// < Display orientation has changed to data1
  SDL_DISPLAYEVENT_ORIENTATION(1),

  /// < Display has been added to the system
  SDL_DISPLAYEVENT_CONNECTED(2),

  /// < Display has been removed from the system
  SDL_DISPLAYEVENT_DISCONNECTED(3),

  /// < Display has changed position
  SDL_DISPLAYEVENT_MOVED(4);

  final int value;
  const SDL_DisplayEventID(this.value);

  static SDL_DisplayEventID fromValue(int value) => switch (value) {
        0 => SDL_DISPLAYEVENT_NONE,
        1 => SDL_DISPLAYEVENT_ORIENTATION,
        2 => SDL_DISPLAYEVENT_CONNECTED,
        3 => SDL_DISPLAYEVENT_DISCONNECTED,
        4 => SDL_DISPLAYEVENT_MOVED,
        _ =>
          throw ArgumentError("Unknown value for SDL_DisplayEventID: $value"),
      };
}

/// \brief Display orientation
enum SDL_DisplayOrientation {
  /// < The display orientation can't be determined
  SDL_ORIENTATION_UNKNOWN(0),

  /// < The display is in landscape mode, with the right side up, relative to portrait mode
  SDL_ORIENTATION_LANDSCAPE(1),

  /// < The display is in landscape mode, with the left side up, relative to portrait mode
  SDL_ORIENTATION_LANDSCAPE_FLIPPED(2),

  /// < The display is in portrait mode
  SDL_ORIENTATION_PORTRAIT(3),

  /// < The display is in portrait mode, upside down
  SDL_ORIENTATION_PORTRAIT_FLIPPED(4);

  final int value;
  const SDL_DisplayOrientation(this.value);

  static SDL_DisplayOrientation fromValue(int value) => switch (value) {
        0 => SDL_ORIENTATION_UNKNOWN,
        1 => SDL_ORIENTATION_LANDSCAPE,
        2 => SDL_ORIENTATION_LANDSCAPE_FLIPPED,
        3 => SDL_ORIENTATION_PORTRAIT,
        4 => SDL_ORIENTATION_PORTRAIT_FLIPPED,
        _ => throw ArgumentError(
            "Unknown value for SDL_DisplayOrientation: $value"),
      };
}

/// \brief Window flash operation
enum SDL_FlashOperation {
  /// < Cancel any window flash state
  SDL_FLASH_CANCEL(0),

  /// < Flash the window briefly to get attention
  SDL_FLASH_BRIEFLY(1),

  /// < Flash the window until it gets focus
  SDL_FLASH_UNTIL_FOCUSED(2);

  final int value;
  const SDL_FlashOperation(this.value);

  static SDL_FlashOperation fromValue(int value) => switch (value) {
        0 => SDL_FLASH_CANCEL,
        1 => SDL_FLASH_BRIEFLY,
        2 => SDL_FLASH_UNTIL_FOCUSED,
        _ =>
          throw ArgumentError("Unknown value for SDL_FlashOperation: $value"),
      };
}

/// \brief An opaque handle to an OpenGL context.
typedef SDL_GLContext = ffi.Pointer<ffi.Void>;

/// \brief OpenGL configuration attributes
enum SDL_GLattr {
  SDL_GL_RED_SIZE(0),
  SDL_GL_GREEN_SIZE(1),
  SDL_GL_BLUE_SIZE(2),
  SDL_GL_ALPHA_SIZE(3),
  SDL_GL_BUFFER_SIZE(4),
  SDL_GL_DOUBLEBUFFER(5),
  SDL_GL_DEPTH_SIZE(6),
  SDL_GL_STENCIL_SIZE(7),
  SDL_GL_ACCUM_RED_SIZE(8),
  SDL_GL_ACCUM_GREEN_SIZE(9),
  SDL_GL_ACCUM_BLUE_SIZE(10),
  SDL_GL_ACCUM_ALPHA_SIZE(11),
  SDL_GL_STEREO(12),
  SDL_GL_MULTISAMPLEBUFFERS(13),
  SDL_GL_MULTISAMPLESAMPLES(14),
  SDL_GL_ACCELERATED_VISUAL(15),
  SDL_GL_RETAINED_BACKING(16),
  SDL_GL_CONTEXT_MAJOR_VERSION(17),
  SDL_GL_CONTEXT_MINOR_VERSION(18),
  SDL_GL_CONTEXT_EGL(19),
  SDL_GL_CONTEXT_FLAGS(20),
  SDL_GL_CONTEXT_PROFILE_MASK(21),
  SDL_GL_SHARE_WITH_CURRENT_CONTEXT(22),
  SDL_GL_FRAMEBUFFER_SRGB_CAPABLE(23),
  SDL_GL_CONTEXT_RELEASE_BEHAVIOR(24),
  SDL_GL_CONTEXT_RESET_NOTIFICATION(25),
  SDL_GL_CONTEXT_NO_ERROR(26),
  SDL_GL_FLOATBUFFERS(27);

  final int value;
  const SDL_GLattr(this.value);

  static SDL_GLattr fromValue(int value) => switch (value) {
        0 => SDL_GL_RED_SIZE,
        1 => SDL_GL_GREEN_SIZE,
        2 => SDL_GL_BLUE_SIZE,
        3 => SDL_GL_ALPHA_SIZE,
        4 => SDL_GL_BUFFER_SIZE,
        5 => SDL_GL_DOUBLEBUFFER,
        6 => SDL_GL_DEPTH_SIZE,
        7 => SDL_GL_STENCIL_SIZE,
        8 => SDL_GL_ACCUM_RED_SIZE,
        9 => SDL_GL_ACCUM_GREEN_SIZE,
        10 => SDL_GL_ACCUM_BLUE_SIZE,
        11 => SDL_GL_ACCUM_ALPHA_SIZE,
        12 => SDL_GL_STEREO,
        13 => SDL_GL_MULTISAMPLEBUFFERS,
        14 => SDL_GL_MULTISAMPLESAMPLES,
        15 => SDL_GL_ACCELERATED_VISUAL,
        16 => SDL_GL_RETAINED_BACKING,
        17 => SDL_GL_CONTEXT_MAJOR_VERSION,
        18 => SDL_GL_CONTEXT_MINOR_VERSION,
        19 => SDL_GL_CONTEXT_EGL,
        20 => SDL_GL_CONTEXT_FLAGS,
        21 => SDL_GL_CONTEXT_PROFILE_MASK,
        22 => SDL_GL_SHARE_WITH_CURRENT_CONTEXT,
        23 => SDL_GL_FRAMEBUFFER_SRGB_CAPABLE,
        24 => SDL_GL_CONTEXT_RELEASE_BEHAVIOR,
        25 => SDL_GL_CONTEXT_RESET_NOTIFICATION,
        26 => SDL_GL_CONTEXT_NO_ERROR,
        27 => SDL_GL_FLOATBUFFERS,
        _ => throw ArgumentError("Unknown value for SDL_GLattr: $value"),
      };
}

enum SDL_GLprofile {
  SDL_GL_CONTEXT_PROFILE_CORE(1),
  SDL_GL_CONTEXT_PROFILE_COMPATIBILITY(2),

  /// < GLX_CONTEXT_ES2_PROFILE_BIT_EXT
  SDL_GL_CONTEXT_PROFILE_ES(4);

  final int value;
  const SDL_GLprofile(this.value);

  static SDL_GLprofile fromValue(int value) => switch (value) {
        1 => SDL_GL_CONTEXT_PROFILE_CORE,
        2 => SDL_GL_CONTEXT_PROFILE_COMPATIBILITY,
        4 => SDL_GL_CONTEXT_PROFILE_ES,
        _ => throw ArgumentError("Unknown value for SDL_GLprofile: $value"),
      };
}

enum SDL_GLcontextFlag {
  SDL_GL_CONTEXT_DEBUG_FLAG(1),
  SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG(2),
  SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG(4),
  SDL_GL_CONTEXT_RESET_ISOLATION_FLAG(8);

  final int value;
  const SDL_GLcontextFlag(this.value);

  static SDL_GLcontextFlag fromValue(int value) => switch (value) {
        1 => SDL_GL_CONTEXT_DEBUG_FLAG,
        2 => SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG,
        4 => SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG,
        8 => SDL_GL_CONTEXT_RESET_ISOLATION_FLAG,
        _ => throw ArgumentError("Unknown value for SDL_GLcontextFlag: $value"),
      };
}

enum SDL_GLcontextReleaseFlag {
  SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE(0),
  SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH(1);

  final int value;
  const SDL_GLcontextReleaseFlag(this.value);

  static SDL_GLcontextReleaseFlag fromValue(int value) => switch (value) {
        0 => SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE,
        1 => SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH,
        _ => throw ArgumentError(
            "Unknown value for SDL_GLcontextReleaseFlag: $value"),
      };
}

enum SDL_GLContextResetNotification {
  SDL_GL_CONTEXT_RESET_NO_NOTIFICATION(0),
  SDL_GL_CONTEXT_RESET_LOSE_CONTEXT(1);

  final int value;
  const SDL_GLContextResetNotification(this.value);

  static SDL_GLContextResetNotification fromValue(int value) => switch (value) {
        0 => SDL_GL_CONTEXT_RESET_NO_NOTIFICATION,
        1 => SDL_GL_CONTEXT_RESET_LOSE_CONTEXT,
        _ => throw ArgumentError(
            "Unknown value for SDL_GLContextResetNotification: $value"),
      };
}

/// The structure that defines a point (integer)
///
/// \sa SDL_EnclosePoints
/// \sa SDL_PointInRect
final class SDL_Point extends ffi.Struct {
  @ffi.Int()
  external int x;

  @ffi.Int()
  external int y;
}

typedef Uint16 = ffi.Uint16;
typedef DartUint16 = int;

/// Possible return values from the SDL_HitTest callback.
///
/// \sa SDL_HitTest
enum SDL_HitTestResult {
  /// < Region is normal. No special properties.
  SDL_HITTEST_NORMAL(0),

  /// < Region can drag entire window.
  SDL_HITTEST_DRAGGABLE(1),
  SDL_HITTEST_RESIZE_TOPLEFT(2),
  SDL_HITTEST_RESIZE_TOP(3),
  SDL_HITTEST_RESIZE_TOPRIGHT(4),
  SDL_HITTEST_RESIZE_RIGHT(5),
  SDL_HITTEST_RESIZE_BOTTOMRIGHT(6),
  SDL_HITTEST_RESIZE_BOTTOM(7),
  SDL_HITTEST_RESIZE_BOTTOMLEFT(8),
  SDL_HITTEST_RESIZE_LEFT(9);

  final int value;
  const SDL_HitTestResult(this.value);

  static SDL_HitTestResult fromValue(int value) => switch (value) {
        0 => SDL_HITTEST_NORMAL,
        1 => SDL_HITTEST_DRAGGABLE,
        2 => SDL_HITTEST_RESIZE_TOPLEFT,
        3 => SDL_HITTEST_RESIZE_TOP,
        4 => SDL_HITTEST_RESIZE_TOPRIGHT,
        5 => SDL_HITTEST_RESIZE_RIGHT,
        6 => SDL_HITTEST_RESIZE_BOTTOMRIGHT,
        7 => SDL_HITTEST_RESIZE_BOTTOM,
        8 => SDL_HITTEST_RESIZE_BOTTOMLEFT,
        9 => SDL_HITTEST_RESIZE_LEFT,
        _ => throw ArgumentError("Unknown value for SDL_HitTestResult: $value"),
      };
}

typedef SDL_HitTestFunction = ffi.UnsignedInt Function(
    ffi.Pointer<SDL_Window> win,
    ffi.Pointer<SDL_Point> area,
    ffi.Pointer<ffi.Void> data);
typedef DartSDL_HitTestFunction = SDL_HitTestResult Function(
    ffi.Pointer<SDL_Window> win,
    ffi.Pointer<SDL_Point> area,
    ffi.Pointer<ffi.Void> data);

/// Callback used for hit-testing.
///
/// \param win the SDL_Window where hit-testing was set on
/// \param area an SDL_Point which should be hit-tested
/// \param data what was passed as `callback_data` to SDL_SetWindowHitTest()
/// \return an SDL_HitTestResult value.
///
/// \sa SDL_SetWindowHitTest
typedef SDL_HitTest = ffi.Pointer<ffi.NativeFunction<SDL_HitTestFunction>>;

final class SDL_Cursor extends ffi.Opaque {}

/// \brief Cursor types for SDL_CreateSystemCursor().
enum SDL_SystemCursor {
  /// < Arrow
  SDL_SYSTEM_CURSOR_ARROW(0),

  /// < I-beam
  SDL_SYSTEM_CURSOR_IBEAM(1),

  /// < Wait
  SDL_SYSTEM_CURSOR_WAIT(2),

  /// < Crosshair
  SDL_SYSTEM_CURSOR_CROSSHAIR(3),

  /// < Small wait cursor (or Wait if not available)
  SDL_SYSTEM_CURSOR_WAITARROW(4),

  /// < Double arrow pointing northwest and southeast
  SDL_SYSTEM_CURSOR_SIZENWSE(5),

  /// < Double arrow pointing northeast and southwest
  SDL_SYSTEM_CURSOR_SIZENESW(6),

  /// < Double arrow pointing west and east
  SDL_SYSTEM_CURSOR_SIZEWE(7),

  /// < Double arrow pointing north and south
  SDL_SYSTEM_CURSOR_SIZENS(8),

  /// < Four pointed arrow pointing north, south, east, and west
  SDL_SYSTEM_CURSOR_SIZEALL(9),

  /// < Slashed circle or crossbones
  SDL_SYSTEM_CURSOR_NO(10),

  /// < Hand
  SDL_SYSTEM_CURSOR_HAND(11),
  SDL_NUM_SYSTEM_CURSORS(12);

  final int value;
  const SDL_SystemCursor(this.value);

  static SDL_SystemCursor fromValue(int value) => switch (value) {
        0 => SDL_SYSTEM_CURSOR_ARROW,
        1 => SDL_SYSTEM_CURSOR_IBEAM,
        2 => SDL_SYSTEM_CURSOR_WAIT,
        3 => SDL_SYSTEM_CURSOR_CROSSHAIR,
        4 => SDL_SYSTEM_CURSOR_WAITARROW,
        5 => SDL_SYSTEM_CURSOR_SIZENWSE,
        6 => SDL_SYSTEM_CURSOR_SIZENESW,
        7 => SDL_SYSTEM_CURSOR_SIZEWE,
        8 => SDL_SYSTEM_CURSOR_SIZENS,
        9 => SDL_SYSTEM_CURSOR_SIZEALL,
        10 => SDL_SYSTEM_CURSOR_NO,
        11 => SDL_SYSTEM_CURSOR_HAND,
        12 => SDL_NUM_SYSTEM_CURSORS,
        _ => throw ArgumentError("Unknown value for SDL_SystemCursor: $value"),
      };
}

/// \brief Scroll direction types for the Scroll event
enum SDL_MouseWheelDirection {
  /// < The scroll direction is normal
  SDL_MOUSEWHEEL_NORMAL(0),

  /// < The scroll direction is flipped / natural
  SDL_MOUSEWHEEL_FLIPPED(1);

  final int value;
  const SDL_MouseWheelDirection(this.value);

  static SDL_MouseWheelDirection fromValue(int value) => switch (value) {
        0 => SDL_MOUSEWHEEL_NORMAL,
        1 => SDL_MOUSEWHEEL_FLIPPED,
        _ => throw ArgumentError(
            "Unknown value for SDL_MouseWheelDirection: $value"),
      };
}

/// The types of events that can be delivered.
enum SDL_EventType {
  /// < Unused (do not remove)
  SDL_FIRSTEVENT(0),

  /// < User-requested quit
  SDL_QUIT(256),

  /// < The application is being terminated by the OS
  /// Called on iOS in applicationWillTerminate()
  /// Called on Android in onDestroy()
  SDL_APP_TERMINATING(257),

  /// < The application is low on memory, free memory if possible.
  /// Called on iOS in applicationDidReceiveMemoryWarning()
  /// Called on Android in onLowMemory()
  SDL_APP_LOWMEMORY(258),

  /// < The application is about to enter the background
  /// Called on iOS in applicationWillResignActive()
  /// Called on Android in onPause()
  SDL_APP_WILLENTERBACKGROUND(259),

  /// < The application did enter the background and may not get CPU for some time
  /// Called on iOS in applicationDidEnterBackground()
  /// Called on Android in onPause()
  SDL_APP_DIDENTERBACKGROUND(260),

  /// < The application is about to enter the foreground
  /// Called on iOS in applicationWillEnterForeground()
  /// Called on Android in onResume()
  SDL_APP_WILLENTERFOREGROUND(261),

  /// < The application is now interactive
  /// Called on iOS in applicationDidBecomeActive()
  /// Called on Android in onResume()
  SDL_APP_DIDENTERFOREGROUND(262),

  /// < The user's locale preferences have changed.
  SDL_LOCALECHANGED(263),

  /// < Display state change
  SDL_DISPLAYEVENT(336),

  /// < Window state change
  SDL_WINDOWEVENT(512),

  /// < System specific event
  SDL_SYSWMEVENT(513),

  /// < Key pressed
  SDL_KEYDOWN(768),

  /// < Key released
  SDL_KEYUP(769),

  /// < Keyboard text editing (composition)
  SDL_TEXTEDITING(770),

  /// < Keyboard text input
  SDL_TEXTINPUT(771),

  /// < Keymap changed due to a system event such as an
  /// input language or keyboard layout change.
  SDL_KEYMAPCHANGED(772),

  /// < Extended keyboard text editing (composition)
  SDL_TEXTEDITING_EXT(773),

  /// < Mouse moved
  SDL_MOUSEMOTION(1024),

  /// < Mouse button pressed
  SDL_MOUSEBUTTONDOWN(1025),

  /// < Mouse button released
  SDL_MOUSEBUTTONUP(1026),

  /// < Mouse wheel motion
  SDL_MOUSEWHEEL(1027),

  /// < Joystick axis motion
  SDL_JOYAXISMOTION(1536),

  /// < Joystick trackball motion
  SDL_JOYBALLMOTION(1537),

  /// < Joystick hat position change
  SDL_JOYHATMOTION(1538),

  /// < Joystick button pressed
  SDL_JOYBUTTONDOWN(1539),

  /// < Joystick button released
  SDL_JOYBUTTONUP(1540),

  /// < A new joystick has been inserted into the system
  SDL_JOYDEVICEADDED(1541),

  /// < An opened joystick has been removed
  SDL_JOYDEVICEREMOVED(1542),

  /// < Joystick battery level change
  SDL_JOYBATTERYUPDATED(1543),

  /// < Game controller axis motion
  SDL_CONTROLLERAXISMOTION(1616),

  /// < Game controller button pressed
  SDL_CONTROLLERBUTTONDOWN(1617),

  /// < Game controller button released
  SDL_CONTROLLERBUTTONUP(1618),

  /// < A new Game controller has been inserted into the system
  SDL_CONTROLLERDEVICEADDED(1619),

  /// < An opened Game controller has been removed
  SDL_CONTROLLERDEVICEREMOVED(1620),

  /// < The controller mapping was updated
  SDL_CONTROLLERDEVICEREMAPPED(1621),

  /// < Game controller touchpad was touched
  SDL_CONTROLLERTOUCHPADDOWN(1622),

  /// < Game controller touchpad finger was moved
  SDL_CONTROLLERTOUCHPADMOTION(1623),

  /// < Game controller touchpad finger was lifted
  SDL_CONTROLLERTOUCHPADUP(1624),

  /// < Game controller sensor was updated
  SDL_CONTROLLERSENSORUPDATE(1625),
  SDL_CONTROLLERUPDATECOMPLETE_RESERVED_FOR_SDL3(1626),

  /// < Game controller Steam handle has changed
  SDL_CONTROLLERSTEAMHANDLEUPDATED(1627),
  SDL_FINGERDOWN(1792),
  SDL_FINGERUP(1793),
  SDL_FINGERMOTION(1794),
  SDL_DOLLARGESTURE(2048),
  SDL_DOLLARRECORD(2049),
  SDL_MULTIGESTURE(2050),

  /// < The clipboard or primary selection changed
  SDL_CLIPBOARDUPDATE(2304),

  /// < The system requests a file open
  SDL_DROPFILE(4096),

  /// < text/plain drag-and-drop event
  SDL_DROPTEXT(4097),

  /// < A new set of drops is beginning (NULL filename)
  SDL_DROPBEGIN(4098),

  /// < Current set of drops is now complete (NULL filename)
  SDL_DROPCOMPLETE(4099),

  /// < A new audio device is available
  SDL_AUDIODEVICEADDED(4352),

  /// < An audio device has been removed.
  SDL_AUDIODEVICEREMOVED(4353),

  /// < A sensor was updated
  SDL_SENSORUPDATE(4608),

  /// < The render targets have been reset and their contents need to be updated
  SDL_RENDER_TARGETS_RESET(8192),

  /// < The device has been reset and all textures need to be recreated
  SDL_RENDER_DEVICE_RESET(8193),

  /// < Signals the end of an event poll cycle
  SDL_POLLSENTINEL(32512),

  /// Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,
  /// and should be allocated with SDL_RegisterEvents()
  SDL_USEREVENT(32768),

  /// This last event is only for bounding internal arrays
  SDL_LASTEVENT(65535);

  final int value;
  const SDL_EventType(this.value);

  static SDL_EventType fromValue(int value) => switch (value) {
        0 => SDL_FIRSTEVENT,
        256 => SDL_QUIT,
        257 => SDL_APP_TERMINATING,
        258 => SDL_APP_LOWMEMORY,
        259 => SDL_APP_WILLENTERBACKGROUND,
        260 => SDL_APP_DIDENTERBACKGROUND,
        261 => SDL_APP_WILLENTERFOREGROUND,
        262 => SDL_APP_DIDENTERFOREGROUND,
        263 => SDL_LOCALECHANGED,
        336 => SDL_DISPLAYEVENT,
        512 => SDL_WINDOWEVENT,
        513 => SDL_SYSWMEVENT,
        768 => SDL_KEYDOWN,
        769 => SDL_KEYUP,
        770 => SDL_TEXTEDITING,
        771 => SDL_TEXTINPUT,
        772 => SDL_KEYMAPCHANGED,
        773 => SDL_TEXTEDITING_EXT,
        1024 => SDL_MOUSEMOTION,
        1025 => SDL_MOUSEBUTTONDOWN,
        1026 => SDL_MOUSEBUTTONUP,
        1027 => SDL_MOUSEWHEEL,
        1536 => SDL_JOYAXISMOTION,
        1537 => SDL_JOYBALLMOTION,
        1538 => SDL_JOYHATMOTION,
        1539 => SDL_JOYBUTTONDOWN,
        1540 => SDL_JOYBUTTONUP,
        1541 => SDL_JOYDEVICEADDED,
        1542 => SDL_JOYDEVICEREMOVED,
        1543 => SDL_JOYBATTERYUPDATED,
        1616 => SDL_CONTROLLERAXISMOTION,
        1617 => SDL_CONTROLLERBUTTONDOWN,
        1618 => SDL_CONTROLLERBUTTONUP,
        1619 => SDL_CONTROLLERDEVICEADDED,
        1620 => SDL_CONTROLLERDEVICEREMOVED,
        1621 => SDL_CONTROLLERDEVICEREMAPPED,
        1622 => SDL_CONTROLLERTOUCHPADDOWN,
        1623 => SDL_CONTROLLERTOUCHPADMOTION,
        1624 => SDL_CONTROLLERTOUCHPADUP,
        1625 => SDL_CONTROLLERSENSORUPDATE,
        1626 => SDL_CONTROLLERUPDATECOMPLETE_RESERVED_FOR_SDL3,
        1627 => SDL_CONTROLLERSTEAMHANDLEUPDATED,
        1792 => SDL_FINGERDOWN,
        1793 => SDL_FINGERUP,
        1794 => SDL_FINGERMOTION,
        2048 => SDL_DOLLARGESTURE,
        2049 => SDL_DOLLARRECORD,
        2050 => SDL_MULTIGESTURE,
        2304 => SDL_CLIPBOARDUPDATE,
        4096 => SDL_DROPFILE,
        4097 => SDL_DROPTEXT,
        4098 => SDL_DROPBEGIN,
        4099 => SDL_DROPCOMPLETE,
        4352 => SDL_AUDIODEVICEADDED,
        4353 => SDL_AUDIODEVICEREMOVED,
        4608 => SDL_SENSORUPDATE,
        8192 => SDL_RENDER_TARGETS_RESET,
        8193 => SDL_RENDER_DEVICE_RESET,
        32512 => SDL_POLLSENTINEL,
        32768 => SDL_USEREVENT,
        65535 => SDL_LASTEVENT,
        _ => throw ArgumentError("Unknown value for SDL_EventType: $value"),
      };
}

/// \brief Fields shared by every event
final class SDL_CommonEvent extends ffi.Struct {
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;
}

typedef Sint32 = ffi.Int32;
typedef DartSint32 = int;

/// \brief Display state change event data (event.display.*)
final class SDL_DisplayEvent extends ffi.Struct {
  /// < ::SDL_DISPLAYEVENT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The associated display index
  @Uint32()
  external int display;

  /// < ::SDL_DisplayEventID
  @Uint8()
  external int event;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < event dependent data
  @Sint32()
  external int data1;
}

/// \brief Window state change event data (event.window.*)
final class SDL_WindowEvent extends ffi.Struct {
  /// < ::SDL_WINDOWEVENT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The associated window
  @Uint32()
  external int windowID;

  /// < ::SDL_WindowEventID
  @Uint8()
  external int event;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < event dependent data
  @Sint32()
  external int data1;

  /// < event dependent data
  @Sint32()
  external int data2;
}

/// \brief The SDL keyboard scancode representation.
///
/// Values of this type are used to represent keyboard keys, among other places
/// in the \link SDL_Keysym::scancode key.keysym.scancode \endlink field of the
/// SDL_Event structure.
///
/// The values in this enumeration are based on the USB usage page standard:
/// https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf
enum SDL_Scancode {
  SDL_SCANCODE_UNKNOWN(0),
  SDL_SCANCODE_A(4),
  SDL_SCANCODE_B(5),
  SDL_SCANCODE_C(6),
  SDL_SCANCODE_D(7),
  SDL_SCANCODE_E(8),
  SDL_SCANCODE_F(9),
  SDL_SCANCODE_G(10),
  SDL_SCANCODE_H(11),
  SDL_SCANCODE_I(12),
  SDL_SCANCODE_J(13),
  SDL_SCANCODE_K(14),
  SDL_SCANCODE_L(15),
  SDL_SCANCODE_M(16),
  SDL_SCANCODE_N(17),
  SDL_SCANCODE_O(18),
  SDL_SCANCODE_P(19),
  SDL_SCANCODE_Q(20),
  SDL_SCANCODE_R(21),
  SDL_SCANCODE_S(22),
  SDL_SCANCODE_T(23),
  SDL_SCANCODE_U(24),
  SDL_SCANCODE_V(25),
  SDL_SCANCODE_W(26),
  SDL_SCANCODE_X(27),
  SDL_SCANCODE_Y(28),
  SDL_SCANCODE_Z(29),
  SDL_SCANCODE_1(30),
  SDL_SCANCODE_2(31),
  SDL_SCANCODE_3(32),
  SDL_SCANCODE_4(33),
  SDL_SCANCODE_5(34),
  SDL_SCANCODE_6(35),
  SDL_SCANCODE_7(36),
  SDL_SCANCODE_8(37),
  SDL_SCANCODE_9(38),
  SDL_SCANCODE_0(39),
  SDL_SCANCODE_RETURN(40),
  SDL_SCANCODE_ESCAPE(41),
  SDL_SCANCODE_BACKSPACE(42),
  SDL_SCANCODE_TAB(43),
  SDL_SCANCODE_SPACE(44),
  SDL_SCANCODE_MINUS(45),
  SDL_SCANCODE_EQUALS(46),
  SDL_SCANCODE_LEFTBRACKET(47),
  SDL_SCANCODE_RIGHTBRACKET(48),

  /// < Located at the lower left of the return
  /// key on ISO keyboards and at the right end
  /// of the QWERTY row on ANSI keyboards.
  /// Produces REVERSE SOLIDUS (backslash) and
  /// VERTICAL LINE in a US layout, REVERSE
  /// SOLIDUS and VERTICAL LINE in a UK Mac
  /// layout, NUMBER SIGN and TILDE in a UK
  /// Windows layout, DOLLAR SIGN and POUND SIGN
  /// in a Swiss German layout, NUMBER SIGN and
  /// APOSTROPHE in a German layout, GRAVE
  /// ACCENT and POUND SIGN in a French Mac
  /// layout, and ASTERISK and MICRO SIGN in a
  /// French Windows layout.
  SDL_SCANCODE_BACKSLASH(49),

  /// < ISO USB keyboards actually use this code
  /// instead of 49 for the same key, but all
  /// OSes I've seen treat the two codes
  /// identically. So, as an implementor, unless
  /// your keyboard generates both of those
  /// codes and your OS treats them differently,
  /// you should generate SDL_SCANCODE_BACKSLASH
  /// instead of this code. As a user, you
  /// should not rely on this code because SDL
  /// will never generate it with most (all?)
  /// keyboards.
  SDL_SCANCODE_NONUSHASH(50),
  SDL_SCANCODE_SEMICOLON(51),
  SDL_SCANCODE_APOSTROPHE(52),

  /// < Located in the top left corner (on both ANSI
  /// and ISO keyboards). Produces GRAVE ACCENT and
  /// TILDE in a US Windows layout and in US and UK
  /// Mac layouts on ANSI keyboards, GRAVE ACCENT
  /// and NOT SIGN in a UK Windows layout, SECTION
  /// SIGN and PLUS-MINUS SIGN in US and UK Mac
  /// layouts on ISO keyboards, SECTION SIGN and
  /// DEGREE SIGN in a Swiss German layout (Mac:
  /// only on ISO keyboards), CIRCUMFLEX ACCENT and
  /// DEGREE SIGN in a German layout (Mac: only on
  /// ISO keyboards), SUPERSCRIPT TWO and TILDE in a
  /// French Windows layout, COMMERCIAL AT and
  /// NUMBER SIGN in a French Mac layout on ISO
  /// keyboards, and LESS-THAN SIGN and GREATER-THAN
  /// SIGN in a Swiss German, German, or French Mac
  /// layout on ANSI keyboards.
  SDL_SCANCODE_GRAVE(53),
  SDL_SCANCODE_COMMA(54),
  SDL_SCANCODE_PERIOD(55),
  SDL_SCANCODE_SLASH(56),
  SDL_SCANCODE_CAPSLOCK(57),
  SDL_SCANCODE_F1(58),
  SDL_SCANCODE_F2(59),
  SDL_SCANCODE_F3(60),
  SDL_SCANCODE_F4(61),
  SDL_SCANCODE_F5(62),
  SDL_SCANCODE_F6(63),
  SDL_SCANCODE_F7(64),
  SDL_SCANCODE_F8(65),
  SDL_SCANCODE_F9(66),
  SDL_SCANCODE_F10(67),
  SDL_SCANCODE_F11(68),
  SDL_SCANCODE_F12(69),
  SDL_SCANCODE_PRINTSCREEN(70),
  SDL_SCANCODE_SCROLLLOCK(71),
  SDL_SCANCODE_PAUSE(72),

  /// < insert on PC, help on some Mac keyboards (but
  /// does send code 73, not 117)
  SDL_SCANCODE_INSERT(73),
  SDL_SCANCODE_HOME(74),
  SDL_SCANCODE_PAGEUP(75),
  SDL_SCANCODE_DELETE(76),
  SDL_SCANCODE_END(77),
  SDL_SCANCODE_PAGEDOWN(78),
  SDL_SCANCODE_RIGHT(79),
  SDL_SCANCODE_LEFT(80),
  SDL_SCANCODE_DOWN(81),
  SDL_SCANCODE_UP(82),

  /// < num lock on PC, clear on Mac keyboards
  SDL_SCANCODE_NUMLOCKCLEAR(83),
  SDL_SCANCODE_KP_DIVIDE(84),
  SDL_SCANCODE_KP_MULTIPLY(85),
  SDL_SCANCODE_KP_MINUS(86),
  SDL_SCANCODE_KP_PLUS(87),
  SDL_SCANCODE_KP_ENTER(88),
  SDL_SCANCODE_KP_1(89),
  SDL_SCANCODE_KP_2(90),
  SDL_SCANCODE_KP_3(91),
  SDL_SCANCODE_KP_4(92),
  SDL_SCANCODE_KP_5(93),
  SDL_SCANCODE_KP_6(94),
  SDL_SCANCODE_KP_7(95),
  SDL_SCANCODE_KP_8(96),
  SDL_SCANCODE_KP_9(97),
  SDL_SCANCODE_KP_0(98),
  SDL_SCANCODE_KP_PERIOD(99),

  /// < This is the additional key that ISO
  /// keyboards have over ANSI ones,
  /// located between left shift and Y.
  /// Produces GRAVE ACCENT and TILDE in a
  /// US or UK Mac layout, REVERSE SOLIDUS
  /// (backslash) and VERTICAL LINE in a
  /// US or UK Windows layout, and
  /// LESS-THAN SIGN and GREATER-THAN SIGN
  /// in a Swiss German, German, or French
  /// layout.
  SDL_SCANCODE_NONUSBACKSLASH(100),

  /// < windows contextual menu, compose
  SDL_SCANCODE_APPLICATION(101),

  /// < The USB document says this is a status flag,
  /// not a physical key - but some Mac keyboards
  /// do have a power key.
  SDL_SCANCODE_POWER(102),
  SDL_SCANCODE_KP_EQUALS(103),
  SDL_SCANCODE_F13(104),
  SDL_SCANCODE_F14(105),
  SDL_SCANCODE_F15(106),
  SDL_SCANCODE_F16(107),
  SDL_SCANCODE_F17(108),
  SDL_SCANCODE_F18(109),
  SDL_SCANCODE_F19(110),
  SDL_SCANCODE_F20(111),
  SDL_SCANCODE_F21(112),
  SDL_SCANCODE_F22(113),
  SDL_SCANCODE_F23(114),
  SDL_SCANCODE_F24(115),
  SDL_SCANCODE_EXECUTE(116),

  /// < AL Integrated Help Center
  SDL_SCANCODE_HELP(117),

  /// < Menu (show menu)
  SDL_SCANCODE_MENU(118),
  SDL_SCANCODE_SELECT(119),

  /// < AC Stop
  SDL_SCANCODE_STOP(120),

  /// < AC Redo/Repeat
  SDL_SCANCODE_AGAIN(121),

  /// < AC Undo
  SDL_SCANCODE_UNDO(122),

  /// < AC Cut
  SDL_SCANCODE_CUT(123),

  /// < AC Copy
  SDL_SCANCODE_COPY(124),

  /// < AC Paste
  SDL_SCANCODE_PASTE(125),

  /// < AC Find
  SDL_SCANCODE_FIND(126),
  SDL_SCANCODE_MUTE(127),
  SDL_SCANCODE_VOLUMEUP(128),
  SDL_SCANCODE_VOLUMEDOWN(129),
  SDL_SCANCODE_KP_COMMA(133),
  SDL_SCANCODE_KP_EQUALSAS400(134),

  /// < used on Asian keyboards, see
  /// footnotes in USB doc
  SDL_SCANCODE_INTERNATIONAL1(135),
  SDL_SCANCODE_INTERNATIONAL2(136),

  /// < Yen
  SDL_SCANCODE_INTERNATIONAL3(137),
  SDL_SCANCODE_INTERNATIONAL4(138),
  SDL_SCANCODE_INTERNATIONAL5(139),
  SDL_SCANCODE_INTERNATIONAL6(140),
  SDL_SCANCODE_INTERNATIONAL7(141),
  SDL_SCANCODE_INTERNATIONAL8(142),
  SDL_SCANCODE_INTERNATIONAL9(143),

  /// < Hangul/English toggle
  SDL_SCANCODE_LANG1(144),

  /// < Hanja conversion
  SDL_SCANCODE_LANG2(145),

  /// < Katakana
  SDL_SCANCODE_LANG3(146),

  /// < Hiragana
  SDL_SCANCODE_LANG4(147),

  /// < Zenkaku/Hankaku
  SDL_SCANCODE_LANG5(148),

  /// < reserved
  SDL_SCANCODE_LANG6(149),

  /// < reserved
  SDL_SCANCODE_LANG7(150),

  /// < reserved
  SDL_SCANCODE_LANG8(151),

  /// < reserved
  SDL_SCANCODE_LANG9(152),

  /// < Erase-Eaze
  SDL_SCANCODE_ALTERASE(153),
  SDL_SCANCODE_SYSREQ(154),

  /// < AC Cancel
  SDL_SCANCODE_CANCEL(155),
  SDL_SCANCODE_CLEAR(156),
  SDL_SCANCODE_PRIOR(157),
  SDL_SCANCODE_RETURN2(158),
  SDL_SCANCODE_SEPARATOR(159),
  SDL_SCANCODE_OUT(160),
  SDL_SCANCODE_OPER(161),
  SDL_SCANCODE_CLEARAGAIN(162),
  SDL_SCANCODE_CRSEL(163),
  SDL_SCANCODE_EXSEL(164),
  SDL_SCANCODE_KP_00(176),
  SDL_SCANCODE_KP_000(177),
  SDL_SCANCODE_THOUSANDSSEPARATOR(178),
  SDL_SCANCODE_DECIMALSEPARATOR(179),
  SDL_SCANCODE_CURRENCYUNIT(180),
  SDL_SCANCODE_CURRENCYSUBUNIT(181),
  SDL_SCANCODE_KP_LEFTPAREN(182),
  SDL_SCANCODE_KP_RIGHTPAREN(183),
  SDL_SCANCODE_KP_LEFTBRACE(184),
  SDL_SCANCODE_KP_RIGHTBRACE(185),
  SDL_SCANCODE_KP_TAB(186),
  SDL_SCANCODE_KP_BACKSPACE(187),
  SDL_SCANCODE_KP_A(188),
  SDL_SCANCODE_KP_B(189),
  SDL_SCANCODE_KP_C(190),
  SDL_SCANCODE_KP_D(191),
  SDL_SCANCODE_KP_E(192),
  SDL_SCANCODE_KP_F(193),
  SDL_SCANCODE_KP_XOR(194),
  SDL_SCANCODE_KP_POWER(195),
  SDL_SCANCODE_KP_PERCENT(196),
  SDL_SCANCODE_KP_LESS(197),
  SDL_SCANCODE_KP_GREATER(198),
  SDL_SCANCODE_KP_AMPERSAND(199),
  SDL_SCANCODE_KP_DBLAMPERSAND(200),
  SDL_SCANCODE_KP_VERTICALBAR(201),
  SDL_SCANCODE_KP_DBLVERTICALBAR(202),
  SDL_SCANCODE_KP_COLON(203),
  SDL_SCANCODE_KP_HASH(204),
  SDL_SCANCODE_KP_SPACE(205),
  SDL_SCANCODE_KP_AT(206),
  SDL_SCANCODE_KP_EXCLAM(207),
  SDL_SCANCODE_KP_MEMSTORE(208),
  SDL_SCANCODE_KP_MEMRECALL(209),
  SDL_SCANCODE_KP_MEMCLEAR(210),
  SDL_SCANCODE_KP_MEMADD(211),
  SDL_SCANCODE_KP_MEMSUBTRACT(212),
  SDL_SCANCODE_KP_MEMMULTIPLY(213),
  SDL_SCANCODE_KP_MEMDIVIDE(214),
  SDL_SCANCODE_KP_PLUSMINUS(215),
  SDL_SCANCODE_KP_CLEAR(216),
  SDL_SCANCODE_KP_CLEARENTRY(217),
  SDL_SCANCODE_KP_BINARY(218),
  SDL_SCANCODE_KP_OCTAL(219),
  SDL_SCANCODE_KP_DECIMAL(220),
  SDL_SCANCODE_KP_HEXADECIMAL(221),
  SDL_SCANCODE_LCTRL(224),
  SDL_SCANCODE_LSHIFT(225),

  /// < alt, option
  SDL_SCANCODE_LALT(226),

  /// < windows, command (apple), meta
  SDL_SCANCODE_LGUI(227),
  SDL_SCANCODE_RCTRL(228),
  SDL_SCANCODE_RSHIFT(229),

  /// < alt gr, option
  SDL_SCANCODE_RALT(230),

  /// < windows, command (apple), meta
  SDL_SCANCODE_RGUI(231),

  /// < I'm not sure if this is really not covered
  /// by any of the above, but since there's a
  /// special KMOD_MODE for it I'm adding it here
  SDL_SCANCODE_MODE(257),
  SDL_SCANCODE_AUDIONEXT(258),
  SDL_SCANCODE_AUDIOPREV(259),
  SDL_SCANCODE_AUDIOSTOP(260),
  SDL_SCANCODE_AUDIOPLAY(261),
  SDL_SCANCODE_AUDIOMUTE(262),
  SDL_SCANCODE_MEDIASELECT(263),

  /// < AL Internet Browser
  SDL_SCANCODE_WWW(264),
  SDL_SCANCODE_MAIL(265),

  /// < AL Calculator
  SDL_SCANCODE_CALCULATOR(266),
  SDL_SCANCODE_COMPUTER(267),

  /// < AC Search
  SDL_SCANCODE_AC_SEARCH(268),

  /// < AC Home
  SDL_SCANCODE_AC_HOME(269),

  /// < AC Back
  SDL_SCANCODE_AC_BACK(270),

  /// < AC Forward
  SDL_SCANCODE_AC_FORWARD(271),

  /// < AC Stop
  SDL_SCANCODE_AC_STOP(272),

  /// < AC Refresh
  SDL_SCANCODE_AC_REFRESH(273),

  /// < AC Bookmarks
  SDL_SCANCODE_AC_BOOKMARKS(274),
  SDL_SCANCODE_BRIGHTNESSDOWN(275),
  SDL_SCANCODE_BRIGHTNESSUP(276),

  /// < display mirroring/dual display
  /// switch, video mode switch
  SDL_SCANCODE_DISPLAYSWITCH(277),
  SDL_SCANCODE_KBDILLUMTOGGLE(278),
  SDL_SCANCODE_KBDILLUMDOWN(279),
  SDL_SCANCODE_KBDILLUMUP(280),
  SDL_SCANCODE_EJECT(281),

  /// < SC System Sleep
  SDL_SCANCODE_SLEEP(282),
  SDL_SCANCODE_APP1(283),
  SDL_SCANCODE_APP2(284),
  SDL_SCANCODE_AUDIOREWIND(285),
  SDL_SCANCODE_AUDIOFASTFORWARD(286),

  /// < Usually situated below the display on phones and
  /// used as a multi-function feature key for selecting
  /// a software defined function shown on the bottom left
  /// of the display.
  SDL_SCANCODE_SOFTLEFT(287),

  /// < Usually situated below the display on phones and
  /// used as a multi-function feature key for selecting
  /// a software defined function shown on the bottom right
  /// of the display.
  SDL_SCANCODE_SOFTRIGHT(288),

  /// < Used for accepting phone calls.
  SDL_SCANCODE_CALL(289),

  /// < Used for rejecting phone calls.
  SDL_SCANCODE_ENDCALL(290),

  /// < not a key, just marks the number of scancodes
  /// for array bounds
  SDL_NUM_SCANCODES(512);

  final int value;
  const SDL_Scancode(this.value);

  static SDL_Scancode fromValue(int value) => switch (value) {
        0 => SDL_SCANCODE_UNKNOWN,
        4 => SDL_SCANCODE_A,
        5 => SDL_SCANCODE_B,
        6 => SDL_SCANCODE_C,
        7 => SDL_SCANCODE_D,
        8 => SDL_SCANCODE_E,
        9 => SDL_SCANCODE_F,
        10 => SDL_SCANCODE_G,
        11 => SDL_SCANCODE_H,
        12 => SDL_SCANCODE_I,
        13 => SDL_SCANCODE_J,
        14 => SDL_SCANCODE_K,
        15 => SDL_SCANCODE_L,
        16 => SDL_SCANCODE_M,
        17 => SDL_SCANCODE_N,
        18 => SDL_SCANCODE_O,
        19 => SDL_SCANCODE_P,
        20 => SDL_SCANCODE_Q,
        21 => SDL_SCANCODE_R,
        22 => SDL_SCANCODE_S,
        23 => SDL_SCANCODE_T,
        24 => SDL_SCANCODE_U,
        25 => SDL_SCANCODE_V,
        26 => SDL_SCANCODE_W,
        27 => SDL_SCANCODE_X,
        28 => SDL_SCANCODE_Y,
        29 => SDL_SCANCODE_Z,
        30 => SDL_SCANCODE_1,
        31 => SDL_SCANCODE_2,
        32 => SDL_SCANCODE_3,
        33 => SDL_SCANCODE_4,
        34 => SDL_SCANCODE_5,
        35 => SDL_SCANCODE_6,
        36 => SDL_SCANCODE_7,
        37 => SDL_SCANCODE_8,
        38 => SDL_SCANCODE_9,
        39 => SDL_SCANCODE_0,
        40 => SDL_SCANCODE_RETURN,
        41 => SDL_SCANCODE_ESCAPE,
        42 => SDL_SCANCODE_BACKSPACE,
        43 => SDL_SCANCODE_TAB,
        44 => SDL_SCANCODE_SPACE,
        45 => SDL_SCANCODE_MINUS,
        46 => SDL_SCANCODE_EQUALS,
        47 => SDL_SCANCODE_LEFTBRACKET,
        48 => SDL_SCANCODE_RIGHTBRACKET,
        49 => SDL_SCANCODE_BACKSLASH,
        50 => SDL_SCANCODE_NONUSHASH,
        51 => SDL_SCANCODE_SEMICOLON,
        52 => SDL_SCANCODE_APOSTROPHE,
        53 => SDL_SCANCODE_GRAVE,
        54 => SDL_SCANCODE_COMMA,
        55 => SDL_SCANCODE_PERIOD,
        56 => SDL_SCANCODE_SLASH,
        57 => SDL_SCANCODE_CAPSLOCK,
        58 => SDL_SCANCODE_F1,
        59 => SDL_SCANCODE_F2,
        60 => SDL_SCANCODE_F3,
        61 => SDL_SCANCODE_F4,
        62 => SDL_SCANCODE_F5,
        63 => SDL_SCANCODE_F6,
        64 => SDL_SCANCODE_F7,
        65 => SDL_SCANCODE_F8,
        66 => SDL_SCANCODE_F9,
        67 => SDL_SCANCODE_F10,
        68 => SDL_SCANCODE_F11,
        69 => SDL_SCANCODE_F12,
        70 => SDL_SCANCODE_PRINTSCREEN,
        71 => SDL_SCANCODE_SCROLLLOCK,
        72 => SDL_SCANCODE_PAUSE,
        73 => SDL_SCANCODE_INSERT,
        74 => SDL_SCANCODE_HOME,
        75 => SDL_SCANCODE_PAGEUP,
        76 => SDL_SCANCODE_DELETE,
        77 => SDL_SCANCODE_END,
        78 => SDL_SCANCODE_PAGEDOWN,
        79 => SDL_SCANCODE_RIGHT,
        80 => SDL_SCANCODE_LEFT,
        81 => SDL_SCANCODE_DOWN,
        82 => SDL_SCANCODE_UP,
        83 => SDL_SCANCODE_NUMLOCKCLEAR,
        84 => SDL_SCANCODE_KP_DIVIDE,
        85 => SDL_SCANCODE_KP_MULTIPLY,
        86 => SDL_SCANCODE_KP_MINUS,
        87 => SDL_SCANCODE_KP_PLUS,
        88 => SDL_SCANCODE_KP_ENTER,
        89 => SDL_SCANCODE_KP_1,
        90 => SDL_SCANCODE_KP_2,
        91 => SDL_SCANCODE_KP_3,
        92 => SDL_SCANCODE_KP_4,
        93 => SDL_SCANCODE_KP_5,
        94 => SDL_SCANCODE_KP_6,
        95 => SDL_SCANCODE_KP_7,
        96 => SDL_SCANCODE_KP_8,
        97 => SDL_SCANCODE_KP_9,
        98 => SDL_SCANCODE_KP_0,
        99 => SDL_SCANCODE_KP_PERIOD,
        100 => SDL_SCANCODE_NONUSBACKSLASH,
        101 => SDL_SCANCODE_APPLICATION,
        102 => SDL_SCANCODE_POWER,
        103 => SDL_SCANCODE_KP_EQUALS,
        104 => SDL_SCANCODE_F13,
        105 => SDL_SCANCODE_F14,
        106 => SDL_SCANCODE_F15,
        107 => SDL_SCANCODE_F16,
        108 => SDL_SCANCODE_F17,
        109 => SDL_SCANCODE_F18,
        110 => SDL_SCANCODE_F19,
        111 => SDL_SCANCODE_F20,
        112 => SDL_SCANCODE_F21,
        113 => SDL_SCANCODE_F22,
        114 => SDL_SCANCODE_F23,
        115 => SDL_SCANCODE_F24,
        116 => SDL_SCANCODE_EXECUTE,
        117 => SDL_SCANCODE_HELP,
        118 => SDL_SCANCODE_MENU,
        119 => SDL_SCANCODE_SELECT,
        120 => SDL_SCANCODE_STOP,
        121 => SDL_SCANCODE_AGAIN,
        122 => SDL_SCANCODE_UNDO,
        123 => SDL_SCANCODE_CUT,
        124 => SDL_SCANCODE_COPY,
        125 => SDL_SCANCODE_PASTE,
        126 => SDL_SCANCODE_FIND,
        127 => SDL_SCANCODE_MUTE,
        128 => SDL_SCANCODE_VOLUMEUP,
        129 => SDL_SCANCODE_VOLUMEDOWN,
        133 => SDL_SCANCODE_KP_COMMA,
        134 => SDL_SCANCODE_KP_EQUALSAS400,
        135 => SDL_SCANCODE_INTERNATIONAL1,
        136 => SDL_SCANCODE_INTERNATIONAL2,
        137 => SDL_SCANCODE_INTERNATIONAL3,
        138 => SDL_SCANCODE_INTERNATIONAL4,
        139 => SDL_SCANCODE_INTERNATIONAL5,
        140 => SDL_SCANCODE_INTERNATIONAL6,
        141 => SDL_SCANCODE_INTERNATIONAL7,
        142 => SDL_SCANCODE_INTERNATIONAL8,
        143 => SDL_SCANCODE_INTERNATIONAL9,
        144 => SDL_SCANCODE_LANG1,
        145 => SDL_SCANCODE_LANG2,
        146 => SDL_SCANCODE_LANG3,
        147 => SDL_SCANCODE_LANG4,
        148 => SDL_SCANCODE_LANG5,
        149 => SDL_SCANCODE_LANG6,
        150 => SDL_SCANCODE_LANG7,
        151 => SDL_SCANCODE_LANG8,
        152 => SDL_SCANCODE_LANG9,
        153 => SDL_SCANCODE_ALTERASE,
        154 => SDL_SCANCODE_SYSREQ,
        155 => SDL_SCANCODE_CANCEL,
        156 => SDL_SCANCODE_CLEAR,
        157 => SDL_SCANCODE_PRIOR,
        158 => SDL_SCANCODE_RETURN2,
        159 => SDL_SCANCODE_SEPARATOR,
        160 => SDL_SCANCODE_OUT,
        161 => SDL_SCANCODE_OPER,
        162 => SDL_SCANCODE_CLEARAGAIN,
        163 => SDL_SCANCODE_CRSEL,
        164 => SDL_SCANCODE_EXSEL,
        176 => SDL_SCANCODE_KP_00,
        177 => SDL_SCANCODE_KP_000,
        178 => SDL_SCANCODE_THOUSANDSSEPARATOR,
        179 => SDL_SCANCODE_DECIMALSEPARATOR,
        180 => SDL_SCANCODE_CURRENCYUNIT,
        181 => SDL_SCANCODE_CURRENCYSUBUNIT,
        182 => SDL_SCANCODE_KP_LEFTPAREN,
        183 => SDL_SCANCODE_KP_RIGHTPAREN,
        184 => SDL_SCANCODE_KP_LEFTBRACE,
        185 => SDL_SCANCODE_KP_RIGHTBRACE,
        186 => SDL_SCANCODE_KP_TAB,
        187 => SDL_SCANCODE_KP_BACKSPACE,
        188 => SDL_SCANCODE_KP_A,
        189 => SDL_SCANCODE_KP_B,
        190 => SDL_SCANCODE_KP_C,
        191 => SDL_SCANCODE_KP_D,
        192 => SDL_SCANCODE_KP_E,
        193 => SDL_SCANCODE_KP_F,
        194 => SDL_SCANCODE_KP_XOR,
        195 => SDL_SCANCODE_KP_POWER,
        196 => SDL_SCANCODE_KP_PERCENT,
        197 => SDL_SCANCODE_KP_LESS,
        198 => SDL_SCANCODE_KP_GREATER,
        199 => SDL_SCANCODE_KP_AMPERSAND,
        200 => SDL_SCANCODE_KP_DBLAMPERSAND,
        201 => SDL_SCANCODE_KP_VERTICALBAR,
        202 => SDL_SCANCODE_KP_DBLVERTICALBAR,
        203 => SDL_SCANCODE_KP_COLON,
        204 => SDL_SCANCODE_KP_HASH,
        205 => SDL_SCANCODE_KP_SPACE,
        206 => SDL_SCANCODE_KP_AT,
        207 => SDL_SCANCODE_KP_EXCLAM,
        208 => SDL_SCANCODE_KP_MEMSTORE,
        209 => SDL_SCANCODE_KP_MEMRECALL,
        210 => SDL_SCANCODE_KP_MEMCLEAR,
        211 => SDL_SCANCODE_KP_MEMADD,
        212 => SDL_SCANCODE_KP_MEMSUBTRACT,
        213 => SDL_SCANCODE_KP_MEMMULTIPLY,
        214 => SDL_SCANCODE_KP_MEMDIVIDE,
        215 => SDL_SCANCODE_KP_PLUSMINUS,
        216 => SDL_SCANCODE_KP_CLEAR,
        217 => SDL_SCANCODE_KP_CLEARENTRY,
        218 => SDL_SCANCODE_KP_BINARY,
        219 => SDL_SCANCODE_KP_OCTAL,
        220 => SDL_SCANCODE_KP_DECIMAL,
        221 => SDL_SCANCODE_KP_HEXADECIMAL,
        224 => SDL_SCANCODE_LCTRL,
        225 => SDL_SCANCODE_LSHIFT,
        226 => SDL_SCANCODE_LALT,
        227 => SDL_SCANCODE_LGUI,
        228 => SDL_SCANCODE_RCTRL,
        229 => SDL_SCANCODE_RSHIFT,
        230 => SDL_SCANCODE_RALT,
        231 => SDL_SCANCODE_RGUI,
        257 => SDL_SCANCODE_MODE,
        258 => SDL_SCANCODE_AUDIONEXT,
        259 => SDL_SCANCODE_AUDIOPREV,
        260 => SDL_SCANCODE_AUDIOSTOP,
        261 => SDL_SCANCODE_AUDIOPLAY,
        262 => SDL_SCANCODE_AUDIOMUTE,
        263 => SDL_SCANCODE_MEDIASELECT,
        264 => SDL_SCANCODE_WWW,
        265 => SDL_SCANCODE_MAIL,
        266 => SDL_SCANCODE_CALCULATOR,
        267 => SDL_SCANCODE_COMPUTER,
        268 => SDL_SCANCODE_AC_SEARCH,
        269 => SDL_SCANCODE_AC_HOME,
        270 => SDL_SCANCODE_AC_BACK,
        271 => SDL_SCANCODE_AC_FORWARD,
        272 => SDL_SCANCODE_AC_STOP,
        273 => SDL_SCANCODE_AC_REFRESH,
        274 => SDL_SCANCODE_AC_BOOKMARKS,
        275 => SDL_SCANCODE_BRIGHTNESSDOWN,
        276 => SDL_SCANCODE_BRIGHTNESSUP,
        277 => SDL_SCANCODE_DISPLAYSWITCH,
        278 => SDL_SCANCODE_KBDILLUMTOGGLE,
        279 => SDL_SCANCODE_KBDILLUMDOWN,
        280 => SDL_SCANCODE_KBDILLUMUP,
        281 => SDL_SCANCODE_EJECT,
        282 => SDL_SCANCODE_SLEEP,
        283 => SDL_SCANCODE_APP1,
        284 => SDL_SCANCODE_APP2,
        285 => SDL_SCANCODE_AUDIOREWIND,
        286 => SDL_SCANCODE_AUDIOFASTFORWARD,
        287 => SDL_SCANCODE_SOFTLEFT,
        288 => SDL_SCANCODE_SOFTRIGHT,
        289 => SDL_SCANCODE_CALL,
        290 => SDL_SCANCODE_ENDCALL,
        512 => SDL_NUM_SCANCODES,
        _ => throw ArgumentError("Unknown value for SDL_Scancode: $value"),
      };
}

/// \brief The SDL virtual key representation.
///
/// Values of this type are used to represent keyboard keys using the current
/// layout of the keyboard.  These values include Unicode values representing
/// the unmodified character that would be generated by pressing the key, or
/// an SDLK_* constant for those keys that do not generate characters.
///
/// A special exception is the number keys at the top of the keyboard which
/// map to SDLK_0...SDLK_9 on AZERTY layouts.
typedef SDL_Keycode = Sint32;

/// \brief The SDL keysym structure, used in key events.
///
/// \note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event.
final class SDL_Keysym extends ffi.Struct {
  /// < SDL physical key code - see ::SDL_Scancode for details
  @ffi.UnsignedInt()
  external int scancodeAsInt;

  SDL_Scancode get scancode => SDL_Scancode.fromValue(scancodeAsInt);

  /// < SDL virtual key code - see ::SDL_Keycode for details
  @SDL_Keycode()
  external int sym;

  /// < current key modifiers
  @Uint16()
  external int mod;

  @Uint32()
  external int unused;
}

/// \brief Keyboard button event structure (event.key.*)
final class SDL_KeyboardEvent extends ffi.Struct {
  /// < ::SDL_KEYDOWN or ::SDL_KEYUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with keyboard focus, if any
  @Uint32()
  external int windowID;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @Uint8()
  external int state;

  /// < Non-zero if this is a key repeat
  @Uint8()
  external int repeat;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < The key that was pressed or released
  external SDL_Keysym keysym;
}

/// \brief Keyboard text editing event structure (event.edit.*)
final class SDL_TextEditingEvent extends ffi.Struct {
  /// < ::SDL_TEXTEDITING
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with keyboard focus, if any
  @Uint32()
  external int windowID;

  /// < The editing text
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> text;

  /// < The start cursor of selected editing text
  @Sint32()
  external int start;

  /// < The length of selected editing text
  @Sint32()
  external int length;
}

/// \brief Extended keyboard text editing event structure (event.editExt.*) when text would be
/// truncated if stored in the text buffer SDL_TextEditingEvent
final class SDL_TextEditingExtEvent extends ffi.Struct {
  /// < ::SDL_TEXTEDITING_EXT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with keyboard focus, if any
  @Uint32()
  external int windowID;

  /// < The editing text, which should be freed with SDL_free(), and will not be NULL
  external ffi.Pointer<ffi.Char> text;

  /// < The start cursor of selected editing text
  @Sint32()
  external int start;

  /// < The length of selected editing text
  @Sint32()
  external int length;
}

/// \brief Keyboard text input event structure (event.text.*)
final class SDL_TextInputEvent extends ffi.Struct {
  /// < ::SDL_TEXTINPUT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with keyboard focus, if any
  @Uint32()
  external int windowID;

  /// < The input text
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> text;
}

/// \brief Mouse motion event structure (event.motion.*)
final class SDL_MouseMotionEvent extends ffi.Struct {
  /// < ::SDL_MOUSEMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with mouse focus, if any
  @Uint32()
  external int windowID;

  /// < The mouse instance id, or SDL_TOUCH_MOUSEID
  @Uint32()
  external int which;

  /// < The current button state
  @Uint32()
  external int state;

  /// < X coordinate, relative to window
  @Sint32()
  external int x;

  /// < Y coordinate, relative to window
  @Sint32()
  external int y;

  /// < The relative motion in the X direction
  @Sint32()
  external int xrel;

  /// < The relative motion in the Y direction
  @Sint32()
  external int yrel;
}

/// \brief Mouse button event structure (event.button.*)
final class SDL_MouseButtonEvent extends ffi.Struct {
  /// < ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with mouse focus, if any
  @Uint32()
  external int windowID;

  /// < The mouse instance id, or SDL_TOUCH_MOUSEID
  @Uint32()
  external int which;

  /// < The mouse button index
  @Uint8()
  external int button;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @Uint8()
  external int state;

  /// < 1 for single-click, 2 for double-click, etc.
  @Uint8()
  external int clicks;

  @Uint8()
  external int padding1;

  /// < X coordinate, relative to window
  @Sint32()
  external int x;

  /// < Y coordinate, relative to window
  @Sint32()
  external int y;
}

/// \brief Mouse wheel event structure (event.wheel.*)
final class SDL_MouseWheelEvent extends ffi.Struct {
  /// < ::SDL_MOUSEWHEEL
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with mouse focus, if any
  @Uint32()
  external int windowID;

  /// < The mouse instance id, or SDL_TOUCH_MOUSEID
  @Uint32()
  external int which;

  /// < The amount scrolled horizontally, positive to the right and negative to the left
  @Sint32()
  external int x;

  /// < The amount scrolled vertically, positive away from the user and negative toward the user
  @Sint32()
  external int y;

  /// < Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back
  @Uint32()
  external int direction;

  /// < The amount scrolled horizontally, positive to the right and negative to the left, with float precision (added in 2.0.18)
  @ffi.Float()
  external double preciseX;

  /// < The amount scrolled vertically, positive away from the user and negative toward the user, with float precision (added in 2.0.18)
  @ffi.Float()
  external double preciseY;

  /// < X coordinate, relative to window (added in 2.26.0)
  @Sint32()
  external int mouseX;

  /// < Y coordinate, relative to window (added in 2.26.0)
  @Sint32()
  external int mouseY;
}

/// This is a unique ID for a joystick for the time it is connected to the system,
/// and is never reused for the lifetime of the application. If the joystick is
/// disconnected and reconnected, it will get a new ID.
///
/// The ID value starts at 0 and increments from there. The value -1 is an invalid ID.
typedef SDL_JoystickID = Sint32;
typedef Sint16 = ffi.Int16;
typedef DartSint16 = int;

/// \brief Joystick axis motion event structure (event.jaxis.*)
final class SDL_JoyAxisEvent extends ffi.Struct {
  /// < ::SDL_JOYAXISMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick axis index
  @Uint8()
  external int axis;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < The axis value (range: -32768 to 32767)
  @Sint16()
  external int value;

  @Uint16()
  external int padding4;
}

/// \brief Joystick trackball motion event structure (event.jball.*)
final class SDL_JoyBallEvent extends ffi.Struct {
  /// < ::SDL_JOYBALLMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick trackball index
  @Uint8()
  external int ball;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < The relative motion in the X direction
  @Sint16()
  external int xrel;

  /// < The relative motion in the Y direction
  @Sint16()
  external int yrel;
}

/// \brief Joystick hat position change event structure (event.jhat.*)
final class SDL_JoyHatEvent extends ffi.Struct {
  /// < ::SDL_JOYHATMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick hat index
  @Uint8()
  external int hat;

  /// < The hat position value.
  /// \sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP
  /// \sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT
  /// \sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN
  ///
  /// Note that zero means the POV is centered.
  @Uint8()
  external int value;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;
}

/// \brief Joystick button event structure (event.jbutton.*)
final class SDL_JoyButtonEvent extends ffi.Struct {
  /// < ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick button index
  @Uint8()
  external int button;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @Uint8()
  external int state;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;
}

/// \brief Joystick device event structure (event.jdevice.*)
final class SDL_JoyDeviceEvent extends ffi.Struct {
  /// < ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick device index for the ADDED event, instance id for the REMOVED event
  @Sint32()
  external int which;
}

enum SDL_JoystickPowerLevel {
  SDL_JOYSTICK_POWER_UNKNOWN(-1),
  SDL_JOYSTICK_POWER_EMPTY(0),
  SDL_JOYSTICK_POWER_LOW(1),
  SDL_JOYSTICK_POWER_MEDIUM(2),
  SDL_JOYSTICK_POWER_FULL(3),
  SDL_JOYSTICK_POWER_WIRED(4),
  SDL_JOYSTICK_POWER_MAX(5);

  final int value;
  const SDL_JoystickPowerLevel(this.value);

  static SDL_JoystickPowerLevel fromValue(int value) => switch (value) {
        -1 => SDL_JOYSTICK_POWER_UNKNOWN,
        0 => SDL_JOYSTICK_POWER_EMPTY,
        1 => SDL_JOYSTICK_POWER_LOW,
        2 => SDL_JOYSTICK_POWER_MEDIUM,
        3 => SDL_JOYSTICK_POWER_FULL,
        4 => SDL_JOYSTICK_POWER_WIRED,
        5 => SDL_JOYSTICK_POWER_MAX,
        _ => throw ArgumentError(
            "Unknown value for SDL_JoystickPowerLevel: $value"),
      };
}

/// \brief Joysick battery level change event structure (event.jbattery.*)
final class SDL_JoyBatteryEvent extends ffi.Struct {
  /// < ::SDL_JOYBATTERYUPDATED
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick battery level
  @ffi.Int()
  external int levelAsInt;

  SDL_JoystickPowerLevel get level =>
      SDL_JoystickPowerLevel.fromValue(levelAsInt);
}

/// \brief Game controller axis motion event structure (event.caxis.*)
final class SDL_ControllerAxisEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERAXISMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The controller axis (SDL_GameControllerAxis)
  @Uint8()
  external int axis;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < The axis value (range: -32768 to 32767)
  @Sint16()
  external int value;

  @Uint16()
  external int padding4;
}

/// \brief Game controller button event structure (event.cbutton.*)
final class SDL_ControllerButtonEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The controller button (SDL_GameControllerButton)
  @Uint8()
  external int button;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @Uint8()
  external int state;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;
}

/// \brief Controller device event structure (event.cdevice.*)
final class SDL_ControllerDeviceEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, ::SDL_CONTROLLERDEVICEREMAPPED, or ::SDL_CONTROLLERSTEAMHANDLEUPDATED
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event
  @Sint32()
  external int which;
}

/// \brief Game controller touchpad event structure (event.ctouchpad.*)
final class SDL_ControllerTouchpadEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERTOUCHPADDOWN or ::SDL_CONTROLLERTOUCHPADMOTION or ::SDL_CONTROLLERTOUCHPADUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The index of the touchpad
  @Sint32()
  external int touchpad;

  /// < The index of the finger on the touchpad
  @Sint32()
  external int finger;

  /// < Normalized in the range 0...1 with 0 being on the left
  @ffi.Float()
  external double x;

  /// < Normalized in the range 0...1 with 0 being at the top
  @ffi.Float()
  external double y;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double pressure;
}

typedef Uint64 = ffi.Uint64;
typedef DartUint64 = int;

/// \brief Game controller sensor event structure (event.csensor.*)
final class SDL_ControllerSensorEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERSENSORUPDATE
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The type of the sensor, one of the values of ::SDL_SensorType
  @Sint32()
  external int sensor;

  /// < Up to 3 values from the sensor, as defined in SDL_sensor.h
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Float> data;

  /// < The timestamp of the sensor reading in microseconds, if the hardware provides this information.
  @Uint64()
  external int timestamp_us;
}

/// \brief Audio device event structure (event.adevice.*)
final class SDL_AudioDeviceEvent extends ffi.Struct {
  /// < ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event
  @Uint32()
  external int which;

  /// < zero if an output device, non-zero if a capture device.
  @Uint8()
  external int iscapture;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;
}

typedef SDL_TouchID = Sint64;
typedef SDL_FingerID = Sint64;

/// \brief Touch finger event structure (event.tfinger.*)
final class SDL_TouchFingerEvent extends ffi.Struct {
  /// < ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The touch device id
  @SDL_TouchID()
  external int touchId;

  @SDL_FingerID()
  external int fingerId;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double x;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double y;

  /// < Normalized in the range -1...1
  @ffi.Float()
  external double dx;

  /// < Normalized in the range -1...1
  @ffi.Float()
  external double dy;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double pressure;

  /// < The window underneath the finger, if any
  @Uint32()
  external int windowID;
}

/// \brief Multiple Finger Gesture Event (event.mgesture.*)
final class SDL_MultiGestureEvent extends ffi.Struct {
  /// < ::SDL_MULTIGESTURE
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The touch device id
  @SDL_TouchID()
  external int touchId;

  @ffi.Float()
  external double dTheta;

  @ffi.Float()
  external double dDist;

  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @Uint16()
  external int numFingers;

  @Uint16()
  external int padding;
}

typedef SDL_GestureID = Sint64;

/// \brief Dollar Gesture Event (event.dgesture.*)
final class SDL_DollarGestureEvent extends ffi.Struct {
  /// < ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The touch device id
  @SDL_TouchID()
  external int touchId;

  @SDL_GestureID()
  external int gestureId;

  @Uint32()
  external int numFingers;

  @ffi.Float()
  external double error;

  /// < Normalized center of gesture
  @ffi.Float()
  external double x;

  /// < Normalized center of gesture
  @ffi.Float()
  external double y;
}

/// \brief An event used to request a file open by the system (event.drop.*)
/// This event is enabled by default, you can disable it with SDL_EventState().
/// \note If this event is enabled, you must free the filename in the event.
final class SDL_DropEvent extends ffi.Struct {
  /// < ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The file name, which should be freed with SDL_free(), is NULL on begin/complete
  external ffi.Pointer<ffi.Char> file;

  /// < The window that was dropped on, if any
  @Uint32()
  external int windowID;
}

/// \brief Sensor event structure (event.sensor.*)
final class SDL_SensorEvent extends ffi.Struct {
  /// < ::SDL_SENSORUPDATE
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The instance ID of the sensor
  @Sint32()
  external int which;

  /// < Up to 6 values from the sensor - additional values can be queried using SDL_SensorGetData()
  @ffi.Array.multi([6])
  external ffi.Array<ffi.Float> data;

  /// < The timestamp of the sensor reading in microseconds, if the hardware provides this information.
  @Uint64()
  external int timestamp_us;
}

/// \brief The "quit requested" event
final class SDL_QuitEvent extends ffi.Struct {
  /// < ::SDL_QUIT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;
}

/// \brief A user-defined event type (event.user.*)
final class SDL_UserEvent extends ffi.Struct {
  /// < ::SDL_USEREVENT through ::SDL_LASTEVENT-1
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The associated window if any
  @Uint32()
  external int windowID;

  /// < User defined event code
  @Sint32()
  external int code;

  /// < User defined data pointer
  external ffi.Pointer<ffi.Void> data1;

  /// < User defined data pointer
  external ffi.Pointer<ffi.Void> data2;
}

final class SDL_SysWMmsg extends ffi.Opaque {}

/// \brief A video driver dependent system event (event.syswm.*)
/// This event is disabled by default, you can enable it with SDL_EventState()
///
/// \note If you want to use this event, you should include SDL_syswm.h.
final class SDL_SysWMEvent extends ffi.Struct {
  /// < ::SDL_SYSWMEVENT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < driver dependent data, defined in SDL_syswm.h
  external ffi.Pointer<SDL_SysWMmsg> msg;
}

/// \brief General event structure
final class SDL_Event extends ffi.Union {
  /// < Event type, shared with all events
  @Uint32()
  external int type;

  /// < Common event data
  external SDL_CommonEvent common;

  /// < Display event data
  external SDL_DisplayEvent display;

  /// < Window event data
  external SDL_WindowEvent window;

  /// < Keyboard event data
  external SDL_KeyboardEvent key;

  /// < Text editing event data
  external SDL_TextEditingEvent edit;

  /// < Extended text editing event data
  external SDL_TextEditingExtEvent editExt;

  /// < Text input event data
  external SDL_TextInputEvent text;

  /// < Mouse motion event data
  external SDL_MouseMotionEvent motion;

  /// < Mouse button event data
  external SDL_MouseButtonEvent button;

  /// < Mouse wheel event data
  external SDL_MouseWheelEvent wheel;

  /// < Joystick axis event data
  external SDL_JoyAxisEvent jaxis;

  /// < Joystick ball event data
  external SDL_JoyBallEvent jball;

  /// < Joystick hat event data
  external SDL_JoyHatEvent jhat;

  /// < Joystick button event data
  external SDL_JoyButtonEvent jbutton;

  /// < Joystick device change event data
  external SDL_JoyDeviceEvent jdevice;

  /// < Joystick battery event data
  external SDL_JoyBatteryEvent jbattery;

  /// < Game Controller axis event data
  external SDL_ControllerAxisEvent caxis;

  /// < Game Controller button event data
  external SDL_ControllerButtonEvent cbutton;

  /// < Game Controller device event data
  external SDL_ControllerDeviceEvent cdevice;

  /// < Game Controller touchpad event data
  external SDL_ControllerTouchpadEvent ctouchpad;

  /// < Game Controller sensor event data
  external SDL_ControllerSensorEvent csensor;

  /// < Audio device event data
  external SDL_AudioDeviceEvent adevice;

  /// < Sensor event data
  external SDL_SensorEvent sensor;

  /// < Quit request event data
  external SDL_QuitEvent quit;

  /// < Custom event data
  external SDL_UserEvent user;

  /// < System dependent window event data
  external SDL_SysWMEvent syswm;

  /// < Touch finger event data
  external SDL_TouchFingerEvent tfinger;

  /// < Gesture event data
  external SDL_MultiGestureEvent mgesture;

  /// < Gesture event data
  external SDL_DollarGestureEvent dgesture;

  /// < Drag and drop event data
  external SDL_DropEvent drop;

  @ffi.Array.multi([56])
  external ffi.Array<Uint8> padding;
}

enum SDL_eventaction {
  SDL_ADDEVENT(0),
  SDL_PEEKEVENT(1),
  SDL_GETEVENT(2);

  final int value;
  const SDL_eventaction(this.value);

  static SDL_eventaction fromValue(int value) => switch (value) {
        0 => SDL_ADDEVENT,
        1 => SDL_PEEKEVENT,
        2 => SDL_GETEVENT,
        _ => throw ArgumentError("Unknown value for SDL_eventaction: $value"),
      };
}

typedef SDL_EventFilterFunction = ffi.Int Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<SDL_Event> event);
typedef DartSDL_EventFilterFunction = int Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<SDL_Event> event);

/// A function pointer used for callbacks that watch the event queue.
///
/// \param userdata what was passed as `userdata` to SDL_SetEventFilter()
/// or SDL_AddEventWatch, etc
/// \param event the event that triggered the callback
/// \returns 1 to permit event to be added to the queue, and 0 to disallow
/// it. When used with SDL_AddEventWatch, the return value is ignored.
///
/// \sa SDL_SetEventFilter
/// \sa SDL_AddEventWatch
typedef SDL_EventFilter
    = ffi.Pointer<ffi.NativeFunction<SDL_EventFilterFunction>>;

/// Flags used when creating a rendering context
enum SDL_RendererFlags {
  /// < The renderer is a software fallback
  SDL_RENDERER_SOFTWARE(1),

  /// < The renderer uses hardware
  /// acceleration
  SDL_RENDERER_ACCELERATED(2),

  /// < Present is synchronized
  /// with the refresh rate
  SDL_RENDERER_PRESENTVSYNC(4),

  /// < The renderer supports
  /// rendering to texture
  SDL_RENDERER_TARGETTEXTURE(8);

  final int value;
  const SDL_RendererFlags(this.value);

  static SDL_RendererFlags fromValue(int value) => switch (value) {
        1 => SDL_RENDERER_SOFTWARE,
        2 => SDL_RENDERER_ACCELERATED,
        4 => SDL_RENDERER_PRESENTVSYNC,
        8 => SDL_RENDERER_TARGETTEXTURE,
        _ => throw ArgumentError("Unknown value for SDL_RendererFlags: $value"),
      };
}

/// Information on the capabilities of a render driver or context.
final class SDL_RendererInfo extends ffi.Struct {
  /// < The name of the renderer
  external ffi.Pointer<ffi.Char> name;

  /// < Supported ::SDL_RendererFlags
  @Uint32()
  external int flags;

  /// < The number of available texture formats
  @Uint32()
  external int num_texture_formats;

  /// < The available texture formats
  @ffi.Array.multi([16])
  external ffi.Array<Uint32> texture_formats;

  /// < The maximum texture width
  @ffi.Int()
  external int max_texture_width;

  /// < The maximum texture height
  @ffi.Int()
  external int max_texture_height;
}

/// The structure that defines a point (floating point)
///
/// \sa SDL_EncloseFPoints
/// \sa SDL_PointInFRect
final class SDL_FPoint extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;
}

/// Vertex structure
final class SDL_Vertex extends ffi.Struct {
  /// < Vertex position, in SDL_Renderer coordinates
  external SDL_FPoint position;

  /// < Vertex color
  external SDL_Color color;

  /// < Normalized texture coordinates, if needed
  external SDL_FPoint tex_coord;
}

/// The scaling mode for a texture.
enum SDL_ScaleMode {
  /// < nearest pixel sampling
  SDL_ScaleModeNearest(0),

  /// < linear filtering
  SDL_ScaleModeLinear(1),

  /// < anisotropic filtering
  SDL_ScaleModeBest(2);

  final int value;
  const SDL_ScaleMode(this.value);

  static SDL_ScaleMode fromValue(int value) => switch (value) {
        0 => SDL_ScaleModeNearest,
        1 => SDL_ScaleModeLinear,
        2 => SDL_ScaleModeBest,
        _ => throw ArgumentError("Unknown value for SDL_ScaleMode: $value"),
      };
}

/// The access pattern allowed for a texture.
enum SDL_TextureAccess {
  /// < Changes rarely, not lockable
  SDL_TEXTUREACCESS_STATIC(0),

  /// < Changes frequently, lockable
  SDL_TEXTUREACCESS_STREAMING(1),

  /// < Texture can be used as a render target
  SDL_TEXTUREACCESS_TARGET(2);

  final int value;
  const SDL_TextureAccess(this.value);

  static SDL_TextureAccess fromValue(int value) => switch (value) {
        0 => SDL_TEXTUREACCESS_STATIC,
        1 => SDL_TEXTUREACCESS_STREAMING,
        2 => SDL_TEXTUREACCESS_TARGET,
        _ => throw ArgumentError("Unknown value for SDL_TextureAccess: $value"),
      };
}

/// The texture channel modulation used in SDL_RenderCopy().
enum SDL_TextureModulate {
  /// < No modulation
  SDL_TEXTUREMODULATE_NONE(0),

  /// < srcC = srcC * color
  SDL_TEXTUREMODULATE_COLOR(1),

  /// < srcA = srcA * alpha
  SDL_TEXTUREMODULATE_ALPHA(2);

  final int value;
  const SDL_TextureModulate(this.value);

  static SDL_TextureModulate fromValue(int value) => switch (value) {
        0 => SDL_TEXTUREMODULATE_NONE,
        1 => SDL_TEXTUREMODULATE_COLOR,
        2 => SDL_TEXTUREMODULATE_ALPHA,
        _ =>
          throw ArgumentError("Unknown value for SDL_TextureModulate: $value"),
      };
}

/// Flip constants for SDL_RenderCopyEx
enum SDL_RendererFlip {
  /// < Do not flip
  SDL_FLIP_NONE(0),

  /// < flip horizontally
  SDL_FLIP_HORIZONTAL(1),

  /// < flip vertically
  SDL_FLIP_VERTICAL(2);

  final int value;
  const SDL_RendererFlip(this.value);

  static SDL_RendererFlip fromValue(int value) => switch (value) {
        0 => SDL_FLIP_NONE,
        1 => SDL_FLIP_HORIZONTAL,
        2 => SDL_FLIP_VERTICAL,
        _ => throw ArgumentError("Unknown value for SDL_RendererFlip: $value"),
      };
}

/// A structure representing rendering state
final class SDL_Renderer extends ffi.Opaque {}

/// An efficient driver-specific representation of pixel data
final class SDL_Texture extends ffi.Opaque {}

/// A rectangle, with the origin at the upper left (floating point).
///
/// \sa SDL_FRectEmpty
/// \sa SDL_FRectEquals
/// \sa SDL_FRectEqualsEpsilon
/// \sa SDL_HasIntersectionF
/// \sa SDL_IntersectFRect
/// \sa SDL_IntersectFRectAndLine
/// \sa SDL_UnionFRect
/// \sa SDL_EncloseFPoints
/// \sa SDL_PointInFRect
final class SDL_FRect extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double w;

  @ffi.Float()
  external double h;
}

typedef SDL_TimerCallbackFunction = Uint32 Function(
    Uint32 interval, ffi.Pointer<ffi.Void> param);
typedef DartSDL_TimerCallbackFunction = DartUint32 Function(
    DartUint32 interval, ffi.Pointer<ffi.Void> param);

/// Function prototype for the timer callback function.
///
/// The callback function is passed the current timer interval and returns
/// the next timer interval. If the returned value is the same as the one
/// passed in, the periodic alarm continues, otherwise a new alarm is
/// scheduled. If the callback returns 0, the periodic alarm is cancelled.
typedef SDL_TimerCallback
    = ffi.Pointer<ffi.NativeFunction<SDL_TimerCallbackFunction>>;

/// Definition of the timer ID type.
typedef SDL_TimerID = ffi.Int;
typedef DartSDL_TimerID = int;

const int SDL_SWSURFACE = 0;

const int SDL_PREALLOC = 1;

const int SDL_RLEACCEL = 2;

const int SDL_DONTFREE = 4;

const int SDL_SIMD_ALIGNED = 8;

const int SDL_WINDOWPOS_UNDEFINED_MASK = 536805376;

const int SDL_WINDOWPOS_UNDEFINED = 536805376;

const int SDL_WINDOWPOS_CENTERED_MASK = 805240832;

const int SDL_WINDOWPOS_CENTERED = 805240832;

const int SDL_BUTTON_LEFT = 1;

const int SDL_BUTTON_MIDDLE = 2;

const int SDL_BUTTON_RIGHT = 3;

const int SDL_BUTTON_X1 = 4;

const int SDL_BUTTON_X2 = 5;

const int SDL_BUTTON_LMASK = 1;

const int SDL_BUTTON_MMASK = 2;

const int SDL_BUTTON_RMASK = 4;

const int SDL_BUTTON_X1MASK = 8;

const int SDL_BUTTON_X2MASK = 16;

const int SDL_RELEASED = 0;

const int SDL_PRESSED = 1;

const int SDL_TEXTEDITINGEVENT_TEXT_SIZE = 32;

const int SDL_TEXTINPUTEVENT_TEXT_SIZE = 32;

const int SDL_QUERY = -1;

const int SDL_IGNORE = 0;

const int SDL_DISABLE = 0;

const int SDL_ENABLE = 1;

const int SDL_INIT_TIMER = 1;

const int SDL_INIT_AUDIO = 16;

const int SDL_INIT_VIDEO = 32;

const int SDL_INIT_JOYSTICK = 512;

const int SDL_INIT_HAPTIC = 4096;

const int SDL_INIT_GAMECONTROLLER = 8192;

const int SDL_INIT_EVENTS = 16384;

const int SDL_INIT_SENSOR = 32768;

const int SDL_INIT_NOPARACHUTE = 1048576;

const int SDL_INIT_EVERYTHING = 62001;
